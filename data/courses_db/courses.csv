subject,ects,classtype,term,offered,first_year,description
Project: Coreforge,4,"analiza kodu źródłowego, prezentacja, projekt programistyczny",winter,True,False,"Celem projektu jest praktyczna nauka architektur komputerów poprzez ich implementację w formie umożliwiającej syntezę na układy FPGA. 

W ramach projektu powstaje rdzeń o nazwie Coreblocks, implementujący zestaw instrukcji [RISC-V](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf) (RV32I) w mikroarchitekturze out-of-order. Implementacja będzie miała w założeniu modularny charakter ""generatora rdzeni"", umożliwiający dodawanie, rekonfigurację i wymianę elementów składowych rdzenia bez głębokich zmian w kodzie.

Dalszymi celami projektu są:

* Integracja z generatorem układów SoC (System on Chip) [LiteX](https://github.com/enjoy-digital/litex), co umożliwi użycie rdzenia w charakterze mikrokontrolera.
* Budowa mechanizmów automatycznego testowania, umożliwiających sprawdzanie poprawności oraz parametrów wydajnościowych (np. maksymalna częstotliwość taktowania, liczba użytych zasobów FPGA) w miarę rozwoju projektu.
* Implementacja rozszerzeń architektury (na przykład: instrukcje mnożące i dzielące, instrukcje atomowe, operacje zmiennoprzecinkowe, instrukcje CSR).
* Implementacja [instrukcji uprzywilejowanych](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf) oraz port [OpenSBI](https://github.com/riscv-software-src/opensbi).
* Implementacja i eksperymenty z różnymi rodzajami predyktorów skoków, pamięci cache, itp.

Długoterminowym celem projektu jest uruchomienie na zaimplementowanym rdzeniu systemu operacyjnego Mimiker.

Praca nad projektem będzie miała charakter zespołowy. Student, po przydzieleniu zadania, powinien zapoznać się z wybraną tematyką, ustalić koncepcję implementacji oraz zaprezentować i przedyskutować ją podczas spotkania projektowego. Opracowany kod oraz dokumentacja projektu będzie podlegać recenzji ze strony prowadzącego oraz innych studentów."
Financial Services,5,"Wykład, ćwiczenia",winter,True,False,"**Przedmiot prowadzony przez dr hab., prof. UWr  Edytę Rutkowską z Instytutu Nauk Ekonomicznych.**

#### Cele przedmiotu
1. Przedstawienie kompleksowej wiedzy o istocie, specyfice i cechach charakterystycznych usług
finansowych oraz instytucji je świadczących (instytucji finansowych).
2. Zapoznanie studenta z zagrożeniami i ryzykiem związanym z usługami finansowymi.
3. Zapoznanie z całokształtem regulacji prawnych dotyczących usług finansowych.
#### Treści programowe
Pojęcie i specyfika usług finansowych (usługi bankowe, kredytowe, płatnicze, ubezpieczeniowe,
inwestycyjne); Klient usług finansowych (klient detaliczny, klient profesjonalny, konsument) Źródła
zagrożeń i ryzyka dla klientów usług finansowych. Regulacja usług finansowych w UE.

Podmioty świadczące legalnie usługi finansowe w UE. Zasady podejmowania i prowadzenia
działalności w zakresie świadczenia usług finansowych w UE.

Nowe technologie na rynku usług finansowych. Fin-Tech – problemy pojęciowe i regulacyjne.
Korzyści zagrożenia, - ryzyka dla konsumentów i wyzwania

Umowy o usługi finansowe i ich regulacja w UE - ogólna charakterystyka i tendencje dotyczące ich
regulacji w UE. Koszty usług finansowych (Odpłatność za usługi finansowe)- odsetki, opłaty, prowizje
i inne koszty ponoszone przez klientów). Obowiązki instytucji finansowych wobec klientów usług
finansowych

Usługi depozytowe ich charakterystyka i regulacja

Usługi typu kredytowego ich charakterystyka i regulacja (kredyt bankowy, kredyt hipoteczny, kredyt
konsumencki, konsumencki kredyt hipoteczny, odwrócony kredyt hipoteczny, leasing)

Usługi ubezpieczeniowe ich charakterystyka i regulacja. Dystrybucja usług ubezpieczeniowych

Usługi płatnicze ich charakterystyka i regulacja

Usługi inwestycyjne ich charakterystyka i regulacja

Usługi emerytalne ich charakterystyka i regulacja"
Course: Game Development in Unreal Engine 5,5,"Wykład, indywidualny lub zespołowy projekt programistyczny, samodzielna praca przy komputerze",winter,True,False,"W przeciwieństwie do kursu Unity nie będę omawiał silnika okno po oknie i właściwości po właściwości, zamiast tego pokażę jak napisać pięć przykładowych gier, od początku do końca używając silnika Unreal 5.

Gry które pojawią się na wykładzie:
- rozbijanie ściany z beczek (fizyka, podstawy, blue printy)
- platformówka z przeszkodami (skrypty c++, animacje, postacie humanoidalne)
- lochy (programowanie obiektowe, kolizje, input system)
- czołgi (multi player, game framework)
- TPS (third person shooter, animacje, AI, GUI)

Dodatkowo omówienie systemu technologii oświetlenia globalnego ""Lumen"" oraz systemu ""Nanite"" umożliwiającego budowę scen 3D o bardzo dużym poziomie szczegółowości.

Kurs nie jest od podstaw, co oznacza, że wymaga wcześniejszej znajomości C++ i podstaw programowania."
Combinatorial Optimization under uncertainty,6,wykład,winter,True,False,"Rozważmy portal randkowy (nie tinder), w którym są 44 tysiące kobiet i 44 tysięce mężczyzn. Portal zarabia na miesięcznej subskrypcji, a jego zadaniem jest proponowanie użytkownikom randek. Portal używając danych użytkowników (np. z ankiet na temat cech charakteru, ulubionych filmów i muzyki itd) jest w stanie całkiem nieźle wyestymować dla każdej pary użytkowników prawdopodobieństwo, że dana para się sobie wzajemnie spodoba, o ile tylko pójdzie na randkę.
Pytanie jednak jest następujące: w jaki sposób portal powinien proponować randki, aby zmaksymalizować średnią (lub też totalną w ciągu roku) liczbę szczęśliwie skojarzonych par? Nie możemy przecież wysłać żadnego użytkownika na 100 nieudanych randek, bo do tego czasu zrezygnuje z subskrypcji. Musimy więc robić to ostrożnie. Co więcej dana para, jeśli tylko się sobie spodoba, to natychmiast opuszcza portal (a przynajmniej takie jest sensowne założenie). 
Gdyby nie było tutaj żadnej niepewności i a priori byśmy wiedzieli, które pary się sobie spodobają, a które nie, to naszym zadaniem byłoby obliczenie po prostu maksymalnego skojarzenia w grafie, które możemy zrobić całkiem sprawnie w czasie wielomianowym.
Ale gdy uwzględnimy stochastyczną naturę, czyli że randki mogą się udać albo się nie udać, to problem --- mimo, że cały czas dotyczy skojarzeń w grafach --- staje się nagle zgoła inny. Co więcej, teraz nawet nie tyle, co nie znamy wielomianowego algorytmu, ale nawet nie wiemy, czy ten problem należy do klasy NP. Mimo wszystko na wykładzie zobaczymy 2-aproksymacyjny algorytm dla tego problemu.

Istotą tego przydługiego wstępu była ilustracja faktu, że bardzo często prawdziwie praktyczne problemy mają pewien aspekt niepewności w sobie, a ten z kolei wymusza zupełnie inne podejście do problemu niż w przypadku jego deterministycznego odpowiednika. 
Na wykładzie przedstawię kilka klasycznych modeli niepewności: stochastyczne próbkowanie (przykład portalu randkowego), problem sekretarki (https://en.wikipedia.org/wiki/Secretary_problem), nierówność Proroka (https://en.wikipedia.org/wiki/Prophet_inequality) i algorytmy online oraz jak w tych modelach rozważać struktury kombinatoryczne takie jak skojarzenia lub matroidy (na wykładzie wytłumaczę co to).

Przedmiot będzie mocno matematyczny, a nawet mocno probabilistyczny, jednak nie będziemy potrzebować żadnego zaawansowanego aparatu --- znajomość warunkowej wartości oczekiwanej w zupełności wystarczy."
Tutoring,0,,winter,True,True,"Celem tutoringu jest czuwanie nad właściwą organizacją pracy przez
studenta, śledzenie jego postępów i pomoc w sytuacjach trudnych.

Zajęcia w ramach przedmiotu nie mają wyznaczonych cotygodniowych terminów, lecz odbywają się kilkakrotnie w czasie semestru w terminach wyznaczonych przez prowadzących, w ramach spotkań indywidualnych lub grupowych. Dodatkowo prowadzący są do
dyspozycji studentów na bieżąco, gdy pojawiają się problemy związane z tokiem studiów."
Combinatorial optimization,6,"* Ćwiczenia audytoryjne
* Wykład monograficzny",winter,True,False,"**Program:**

1.Matchingi.

Matchingi (skojarzenia) oraz ich uogólnienia pojawiają się w bardzo wielu
kontekstach, bardziej i mniej oczywistych, m.in. przy:

  * różnego typu przydziałach: zadań pracownikom lub maszynom, studentów szkołom itp.

  * obliczaniu podgrafów, w których każdy wierzchołek ma mieć stopień z podanego przedziału. Za pomocą skojarzeń oblicza się np. pokrycia cyklowe (podgrafy, w kt. każdy wierzchołek ma mieć stopień 2) o najmniejszej/największej wadze. Takie pokrycia przydają się z kolei w znajdowaniu optymalnych dróg komiwojażera,

  * aukcjach.

2.Matroidy.

Przykładami matroidów są lasy w grafach i podzbiory niezależnych liniowo
kolumn danej macierzy.

3.Rozlaczne sciezki, T-joins i T-cuts.

T-joiny mają zastosowania m.in. w wykrywaniu cykli o ujemnej wadze.

4.Przeplywy.

**Wymagania:** matematyka dyskretna, algorytmy i struktury danych"
Digital Image Processing,6,"* lecture
* programming lab
* programming project
* tutorial
* individual computer work",winter,True,False,"Przedmiot może się odbyć w języku polskim lub angielskim o czym możemy zadecydować na pierwszych zajęciach  
(Language can be switched to English or Polish, we can decide about it on the first lecture). 

Advances in digital photography have made great interest in Digital Image Processing (DIP) area and created new research field of Computational Photography (CP). In this lecture we will present both classical DIP methods which are the main tools in image editors as well as the new methods from the CP.

**Topics:**

  1. Color Science and High Dynamic Range Imaging
  2. Per pixel operations, histograms, combining images
  3. Geometrical operations eg. distortion correction
  4. Linear filtering and Fourier transforms
  7. Edge detection
  6. Nonlinear filters eg. median, bilateral
  8. Morphological operators: dylation and erosion
  9. Multiresolution representations
  10. Keypoint detection and image registration
  11. Image segmentation, graphcuts and texture synthesis
  12. Gradient domain image processing

**Requirements:** 
 * some maths: Calculus and Algebra 
 * programming skills: prefered C/C++
 * knowledge of Computer Graphics can be beneficial"
Algebra,7,"* Ćwiczenia audytoryjne
* Wykład",winter,True,True,"**Program:**

1. Przestrzenie liniowe. Zbiory liniowo niezależne. Bazy.
2. Macierze i przekształcenia liniowe. Rząd macierzy. Algorytm eliminacji Gaussa.
3. Wyznaczniki. Własności wyznaczników. Rozwinięcie Laplace’a. 
4. Równania liniowe. Zbiór rozwiązań układu równań liniowych. Wzory Cramera.
5. Wartości i wektory własne. Podprzestrzenie niezmiennicze. Wielomian charakterystyczny.
6. Iloczyn skalarny. Rzut ortogonalny. Izometrie i przekształcenia ortogonalne.
7. Elementy geometrii.
8. Grupy — podstawowe pojęcia: rząd grupy, rząd elementu grupy, podgrupa.
9. Grupy permutacji. Rozkład permutacji na cykle. Znak permutacji. 
10. Działanie grupy na zbiorze.
Orbity i stabilizatory. Lemat Burnside’a. Warstwy. Twierdzenie Lagrange’a.
11. Arytmetyka modularna. Relacja podzielności. Pierścienie i pierścienie Zn.
12. Algorytm Euklidesa. Chińskie twierdzenie o resztach.
13. Pierścienie wielomianów. Podzielność wielomianów.
14. Przykład konstrukcji ciała skończonego.

**Wymagania:**
* Matematyka w zakresie szkoły średniej.
* Podstawy analizy
matematycznej.
* Podstawy logiki i teorii mnogości.

**Literatura**

W zasadzie każda książka do algebry liniowej i algebry
powinna pokryć przerabiany materiał. Poniżej przykładowe pozycje.

1. A. Białynicki-Birula, Algebra
2. G. Birkhoff, S. Mac Lane, Przeglad algebry współczesnej
3. B. Gleigchgewicht,
Algebra
4. A. Kostrikin, J. Manin Algebra liniowa i geometria
5. A. Kostrikin, Zbiór zadań z algebry
6. A. Kostrikin, Wstęp do algebra t. 1-3
7. A. Mostowski, M. Stark, Elementy algebry wyższej
8. A. Mostowski, M. Stark, Algebra liniowa
9. J. Rutkowski, Algebra abstrakcyjna w zadaniach"
Deep Learning (project),6,* projekt programistyczny,winter,True,False,"Celem projektu jest doskonalenie umiejętności programowania metod związanych z
głębokim uczeniem (ang. _deep learning_ ).

W ramach projektu omówione zostaną zastosowania głębokich sieci neuronowych do przetwarzania tekstu i obrazów.

W programie projektu przewiduje się programowanie sieci związanych z klasyfikacją, detekcją obiektów oraz segmentacją obrazów za pomocą takich
sieci neuronowych jak:
  * głębokie sieci splotowe (deep convolutional neural networks, CNN)
  * region-based CNN (RCNN)
  * Mask-RCNN
  * Fast-RCNN, Faster-RCNN

Realizacja projektu będzie wymagała zaprogramowanie całości procesu:
* pobeiranie i przetwarzanie danych
* przygotowanie danych do uczenia i testowania
* utworzenie odpowiedniego modelu
* tranowanie i walidacja modelu
* testowanie modelu
* zapisywanie pośrednich stanów modelu
* otwrzoenie podsumowania z istotnymi dla zadania metrykami.


**Wymagania:** wiedza z analizy matematycznej,
ukończenie przedmiotu z sieci neuronowych, umiejętność programowania w języku Python."
Artificial Intelligence,6,"Wykład, prezentacja, rozwiązywanie zadań z komentowaniem, dyskusja, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze, indywidualny projekt programistyczny",winter,True,False,"Sztuczna inteligencja jest dziedziną budzącą emocje. Chyba każdy programista
chciałby, żeby jego programy (przynajmniej niektóre) działały inteligentnie,
czyli tak jak ludzie, tylko szybciej i bardziej bezbłędnie.

Z drugiej strony budzi też obawy: czy ONE (komputery) będą myśleć lepiej niż
MY (ludzie)? Czy komputer lepszy od człowieka (swego twórcy), będzie mógł
tworzyć jeszcze bardziej inteligentne komputery?

Niniejszy wykład ma na celu przedstawienie najistotniejszych wątków sztucznej
inteligencji, czyli dziedziny, która próbuje modelować zachowanie inteligentne
i tworzyć systemy, które to zachowanie przejawiają.

Choć wykład ma być dość ogólny i przeglądowy, będziemy starać się, by student,
który go ukończy, nie tylko wiedział, jak używać wybrane metody sztucznej
inteligencji, ale je również dobrze rozumiał, potrafił zaimplementować i
zmodyfikować na potrzeby konkretnego zadania.

Będziemy omawiać następujące zagadnienia:
* Modelowanie rzeczywistości za pomocą przestrzeni stanów, metody przeszukiwania z więdzą o problemi i bez wiedzy
* Przeszukiwanie metaheurystyczne: hill climbing, symulowane wyżarzanie, beam search, algorytmy ewolucyjne.
* Rozwiązywanie więzów, wnioskowanie w sieci więzów
* programy grające w różne gry (w tym gry z niepełną informacją), zagadnienia uczenia się strategii, podstawy teorii gier, 
* Decyzyjne procesy Markowa, uczenie ze wzmocnieniem
* uczenie z nadzorem i bez nadzoru
* Modelowanie za pomocą logiki, metody wnioskowania
* Sieci Bayesowskie 
* Wybrane elementy innych dziedzin sztucznej inteligencji


Niektóre zagadnienia mają naturalną kontynuację na przedmiotach Machine learning, Eksploracja danych, Neural Networks and Natural Language Processing, Text mining
czy AI for games -- w takich przypadkach będziemy
koncetrowali się na podstawach tych dziedzin, pozostawiając zainteresowanemu
studentowi możliwość ich zgłębienia na dedykowanych przedmiotach.


W przypadku konieczności organizowania zajęć w formie zdalnej, studenci otrzymają nagrane wykłady, ćwiczenia będą w przeprowadzone z deklaracjami i wspólną pracą nad Raportem z ćwiczeń, zadania na pracownie będą konsultowane i odbierane przy użyciu systemu telekonferencyjnego.

Edycja 2022/2023 będzie miała nową sprawdzaczkę do zadań i nieco większy nacisk na zagadnienia uczenia maszynowego"
From Mordor to Matrix. The Fantastic Political Philosophy,3,Wykład,winter,True,True,"* Przedmiot prowadzony przez dr. hab Bartosza Bolechówa z Instytutu Politologii. *

Zapoznanie studentów z problematyką będącą przedmiotem zainteresowania
filozofii oraz antropologii polityki (natura polityki, wspólnoty politycznej i człowieka
jako „zwierzęcia politycznego”; uniwersalne mechanizmy i aporie władzy,
koncepcje strukturalnej organizacji społeczeństwa; pochodzenie, zmienność,
ewolucja– progres, regres, cykliczność - i postulowana wartość moralna ustrojów
oraz instytucji politycznych; światopoglądy, ideologie, modele polityczne i ich
zderzenia z praxis; legitymizacja; dyskurs polityczny; konflikt społeczny;
rewolucja i wojna; mechanizmy fanatyzmu, ekstremizmu i radykalizmu, utopia
jako fikcja spekulatywna; dystopia jako krytyka polityczna, sprzężenie zwrotne
między nieuświadomioną i uświadomioną fikcją a praktyką polityczną) poprzez
analizę utworów, gatunków, konwencji i toposów historycznej oraz współczesnej
fantastyki."
Professional Practice,4,Realizacja zadań postawionych przez pracodawcę.,winter,True,False,Zaliczenie praktyki zawodowej jest wymagane do ukończenia studiów pierwszego stopnia.
Mentoring for Data Science,0,,winter,True,False,A series of meetings with a teacher designated as mentor for Data Science students. Students are welcome to make individual appointments with the mentor whenever they need advice or help in all academic matters.
Sport programming in practice,2,,winter,True,False,"Na zajęciach studenci będą rozwiązywali zadania z zespołowych zawodów  
programistycznych. Każde spotkanie będzie miało formę pięciogodzinnego  
treningu przygotowanego na podstawie jednego z konkursów organizowanych  
w formule ICPC. Głównym celem zajęć jest przygotowanie drużyn, które  
reprezentują Uniwersytet Wrocławski w Akademickich Mistrzostwach Polski  
w Programowaniu Zespołowym, a później w zawodach ICPC. Ta drużynowa  
formuła nie oznacza jednak, że warunkiem uczestniczenia w zajęciach jest  
posiadanie stałej drużyny, gdyż celem naszych spotkań będzie także  
sprawdzenie w praktyce różnych strategii i składów zespołów."
Clone: Financial Services,3,"Wykład, ćwiczenia",winter,True,False,"**Przedmiot prowadzony przez dr hab., prof. UWr  Edytę Rutkowską z Instytutu Nauk Ekonomicznych.**

#### Cele przedmiotu
1. Przedstawienie kompleksowej wiedzy o istocie, specyfice i cechach charakterystycznych usług
finansowych oraz instytucji je świadczących (instytucji finansowych).
2. Zapoznanie studenta z zagrożeniami i ryzykiem związanym z usługami finansowymi.
3. Zapoznanie z całokształtem regulacji prawnych dotyczących usług finansowych.
#### Treści programowe
Pojęcie i specyfika usług finansowych (usługi bankowe, kredytowe, płatnicze, ubezpieczeniowe,
inwestycyjne); Klient usług finansowych (klient detaliczny, klient profesjonalny, konsument) Źródła
zagrożeń i ryzyka dla klientów usług finansowych. Regulacja usług finansowych w UE.

Podmioty świadczące legalnie usługi finansowe w UE. Zasady podejmowania i prowadzenia
działalności w zakresie świadczenia usług finansowych w UE.

Nowe technologie na rynku usług finansowych. Fin-Tech – problemy pojęciowe i regulacyjne.
Korzyści zagrożenia, - ryzyka dla konsumentów i wyzwania

Umowy o usługi finansowe i ich regulacja w UE - ogólna charakterystyka i tendencje dotyczące ich
regulacji w UE. Koszty usług finansowych (Odpłatność za usługi finansowe)- odsetki, opłaty, prowizje
i inne koszty ponoszone przez klientów). Obowiązki instytucji finansowych wobec klientów usług
finansowych

Usługi depozytowe ich charakterystyka i regulacja

Usługi typu kredytowego ich charakterystyka i regulacja (kredyt bankowy, kredyt hipoteczny, kredyt
konsumencki, konsumencki kredyt hipoteczny, odwrócony kredyt hipoteczny, leasing)

Usługi ubezpieczeniowe ich charakterystyka i regulacja. Dystrybucja usług ubezpieczeniowych

Usługi płatnicze ich charakterystyka i regulacja

Usługi inwestycyjne ich charakterystyka i regulacja

Usługi emerytalne ich charakterystyka i regulacja"
Tutoring ISIM,0,,winter,True,True,"Celem tutoringu jest czuwanie nad właściwą organizacją pracy przez
studenta, śledzenie jego postępów i pomoc w sytuacjach trudnych.

Zajęcia w ramach przedmiotu nie mają wyznaczonych cotygodniowych terminów, lecz odbywają się kilkakrotnie w czasie semestru w terminach wyznaczonych przez prowadzących, w ramach spotkań indywidualnych lub grupowych. Dodatkowo prowadzący są do
dyspozycji studentów na bieżąco, gdy pojawiają się problemy związane z tokiem studiów."
Seminar: Analysis of algorithmic problems,3,,winter,True,True,"Uwaga: seminarium planujemy prowadzić (pod taką samą nazwą) zarówno w semestrze zimowym jak i letnim. Można je będzie zaliczyć więcej niż raz.

Zajęcia będą poświęcone analizie trudnych zadań z zawodów programistycznych
typu ICPC, TopCoder, czy Google Code Jam.

Głównym celem spotkań będzie zarówno zapoznanie studentów z ogólnymi
zaawansowanymi technikami algorytmicznymi, które przydają się w takich
problemach, a nie są przedstawiane na wykładzie z Algorytmów i Struktur
Danych, jak i regularne omawianie ciekawszych zadań, które pojawią się na
niedawno przeprowadzonych konkursach. Podczas dyskusji zostaną poruszone także
bardziej praktyczne kwestie sprawnej implementacji skomplikowanych rozwiązań.

Zajęcia są przeznaczone dla studentów, którzy zdobyli już spore doświadczenie
podczas startów w zawodach programistycznych podczas studiów lub z sukcesami
startowali w Olimpiadzie Informatycznej.

Jeśli prowadzenie zajęć stacjonarnych okaże się niemożliwe to seminarium będzie miało formę spotkań online."
Geometric Optimization,6,,winter,True,False,"The course will be given by Sandip Banerjee.
It will cover the following topics:

1) Randomized Incremental Construction (RIC) (2-3 lectures)
* Random sampling in computational geometry
* Convex hull, Dynamic maintenance using RIC
* RIC of Delaunay and Voronoi diagrams.

2) Epsilon-approximation and Epsilon-nets (2 lectures)
* Basic definitions, applications, range space and VC-dimension
 * Discrepancy

3) Geometric covering problems (2-3 lectures)
* Geometric Covering and packing problems
* Geometric hitting set problem

4) Coresets and Clustering (3-4 lectures)
*  Centroid based like k-center, k-median, k-means and Density based clustering
        like min-sum clustering 

5) Metric embedding (3-4 lectures)

 * Basic definition, doubling metric, distortion
 * Emedding into l_p space
 * JL-lemma
 * Probabilistic embedding

6) Network design (2-3 lectures)
* Eucledian spanners
* Well-separated pair decomposition
* Euclidean TSP

Pre-requisite: (i) Algorithm course.(ii) Basic idea of Linear programming and probability
will help but not mandatory. 

Literature: A large part of the course will follow the books:

   (i) Geometric approximation algorithms (Author- Sariel Har-Peled)

   (ii) Algorithmic geometry (Author- J.D. Boissonnat,  Mariette Yvinec and
           Herve Bronniman)"
Diploma Project,4,"Studenci prezentują wyniki etapów realizacji pracy dyplomowej
Podczas zajęć następuje systematyzacja wiedzy i rozwinięcie umiejętności planowania zakresu i przebiegu produktu przedsięwzięcia informatycznego.
Przedmiot  Projekt Dyplomy ma charakter wspomagający przygotowanie, redakcje i kompletacje  dokumentacji  i innych produktów wytwarzanych w celu osiągnięcia celu pracy dyplomowej.
 Zajęcia przygotowują do samodzielnego i świadomego współudziału w analizie zagadnień, kształtowaniu i planowaniu projektów informatycznych.",winter,True,False,W ramach przedmiotu studenci przygotowują prace dyplomową wymaganą do zakończenie studiów lic/inż pod kierunkiem dr. inż Leszka Grocholskiego. Tematy proc dyplomowych wymagają zaakceptowania przez Komisję ds. Prac Dyplomowych.
Object-oriented Software Development,6,"* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",winter,True,False,"Wykład skierowany jest do przyszłych architektów systemów informatycznych oraz
do wszystkich programistów zainteresowanych udoskonaleniem swojego warsztatu.
Celem wykładu jest zapoznanie studentów z kanonem współczesnych narzędzi w
zakresie projektowania obiektowego oprogramowania.

Materiał wykładu obejmuje:

  * podstawy języka UML w zakresie wymaganym przez projekty analityczne i techniczne
  * zasady SOLID i GRASP
  * przegląd katalogu wzorców projektowych (GoF) (m.in. Observer, Builder, Bridge, State, Strategy, Facade, Adapter, Mediator, itd.)
  * przegląd katalogu wzorców architektury aplikacji (wzorce architektoniczne) (m.in. Model-View-Controller, Object-Relational Mapping, Dependency Injection, Service Locator, Mock Object, itd.)
  * przegląd katalogu wzorców architektury systemów (Enterprise Service Bus, Single Sign-on)

Celem pracowni jest praktyczny kontakt z materiałem z wykładu.

Wymagania: ukończony kurs języka Java lub C# (wszystkie przykłady będą
bazowały na języku C#)

Literatura:

  1. Wrycza, Marcinkowski, Wyrzykowski - Język UML 2.0 w modelowaniu systemów informatycznych
  2. Fowler - Refactoring: Improving the Design of Existing Code Gamma, Helm, Johnson, Vlissides: Design Patterns: Elements of Reusable Object-Oriented Software
  3. Fowler - Patterns of Enterprise Application Architecture Microsoft Patterns & Practices - Application Architecture Guide"
Project: Development of the Enrollment System,4,"* Projekt programistyczny
* Pracownia programistyczna",winter,True,False,"W ramach projektu grupa studentów rozwija istniejący System Zapisów na zajęcia: ulepsza istniejące funkcjonalności, usuwa niepotrzebne i wprowadza nowe.

System Zapisów napisany jest w Pythonie z użyciem framework-u Django, a elementy front-endowe zazwyczaj powstają w TypeScript'cie. Jednakowoż znajomość tych technologii nie jest warunkiem koniecznym uczestnictwa w projekcie. Oczekuje się od studentów raczej gotowości do zanurzenia się w dużym, istniejącym projekcie, rozpoznania terenu i wykonywania w nim zadań.

Przedmiot zalicza wymaganie projektu zespołowego. Można uczestniczyć w nim wielokrotnie.

Praca zespołowa studentów oparta jest na GitHubie (issue, pull-request, code-review), a bieżąca komunikacja jest asynchroniczna (z wykorzystaniem komunikatora)."
Seminar: Software Engineering,3,Prepared by students lectures,winter,True,False,"During Seminar Software Engineering Students  present popular standards, methods, tools use during software development. 
In presentation it is particularly important for students who work in leading IT companies to inform less experience students information about what methods they use and what tools they use when developing software.
Seminar aimed at inspiring future software engineers for self-development  and  self-preparation for professional work."
Digital logic,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",winter,True,True,"Wykład jest wprowadzeniem do projektowania układów cyfrowych. Celem wykładu
jest nauczenie zasad rządzących funkcjonowaniem elektroniki cyfrowej oraz
typowych rozwiązań stosowanych przy projektowaniu układów. Wiedza zdobyta na
wykładzie pomoże w zrozumieniu zasady działania mikroprocesorów i
mikrokontrolerów oraz zasad rządzących programowalnymi układami logicznymi
FPGA.

#### Wymagania

Wykład nie wymaga wcześniejszego zaliczenia innych przedmiotów.

#### Program

  1. Wprowadzenie do układów cyfrowych
  2. Technologie implementacji układów cyfrowych
  3. Elementy Veriloga jako języka opisu sprzętu
  4. Optymalizacja funkcji logicznych
  5. Układy arytmetyczne
  6. Podstawowe układy kombinacyjne
  7. Zatrzaski i przerzutniki
  8. Automaty Moore'a i Mealy'ego
  9. Układy sekwencyjne
  10. Budowa prostego procesora

#### Literatura

  * Fundamentals of Digital Logic with Verilog Design; Brown, Vranesic; McGraw-Hill
  * Digital Design: With an Introduction to the Verilog HDL, VHDL, and SystemVerilog (6th Edition); Mano, Ciletti; Pearson"
Programming methodology,9,"wykład, live coding, dyskusja, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań, samodzielna praca przy komputerze",winter,True,True,"Naszym celem jest przygotowanie studentów do używania języków programowania
jako formalnych narzędzi komunikacji między ludźmi, w szczególności jako
technik które mogą i powinny być stosowane do zapanowania nad złożonością
intelektualną dużych systemów. W tym celu zajmiemy się zarówno konkretnymi
narzędziami których projektanci języków programowania dostarczają
programistom, jak i ogólnymi zasadami konstrukcji języków programowania.

Wykład prowadzą Marek Materzok, Maciej Piróg i Filip Sieczkowski.

#### Program:

  1. Elementy programowania
  2. Rekursja i abstrakcja proceduralna
  3. Wprowadzenie do abstrakcji danych
  4. Dane hierarchiczne i własność domknięcia
  5. Dane symboliczne i wielorakie reprezentacje danych
  6. Składnia abstrakcyjna i podstawy ewaluacji
  7. Środowiskowy model obliczeń
  8. Ewaluator metacykliczny
  9. Reprezentacja wartości w metajęzyku
  10. Składnia konkretna jako język dedykowany
  11. Zarządzanie złożonością: kontrakty
  12. Zarządzanie złożonością: systemy typów
  13. Obliczenia z danymi modyfikowalnymi
  14. Elementy programowania współbieżnego
  15. Programowanie w logice"
Economic Policy Policy,3,Wykład,winter,True,False,"*Przedmiot prowadzony przez dr. Mirosława Strusia z  Instytutu Nauk Ekonomicznych.*

Celem przedmiotu jest zapoznanie studentów z podstawami i głównymi
pojęciami polityki gospodarczej w otwartej gospodarce rynkowej, w celu umożliwienia im lepszego
zrozumienia głównych zagadnień i problemów związanych z przebiegiem procesów gospodarczych."
C++ course,5,"Wykład, live coding, analiza programów dostarczonych przez wykładowcę, konsultowanie pomysłów na rozwiązania zadań, samodzielna praca programistyczna w domu oraz na zajęciach.",winter,True,True,"**C++** to język programowania o charakterze obiektowym.
Jest to obecnie jeden z najbardziej znanych i popularnych języków programowania, wykorzystywany w różnych działach IT ale przede wszystkim do programowania systemowego, aplikacji narzędziowych, wykonywania obliczeń inżynierskich oraz do tworzenia gier komputerowych. 
Charakteryzuje się wysoką wydajnością kodu wynikowego, przenaszalnością tego kodu pomiędzy różnymi platformami oraz łatwością tworzenia i używania z bibliotek. 
C++ jest na pewno podstawowym narzędziem pracy milionów programistów na całym świecie.

Język C++ jest potomkiem języka C.
Te dwa języki są do siebie podobne składniowo ale w istocie mocno się różnią.
Prace nad tym językiem rozpoczął duński naukowiec Bjarne Stroustrup już w 1979 roku.
Nazwa języka ukonstytuowała się w roku 1983, kiedy to po raz pierwszy użyto go poza laboratorium naukowym. 
Natomiast pierwszy oficjalny standard C++ ISO/IEC 14882-1998 został opublikowany dopiero w 1998 roku.

Kurs C++ jest poświęcony nauce programowania obiektowego w C++.
Jest to język bardzo różnorodny, dający olbrzymie możliwości optymalizacji kodu, wyposażony w obszerną bibliotekę standardową. 
Na kursie można się zapoznać z bogatą składnią tego języka, wieloma technikami programistycznymi oraz trikami pozwalającymi łatwo rozwiązywać pewne standardowe ale trudne zadania.
Omawiane są także najważniejsze fragmenty biblioteki STL."
Numerical Optimization,8,"Lecture, problem solving in class, individual work at the computer, programming project",winter,True,False,"_Mandatory course for Data Science._

This course is a detailed survey of optimization from both a computational and theoretical perspective. Theoretical topics include convex sets, convex functions, optimization problems, least-squares, linear and quadratic programs, optimality conditions, and duality theory. Special emphasis is put on scalable numerical methods for analyzing and solving general smooth unconstrained problems (e.g. first-order and second-order methods), quadratic programs (e.g. linear least squares), general smooth constrained problems (e.g. interior-point methods), as well as, a family of non-smooth problems (e.g. ADMM method).

The applications in data sciences, such as machine learning, model fitting, and image processing, will be discussed. The computational part covers the following algorithms: gradient method, quasi-Newton methods, proximal gradient method, Nesterov’s accelerated gradient method and stochastic gradient descent method. Students complete hands-on exercises using high-level numerical software.

## Prerequisites
- not scared of math
- good knowledge of linear algebra
- multivariable calculus skills
- programming skills; Python is recommended.

## Topics overview
- (Numerical) Linear algebra review
- Iterative methods solving linear system of equations
- First and second order methods + quasi Newton methods
- Convex Functions
- Unconstrained Optimization
- Stochastic Methods"
Algorithms and Data Structures,9,"wykład, rozwiązywanie zadań z komentowaniem, indywidualne rozwiązywanie zadań, analiza algorytmów (poprawność, złożoność), indywidualne rozwiązywanie zadań programistycznych",winter,True,False,"Zajęcia do przedmiotu prowadzone są razem z zajęciami na poziomie M. Chętni na
Algorytmy i struktury danych (M) powinni zapisywać się na zajęcia do
Algorytmów i struktur danych (L). W praktyce przedmioty różnią się wymiarem
pracowni (liczbą wymaganych zadań), wymaganiami na zaliczenie oraz wymaganiami
na egzaminie.

W bieżącym roku ćwiczenia będą prowadzone w wymiarze 3h tygodniowo, z czego trzecia godzina jest nieobowiązkowa na poziomie L."
Cryptography,6,"wykład, wykład interaktywny, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów",winter,True,False,"**Cel zajęć:**

Celem wykładu jest zapoznanie uczestnikow z nowoczesnymi metodami służącymi do
ochrony prywatnosci danych elektronicznych, autentyfikacji użytkownikow
systemow komputerowych, zabezpieczaniu przed nieuprawnionymi modyfikacjami
danych i innymi tego typu zastosowaniami opartymi na technikach
kryptograficznych. Znaczenie tego typu metod ujawnia się szczegolnie ostro w
epoce powstawania globalnych sieci komputerowych, gdzie systemy operacyjne nie
gwarantują już bezpieczeństwa.

Głowny nacisk położony zostanie na prezentację metod albo obecnie stosowanych,
bądź też wchodzących do praktyki. Niemniej jednak uczestnicy wykładu będą
mieli okazję zapoznania się z materiałem teoretycznym będącym podstawa dla
zrozumienia tych metod.

Uczestnicy zajęc przygotowani zostaną do pracy w zakresie projektowania i
użytkowania systemow w zakresie problematyki bezpieczeństwa.

**Program:**

  * podstawowe rodzaje funkcji kryptograficznych, szyfrowanie symetryczne, asymetryczne, hashowanie, itp.;
  * podstawowe protokoły kryptograficzne: dzielenie tajemnic, zobowiązanie bitowe, pieniądze cyfrowe, elektroniczne wybory;
  * algorytmy symetryczne: DES, IDEA, rozszerzenia DES-a, RC5;
  * tryby pracy: ECB, CBC, CFB;
  * kryptoanaliza rożnicowa, liniowa, błędow;
  * algorytmy asymetryczne: RSA, ElGamal;
  * funkcje hashujące: oparte o dyskretny logarytm, MD5, tryby pracy;
  * generatory pseudolosowe: LFSR, BBS;
  * podpisy cyfrowe: ElGamal, DSA, ślepe podpisy, kanał podprogowy, podpisy niezaprzeczalne,
  * uwierzytelnianie: challenge and response, dowody interakcyjne i z wiedzą zerową, protokoł Schnorra, podpisy cyfrowe przez uwierzytelnianie;
  * administracja kluczami: przechowywanie kluczy, uzgadnianie kluczy, protokoł Diffie-Hellmana i jego pochodne;
  * plastikowe pieniądze: smart cards, PIN;
  * protokoły zabezpieczania komunikacji: Kerberos, ssh, SSL, cyfrowa komunikacja telefoniczna;
  * szyfrowanie systemow plikow;
  * protokoły obrotu finansowego
  * systemy oparte na krzywych eliptycznych.

**Wymagania:** Matematyka dyskretna"
Neural Networks and Natural Language Processing,6,"* Programming project
* Programming laboratories
* Research project
* Lecture

In case of further University lockdown the course will be offered remotely:

* Lectures will be delivered over a videconference system and recorded
* Assignments will be graded using a combination of automatic grading tools and presentations over conferencing systems
* The project will feature presentations given to other students
* The final exam may be held remotely in the form of quizzes and oral evaluations during 1-on-1 calls",winter,True,False,"Neural Networks allow creation of programs that are learned rather than written. This means that instead of implementing a concrete algorithm, the program applies patterns that are automatically found in the data. For example, a translation system such as Google Translate can be created by applying a deep neural network to a large corpus of translated documents. The aim of this course is to present the basics of how neural networks work, both from a more theoretical and practical point of view. Neural Networks can be applied to a wide spectrum of tasks, including image and video processing, creating game playing agents, financial data analysis, or even using a computer as a writer, painter or composer. We will try to address many such issues with the emphasis on natural language processing.

The lecture can be treated as a continuation of the following courses: Machine Learning, and Natural Language Processing.

The first part of this course is shared with the Neural Networks and Deep Learning. However, students who have finished NN-DL can enroll in this course, and obtain 50% of ECTS points (there will be special rules for them, allowing them to concentrate only on the new material).
 

The lecture will be accompanied by computer exercises, including small exercises illustrating key topics, slightly more demanding tasks giving better understanding of neural networks and a larger project that will give you the opportunity to tackle a real world machine learning problem.

We will introduce the PyTorch deep learning framework, and PyTorch-based popular NLP libraries (Flair, AllenNLP)

This course will have two lecturers: Rafał Nowak, for the first part and Paweł Rychlikowski for the second part."
Computer networks,6,"* wykład 
* ćwiczenia warsztatowe
* rozwiązywanie zadań z komentowaniem 
* indywidualne/grupowe rozwiązywanie zadań
* indywidualny  projekt programistyczny",winter,True,False,"Wykład jest wstępem do szerokiej tematyki sieci komputerowych. Przedstawione będą na nim podstawowe zasady działania sieci komputerowych, ze szczególnym uwzględnieniem sieci opartych na protokole TCP/IP, oraz przegląd zastosowań sieciowych spotykanych w Internecie. Nacisk położony będzie na przedstawienie słuchaczowi mechanizmów, protokołów i algorytmicznych podstaw stojących za problemami komunikacji w sieciach, a także na praktyczne wykorzystanie
elementów tej wiedzy.

**Omówione zostaną następujące zagadnienia:**

1. Podstawowe pojęcia, protokoły, model warstwowy.
2. Warstwa sieciowa: adresowanie CIDR, routing, protokoły IP i ICMP, tworzenie tablic routingu oparte o stan łączy i wektory odległości, systemy autonomiczne, budowa routera, NAT.
3. Warstwa łącza danych i fizyczna: Ethernet, sieci bezprzewodowe, dostęp do współdzielonego nośnika (CSMA/CD, CSMA/CA).
4. Warstwa transportowa: niezawodny transport, mechanizmy okna przesuwnego, kontrola przepływu, kontrola przeciążenia, protokoły UDP i TCP. 
5. Warstwa zastosowań: DNS, HTTP, poczta elektroniczna, sieci P2P, serwery proxy, współpraca z NAT.
6. Programowanie gniazd: gniazda surowe, datagramowe i strumieniowe. 
7. Podstawy kodowania i kryptografii: kody detekcyjne (CRC) i korekcyjne, szyfrowanie, podpisy cyfrowe, RSA, SSL, PGP.
8. Podstawy bezpieczeństwa sieci.

**Wymagania wstępne:**

Zrealizowane przedmioty:

* Algebra lub Matematyka dyskretna
* Systemy operacyjne lub Systemy komputerowe

Niezbędne kompetencje:

* Znajomość grup i pierścieni. 
* Znajomość tematyki procesów, sygnałów i komunikacji międzyprocesowej.
* Obsługa wiersza poleceń w systemie Linux, umiejętność pisania prostych skyptów w powłoce.
* Dobra umiejętność programowania w C lub C++."
Game Testing,6,"wykłady, wykłady interaktywne, nadzorowane rozwiązywanie problemów,
indywidualne / zbiorowe rozwiązywanie problemów, analiza wymagań i przypadków testowych (poprawność, testowalność, złożoność, planowanie i wykonywanie testów)",winter,True,False,"Nie naprawimy ułomności natury ludzkiej. Programiści i inżynierowie oprogramowania będą nadal popełniać błędy; projektanci gier wprowadzą exploity, artyści zapomną o ważnych szczegółach.
To od testerów gry zależy czy wystąpią  przerwy w zabawie z niedopracowaną grą i czy gra odniesie komercyjny sukces.  Celem przedmiotu Testowanie gier jest pomoc w doskonaleniu umiejętności wystarczająco dobrego testowania gier komputerowych."
Theoretical Foundations of Programming Languages,6,"* Wykład
* Ćwiczenia",winter,True,False,"Programy i języki programowania (funkcyjne) będą rozpatrywane jako obiekty matematyczne. Nacisk będzie położony na związki programowania z logiką i dowodami formalnymi (izomorfizm Curry'ego-Howarda). Będą omawiane systemy typów, polimorfizm, podtypowanie, teoretyczne podstawy języków obiektowych. 
Jako ""język programowania"" będzie wykorzystywany przede wszystkim rachunek lambda, ale będą też przykłady w językach Haskell, OCaml, Idris, ...

Wcześniejsza znajomość rachunku lambda ani izomorfizmu Curry'ego-Howarda  nie jest wymagana.

Nauczanie zdalne
W razie konieczności możliwe jest przejście na tryb zdalny. Materiały do wykładów będą umieszczane na SKOSie (jak zawsze), a wykład będzie prowadzony on-line z wykorzystaniem wybranej platformy. Zadania na ćwiczenia też będą umieszczane na SKOSie (jak zwykle), rozwiązania studentów będą dostarczane za pośrednictwem SKOSa, a prowadzący zapewni informację zwrotną. Ćwiczenia też będą prowadzone on-line. Wskazani studenci będą prezentowali swoje rozwiązania na forum grupy z możliwością dyskusji."
Advanced Distributed Algorithms,6,"* Ćwiczenia audytoryjne
* Wykład",winter,True,False,"Obliczenia rozproszone stanowią obecnie naturalny sposób przetwarzania
informacji – od sieci globalnych jak Internet do systemów wieloprocesorowych
czy wielordzeniowych. Środowisko rozproszone daje możliwość przyspieszenia
obliczeń dzięki podziale zadań na wiele komputerów. Jednocześnie dane, na
których prowadzone są obliczenia są często rozproszone w sieci (niedostępne w
całości poszczególnym komputerom), co stanowi istotne utrudnienie i wymaga
kosztownej komunikacji. Dlatego oprócz czasu obliczeń i zużywanej lokalnie
pamięci, w konstrukcji algorytmów rozproszonych kluczowe są też inne miary
jakości, m. in.:

  * liczba rund komunikacji koniecznych do zakończenia obliczeń,
  * rozmiar przesyłanych pojedynczych wiadomości jak i sumaryczny ruch w sieci konieczny do rozwiązania problemu,
  * opóźnienia (latency) w dostarczaniu wiadomości,
  * stabilizacja (osiągnięcie stabilnego pożądanego stanu obliczeń).

Celem wykładu jest zapoznanie studentów z najpopularniejszymi obecnie modelami
obliczeń rozproszonych oraz problemami **algorytmicznymi** w nich
występującymi. W szczególności wykład skoncentrowany będzie na rozwiązywaniu
problemów grafowych w środowisku rozproszonym, a także na problemach
algorytmicznych związanych komunikacją i koordynacją współpracujących
jednostek, odpornościa na błędy, współdzieleniem łączy komunikacyjnych i
innych zasobów. Rozważane będą klasyczne modele obliczeń rozproszonych (Local,
Congest, pamięć dzielona) jak i nowsze (Congested Clique, radio/wireless
networks, MapReduce).

Wykład obejmować będzie m.in. następujące problemy w różnych modelach obliczeń
**rozproszonych** :

  1. Rozproszone kolorowanie grafu (sieci)
  2. Wyznaczenie składowych spójności grafu, (minimalnych) drzew spinających, BFS
  3. Wyznaczanie najkrótszych ścieżek, problemy rutingu
  4. Wyznaczanie maksymalnego zbioru niezależnego, minimalnego zbioru dominującego
  5. Wyznaczanie minimalnych/maksymalnych cięć w grafie
  6. Klastrowanie i dekompozycja sieci
  7. Rozgłaszanie (broadcasting) i zbieranie (gathering) informacji, elekcja lidera, łamanie symetrii w sieciach (ad hoc).
  8. Problemy algorytmiczne w środowisku z pamięcią dzieloną.

Tematyka wykładu będzie zbliżona m.in. do wykładów:

  * [ETH](https://disco.ethz.ch/courses/podc/)
  * [Aalto](https://users.ics.aalto.fi/suomela/da/)
  * [Yale](http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf)

Na wykładzie przyjmuje się, że studenci znają materiał z przedmiotu Algorytmy
i Strutkury Danych, posiadają też podstawową wiedzę z rachunku
prawdopodobieństwa.

Uwaga. Program przedmiotu nie pokrywa się z programem przedmiotu _Algorytmy
rozproszone_ prowadzone. Studenci mogą zaliczać oba przedmioty.

**Literatura**

  1. David Peleg. Distributed Computing: A Locality-Sensitive Approach Society for Industrial and Applied Mathematics (SIAM), 2000, ISBN 0-89871-464-8
  2. Hagit Attiya, Jennifer Welch. Distributed Computing: Fundamentals, Simulations and Advanced Topics McGraw-Hill Publishing, 1998, ISBN 0-07-709352 6
  3. Juraj Hromkovic, Ralf Klasing, Andrzej Pelc, Peter Ruzicka, Walter Unger. Dissemination of Information in Communication Networks Springer-Verlag, Berlin Heidelberg, 2005, ISBN 3-540-00846-2
  4. Skrypty do wymienionych powyżej wykładów na różnych uczelniach.

###### Przewidywana formie zajęć w przypadku konieczności prowadzenia zajęć zdalnie:

- wykłady i ćwiczenia będą prowadzone w formie wideokonferencji."
Seminar: Computer Graphics,3,"* samodzielna praca
* przygotowanie prezentacji
* prezentacja
* dyskusja",winter,True,False,"Celem seminarium jest przegląd ciekawszych prac z ostatnich lat dotyczących szeroko rozumianej grafiki komputerowej. Wymagana jest znajomość tematyki minimum na poziomie wykładu z podstaw grafiki komputerowej i ciekawość wiedzy, część prac może dotykać tematyki przetwarzania obrazów czy też ogólniej wizji komputerowej. Omawiać będziemy prace z wiodących konferencji takich jak np. ACM SIGGRAPH, EUROGRAPHICS.

Uczestnicy seminarium zapoznają się ze stanem bieżących badań w wybranych tematach i nabędą umiejętność dalszego zgłębiania rozwoju grafiki komputerowej poprzez śledzenie i czytanie prac z renomowanych konferencji naukowych. 

Odnośniki:
 * http://www.siggraph.org
 * http://www.eg.org
 * http://kesen.realtimerendering.com"
Clone: Ethics for the thinking,3,"Wykład, dyskusja",winter,True,False,"Na co dzień etyka nie jest ci potrzebna. Wiesz co robić. Ale czasem sprawy się komplikują…
- w twojej pracy leży laptop. Nikt go nie używa, nikt się nim nawet nie interesuje. Gdybyś go wziął, nikt by się nawet nie zorientował. Przydałby ci się taki laptop…
- spotykasz się z dziewczyną. Wiesz, że nigdy nie zwiążesz się z nią na poważnie, choć ona bardzo na to liczy. Powiedzieć jej o tym? Po co – jej bliskość jest ci tak przyjemna. A może, co gorsze, przydarzyła wam się „wpadka”? Na szczęście jest pewne proste rozwiązanie. Ale czy faktycznie jest ono tak proste, jak weekendowy wyjazd do Austrii lub Holandii?
- zostać w tym kraju czy wyjechać na stałe? Choć masz stąd tożsamość, wykształcenie i miłe obyczaje świąteczne, to jednak tkwienie w tym całym bałaganie... Co prawda mógłbyś zostać i próbować zmieniać swoje najbliższe otoczenie, mógłbyś swoją wiedzą pomnażać dobrobyt  jego mieszkańców, ale z drugiej strony wyjeżdżasz i masz święty spokój, no i te zarobki…

W tego typu sytuacjach zaczynasz się zastanawiać na tym co jest dobre, a co złe, co jest słuszne a co niewłaściwe, co jest powinne a co przeciwpowinne, co jest twoim obowiązkiem, a czego nie wolno ci robić, co jest godne zasługi, a co godne potępienia. Im dłużej się jednak zastanawiasz, tym bardziej zdajesz sobie sprawy z tego, że tak naprawdę nie rozumiesz znaczenia tych pojęć. Wartość, obowiązek, cnota, honor, dobro, powinność, szczęście  – wszystkie te pojęcia są jakoś związane z moralnością, ale czym się od siebie różnią? Co oznaczają?

Ten kurs daje ci możliwość zapoznanie się z podstawowymi sposobami odpowiedzi na pytanie o sens pojęć moralnych. Tok myśli będzie prowadzony w porządku historycznym, zaczniemy od Sokratesa i Platona, a skończymy na współczesnej fenomenologii. Nie zniechęcaj się jednak, bo w etyce, jak w całej filozofii, stare nie oznacza przestarzałe. Dawne koncepcje są laboratorium współczesnego myśliciela. Tak więc poprzez dzieje refleksji etycznej będziemy starali się o analizę podstawowych pojęć moralnych. 

Bądź jednak świadomy, że odbycie tego kursu nie sprawi, że rozstrzyganie twoich problemów moralnych stanie się łatwe. Choć będziesz bardziej świadomy czym jest obowiązek, ale wciąż będziesz musiał sam ustalać, co jest twoim obowiązkiem w tej konkretnej chwili. Będziesz wiedział czym jest wartość, ale sam będziesz musiał rozstrzygać, za którą z dwóch opcji dylematu moralnego kryje się wyższa wartość. Jaka więc korzyść z tego kursu? Subtelniejszy język do przemyśleń moralnych i budowy własnego światopoglądu, większa samoświadomość w sytuacjach granicznych. To już chyba coś?


**Przedmiot będzie prowadzony przez dr. Marcina Drofiszyna z Katedry Logiki i Metodologii Nauk.**"
Scala in Practice,5,"* Lectures (theory & live-coding)
* Programming exercises & demos
* Code reviews
* Reading",winter,True,False,"Scala is currently one of the most popular programming languages, with a [high demand](https://insights.stackoverflow.com/survey/2019?utm_source=Iterable&utm_medium=email&utm_campaign=dev-survey-2019#top-paying-technologies) amongst software development companies, globally.


It’s functional & object oriented dual nature, static typing, high expressiveness & JVM integration makes it a perfect choice for many companies. User’s include the likes of Twitter, LinkedIn, Infor, Netflix &  Amazon, amongst others.  These companies use Scala to create web portals, big data applications... and code-generators [[ScalaUA 2019](https://www.youtube.com/watch?v=DLjALS_Lbn8&feature=youtu.be)].

The goal of this course is to introduce students to the syntax of the language, along with the frameworks and libraries associated with it, which are a standard in the industry.

**Course Syllabus:** 
 
#### I. Scala syntax
 * Code standards  
 * Types
 * Classes & objects
 * Traits
 * Functions & closures
 * Collections
 * Case classes & pattern matching
 * Lambdas
 * Implicit parameters
 * Futures
 * Cooperation with Java

#### II. Frameworks & libraries
 * Scala in commercial applications
 * Build tool - [[Sbt](https://www.scala-sbt.org)] 
 * Testing - [[ScalaTest](http://www.scalatest.org/)] 
 * Database access - [[Slick](http://scala-slick.org/)] 
 * Web applications - [[Play Framework](https://www.playframework.com)]  
 * Concurrent and distributed applications [[Akka](https://akka.io)]
 * Functional Programming - [[Cats](https://typelevel.org/cats/)] 

#### III. Glimpse into the future of Scala [[Dotty compiler](https://dotty.epfl.ch/)] 
 
&nbsp;  

**Entry Recommendations**: Java, Object Oriented Programming & basics of Web Development.



**Process during (possible) remote studying:**
All lectures & labs are online via [meet.google.com](https://meet.google.com/).

###### Lectures: ######
* All students have cameras & mics disabled
* All questions are asked via chat-box
* After online session slides from lectures will be available in SKOS

###### Labs: ######

* The only way to gain points is to send the code to email (michal.kowalczykiewicz@cs.uni.wroc.pl) before the deadline
* Lab hours are optional Q/A sessions"
Design and development of .NET Windows Applications,5,"* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",winter,True,False,"Celem wykładu jest przedstawienie systemu operacyjnego Windows widzianego
oczami programisty z szerokiej perspektywy technologii .NET. Pracownia daje
okazję do zmierzenia się z szeregiem typowych zadań programistycznych w
środowisku Windows.

**Program:**

  1. Omówienie wewnętrznych mechanizmów Windows.
  2. Zapoznanie z interfejsem programowania Win32API.
  3. Omówienie platformy .NET i języka C#
  4. Przegląd biblioteki standardowej platformy .NET, m.in:
    * oprogramowanie interfejsu użytkownika (Windows.Forms, WPF),
    * komunikacja z systemami baz danych (ADO.NET, Linq2SQL, Entity Framework)
    * integracja różnych języków platformy .NET: VB.NET, MSIL."
Seminar: Software Testing,3,"- samodzielny wybór i lektura materiałów,
- przygotowanie i wygłoszenie prezentacji,
- wysłuchanie i zrozumienie wygłoszonych referatów,
- uczestnictwo w dyskusji.",winter,True,False,"Seminarium dotyczy metod, technik, norm, narzędzi testowania.
Oprócz testowania systemów obiektowych (modele, wzorce, narzędzia) ważne będą
również testy akceptacji, pokrycie testami, automatyzacja testów itp.

**Program:**

  1. Wytwarzanie oprogramowania sterowane testami
  2. Testy akceptacji
  3. Automatyczne testowanie interfejsów
  4. Modele testów
  5. Wzorce projektowania testów
  6. Narzędzia testowania
  7. Projektowanie automatyzacji testów
  8. Zgodne z RODO testowanie oprogramowania

****"
Object-oriented programming,6,"* wykład
* prezentacja rozwiązań i live coding
* samodzielna implementacja zadań
* realizacja i prezentacja projektu programistycznego",winter,True,True,"Celem zajęć jest poznanie jednego z najpowszechniej stosowanego paradygmatu programowania: programowania obiektowego. Program obejmuje zarówno przedstawienie podstawowych pojęć takich jak klasa, obiekt, dziedziczenie czy metody wirtualne, jak i praktykę  wykorzystania tych elementów w budowaniu złożonych programów za pomocą wzorców projektowych.

Naukę programowania obiektowego będą wspierać języki obiektowe, zarówno te z tzw. statycznym typowaniem jak i dynamicznym."
Design of database applications,5,"* Pracownia programistyczna
* Wykład",winter,True,False,"Dobrze zaprojektowana aplikacja przetwarzająca i prezentująca dane ma wiele warstw i komponentów o określonych odpowiedzialnościach. Celem wykładu jest zaprezentowanie, jak dobrze taki typ aplikacji zaprojektować i oprogramować.
Podczas wykładów oraz towarzyszących im pracowni będziemy poznawać i budować kolejne elementy rozwiązania, aby ostatecznie otrzymać kompletny, działający system.

**Program**

Składa się z dwóch głównych części

**Część 1: DBMS**

  1. Podstawy Microsoft SQL Server
  2. Język SQL
  3. Programowanie w T-SQL
  4. Kursory, wyzwalacze, funkcje i procedury
  5. Transakcje i blokady
  6. Optymalizacja w tym normalizacja, indeksy i plany wykonania
  7. Przegląd wybranych baz danych typu NoSQL

**Część 2: System informatyczny**

  1. Podstawy uruchomienia rozwiązania w chmurze
  2. Architektura Microservices, podstawy konteneryzacji
  3. Architektury aplikacji z bazą danych
  4. Przegląd Domain-Driven Design
  5. Wzorce CQRS i Event Sourcing
  6. Podstawy testowania
  7. Wzorzec repozytorium, w tym narzędzia ORM i LINQ
  8. Walidacja danych
  9. Modele danych i automapper
  10. Prezentacja danych, w tym
      - sposoby prezentacji informacji
      - stronicowanie, sortowanie, filtry
      - wzorzec specyfikacji
  11. Integracja systemów, w tym
      - wzorce integracyjne
      - usługi danych, protokół OData
      - API management
      - podstawy federacji tożsamości
  12. Skalowalność rozwiązań, 
  13. Zarządzanie transakcjami, transakcje rozproszone
  14. Podstawy analizy danych i raportowania

**Wymagania:** Umiejętność programowania na dowolnej platformie
programistycznej oraz znajomość materiału z kursu WWW"
Advanced Data Mining,6,"samodzielne czytanie literatury, prezentacja, dyskusja",winter,True,False,"_**UWAGA**: W przypadku takiej konieczności, w roku akademickim 2020/21 zajęcia mogą być prowadzone zdalnie: wykłady będą prowadzone online przez Google Meet lub podobne narzędzie interaktywnej komunikacji, a pracownie będą miały formę indywidualnych spotkań online._

Celem przedmiotu jest zapoznanie słuchaczy z zaawansowanymi algorytmami eksploracji danych, dotyczącymi głównie systemów rekomendujących, redukcji wymiarowości, eksploracji danych temporalnych i systemów wspomagania decyzji. Zajęcia pomocnicze skupiają się na rozwiązywaniu przykładowych problemów świata rzeczywistego za pomocą zaawansowanych algorytmów eksploracji danych.

Ogólny program zajęć:
1. Zaawansowane zagadnienia eksploracji danych.
2. Dane sekwencyjne i temporalne. Wielowymiarowe szeregi czasowe. Prognozowanie metodami stochastycznymi i uczenia maszynowego. Grupowanie i klasyfikacja szeregów czasowych, danych temporalnych i sekwencyjnych. Wzorce charakterystyczne w szeregach czasowych.
3. Systemy rekomendujące. Collaborative Filtering i jego rozszerzenia. Faktoryzacja macierzy i jej rozszerzenia. Grupowanie produktów i użytkowników w systemach rekomendujących. Praktyczne problemy systemów rekomendujących: dokładność (ang. accuracy), pokrycie (ang. coverage), różnorodność (ang. diversity), nowość (ang. novelty) i inne miary oceny systemów rekomendujących.
4. Redukcja wymiarowości. Liniowa redukcja wymiarowości przestrzeni danych. Nieliniowa redukcja wymiarowości przestrzeni danych (w tym przekształcenia kernelowe). Zanurzenia sąsiedztw punktów danych (podejścia deterministyczne i probabilistyczne). Ekstrakcja cech charakterystycznych danych.
5. Eksploracja danych złożonych i nieustrukturalizowanych. Dane geoprzestrzenne. Trajektorie ruchu GPS.
5. Systemy wspomagania decyzji. Wybrane zastosowania zaawansowanej eksploracji danych.

This lecture focuses on advanced data mining algorithms for processing big, complex and unstructured data. It mainly concerns recommendation systems, dimensionality reduction with neighborhood embedding, temporal data mining and decision support systems. In recommendation systems, various approaches from simple collaborative filtering to advanced matrix factorization are presented and discussed in the context of their practical relevance, concerning not only the popular MSE or MAE measures, but also the coverage, diversity, and novelty of recommendations. In temporal data mining, beside the analysis of regular time series with machine learning methods, such as Support Vector Regression and Neural Networks, unstructured temporal data are studied. Additional topics may concern unstructured datasets, such as irregular multidimensional time series, GPS tracks or medical images."
Ethics for the thinking,5,"Wykład, dyskusja",winter,True,False,"Na co dzień etyka nie jest ci potrzebna. Wiesz co robić. Ale czasem sprawy się komplikują…
- w twojej pracy leży laptop. Nikt go nie używa, nikt się nim nawet nie interesuje. Gdybyś go wziął, nikt by się nawet nie zorientował. Przydałby ci się taki laptop…
- spotykasz się z dziewczyną. Wiesz, że nigdy nie zwiążesz się z nią na poważnie, choć ona bardzo na to liczy. Powiedzieć jej o tym? Po co – jej bliskość jest ci tak przyjemna. A może, co gorsze, przydarzyła wam się „wpadka”? Na szczęście jest pewne proste rozwiązanie. Ale czy faktycznie jest ono tak proste, jak weekendowy wyjazd do Austrii lub Holandii?
- zostać w tym kraju czy wyjechać na stałe? Choć masz stąd tożsamość, wykształcenie i miłe obyczaje świąteczne, to jednak tkwienie w tym całym bałaganie... Co prawda mógłbyś zostać i próbować zmieniać swoje najbliższe otoczenie, mógłbyś swoją wiedzą pomnażać dobrobyt  jego mieszkańców, ale z drugiej strony wyjeżdżasz i masz święty spokój, no i te zarobki…

W tego typu sytuacjach zaczynasz się zastanawiać na tym co jest dobre, a co złe, co jest słuszne a co niewłaściwe, co jest powinne a co przeciwpowinne, co jest twoim obowiązkiem, a czego nie wolno ci robić, co jest godne zasługi, a co godne potępienia. Im dłużej się jednak zastanawiasz, tym bardziej zdajesz sobie sprawy z tego, że tak naprawdę nie rozumiesz znaczenia tych pojęć. Wartość, obowiązek, cnota, honor, dobro, powinność, szczęście  – wszystkie te pojęcia są jakoś związane z moralnością, ale czym się od siebie różnią? Co oznaczają?

Ten kurs daje ci możliwość zapoznanie się z podstawowymi sposobami odpowiedzi na pytanie o sens pojęć moralnych. Tok myśli będzie prowadzony w porządku historycznym, zaczniemy od Sokratesa i Platona, a skończymy na współczesnej fenomenologii. Nie zniechęcaj się jednak, bo w etyce, jak w całej filozofii, stare nie oznacza przestarzałe. Dawne koncepcje są laboratorium współczesnego myśliciela. Tak więc poprzez dzieje refleksji etycznej będziemy starali się o analizę podstawowych pojęć moralnych. 

Bądź jednak świadomy, że odbycie tego kursu nie sprawi, że rozstrzyganie twoich problemów moralnych stanie się łatwe. Choć będziesz bardziej świadomy czym jest obowiązek, ale wciąż będziesz musiał sam ustalać, co jest twoim obowiązkiem w tej konkretnej chwili. Będziesz wiedział czym jest wartość, ale sam będziesz musiał rozstrzygać, za którą z dwóch opcji dylematu moralnego kryje się wyższa wartość. Jaka więc korzyść z tego kursu? Subtelniejszy język do przemyśleń moralnych i budowy własnego światopoglądu, większa samoświadomość w sytuacjach granicznych. To już chyba coś?


**Przedmiot będzie prowadzony przez dr. Marcina Drofiszyna z Katedry Logiki i Metodologii Nauk.**"
Warsztaty: Jak założyć firmę?,3,,winter,True,False,"Zajęcia będą miały formę warsztatów. Uczestnicy będą proszeni o opracowanie (w
formie krótkiego referatu będącego wprowadzeniem do dyskusji) jednego z
tematów lub “case study” i udział w dyskusji. Przewiduję udział “anioła
biznesu”, założycieli start-upów, szefów małych firm, osób, którym się nie
bardzo udało (sprzedali start-upy), osób, które rozpędziły kulejące małe
firmy.

Tematy do dyskusji:

Co oferować: tanie usługi, unikalne usługi czy produkt.

Cel strategiczny: sprzedać firmę po zbudowaniu marki, czy budować z myślą o
trwałej niezależnej firmie.

Jaki produkt: istniejący niezależnie, czy po zbudowaniu włączony do większego
systemu.

Jak znaleźć niszę?

Jak ocenić wielkość rynku?

Czy myśleć o rynku lokalnym (Polska), czy globalnym?

Jak poszukiwać partnerów i klientów.

Finansowanie: gdzie są pieniądze? (prywatne i publiczne, granty dla start-
upów).

Przykłady udanych startupów (w Polsce i za granicą)?

Na ogół się nie udaje, co wtedy?

Firma rodzinna (koleżeńska), czy zatrudniająca liderów spoza grona znajomych?

Zrobimy to sami, czy kupimy usługę?

Czy zaczynać zaraz po studiach (lub jeszcze w takcie), czy zdobyć wcześniej
doświadczenie w korporacji?

Ile informatyki w produkcie (usłudze)?

Czy korzystać z usług księgowych, prawników, pijarowców? Gdzie ich szukać?

Czy nawiązywać kontakty z sieciami społecznymi start-upowców."
Formal Languages and Computational Complexity,9,Wykład i ćwiczenia,winter,True,False,"Program przedmiotu obejmuje zagadnienia związane z teorią językow formalnych
(wykłady A1 - A8) w zakresie istotnym z punktu widzenia wykształcenia
informatycznego, a także dostatecznym dla stworzenia zasobow naturalnych
przykładow dla części B i C. Następnie przechodzi się do zagadnień związanych
z pojęciami rozstrzygalności i nierozstrzygalności (wykłady R1 -- R8).
Ostatnia część kursu poświęcona jest wybranym, elementarnym zagadnieniom
złożoności obliczeniowej."
Introduction to databases,6,"Wykład, wykład interaktywny, samodzielne rozwiązywanie zadań, dyskusja, rozwiązywanie zadań z komentowaniem, ćwiczenia warsztatowe, samodzielny projekt programistyczny",winter,True,False,"Celem wykładu jest omówienie zasad konstrukcji relacyjnych baz danych oraz
opanowanie przez słuchaczy umiejętności profesjonalnej obsługi systemu baz
danych od strony użytkownika, czyli:

  * umiejętności projektowania i tworzenia relacyjnych baz danych dla rzeczywistych zagadnień;
  * sprawnego wyszukiwania i odzyskiwania informacji z baz danych przy pomocy języków SQL.
  * pisania aplikacji z dostępem do baz danych;
  * efektywnego wykorzystania dodatkowych możliwości systemu (perspektyw, transakcji, więzów, itp.).

Ponadto wykład pozwala słuchaczom poznać elementy systemów baz danych spoza
warstwy użytkownika (system nadzoru transakcji, zapewnienia bezpieczeństwa i
optymalizacji) oraz zapoznać się z innymi koncepcjami baz danych
wykraczającymi poza standard relacyjny (np. grafowe bazy danych, elementy
rozproszonych baz danych).

**Program wykładu:**

  1. Podstawowe pojęcia baz danych i modelowanie konceptualne.
  2. Relacyjne bazy danych. Języki opisu danych i języki zapytań. SQL.
  3. Elementy aktywnych baz danych (więzy integralności, wyzwalacze).
  4. Elementy systemów baz danych (transakcje, bezpieczeństwo i autoryzacja danych, połączenie relacyjnych języków zapytań z językami macierzystymi).
  5. Teoria relacyjnych baz danych (zależności funkcyjne, normalizacja i denormalizacja).
  6. Metody pisania aplikacji z dostępem do baz danych.
  7. Inne modele baz danych (m.in. bazy grafowe, przetwarzanie dużych danych).

**Program ćwiczeń i pracowni:**

  1. Zajęcia konwersatoryjne pomagające w praktycznym opanowaniu projektowania relacyjnych baz danych.
  2. Opanowanie zapytań w językach SQL.
  3. Zajęcia laboratoryjne pozwalające zapoznać się z systemami zarządzania bazami danych (PostgreSQL itp.).
  4. Wykonanie kompletnego projektu niewielkiej bazy danych.

**Wymagania:** Podstawowa znajomość logiki nabyta np. na Logice dla
informatyków lub Wstępie do matematyki; Podstawowa znajomość algorytmiki, np.
Algorytmy i struktury danych (L); Umiejętność programowania wystarczająca do
napisania aplikacji."
Curves and Surfaces in Computer Graphics,6,"* wykład,
* wykład interaktywny,
* ćwiczenia audytoryjne,
* pracownia programistyczna,
* projekt programistyczny.",winter,True,False,"Krzywe i powierzchnie to podstawowe obiekty grafiki komputerowej. To właśnie przy ich pomocy można modelować skomplikowane kształty i sceny, którym nadaje się później cechy realistyczne i wykorzystuje na przykład w tak modnej ostatnio animacji komputerowej.

Głównym celem wykładu jest przedstawienie podstawowych wiadomości na temat narzędzi pozwalających efektywnie reprezentować i modelować krzywe oraz powierzchnie różnego typu i wygładzać przy ich pomocy dane. Szczególny nacisk położony będzie na omówienie odpowiednich technik i algorytmów z tym związanych, które pozwolą uczestnikom zajęć przygotować własny edytor krzywych lub powierzchni.

  
**Wymagania**

* analiza numeryczna (L lub M),
* umiejętność programowania.

**Program**

1\. Podstawowe pojęcia (działania na punktach i wektorach, kombinacja barycentryczna punktów, otoczka wypukła, długość łuku krzywej, krzywizna).

2\. Reprezentacja krzywych. Krzywe interpolacyjne. Krzywe Béziera. Krzywe sklejane. Krzywe wygładzające.

3\. Reprezentacja powierzchni. Powierzchnie interpolacyjne Lagrange'a. Prostokątne i trójkątne płaty Béziera i ich gładkie łączenie. Powierzchnie sklejane. Powierzchnie wygładzające. Powierzchnie Coonsa i Gordona.

**Literatura**

  * P. Dierckx, _Curve and Surface Fitting with Splines_ , Clarendon Press, Oxford 1993.
  * G. Farin, _Curves and Surfaces for CAGD. A Practical Guide_ , Morgan-Kaufmann, 2002.
  * J. Hoschek, D. Lasser, _Fundamentals of Computer Aided Geometric Design_ , AK Peters, Wellesley (Ma) 1993.
  * J. F. Hughes, A. van Dam, M. McGuire, D. F. Sklar, J. D. Foley, S. K. Feiner, K. Akeley, _Computer Graphics. Principles and Practice_ , Addison-Wesley, 2013.
  * P. Kiciak, _Podstawy modelowania krzywych i powierzchni_ , WNT, Warszawa 2019."
Linux system administration,5,"* Wykład
* Pracownia komputerowa, w tym prezentacja rozwiązań zadań przy komputerze",winter,True,False,"Celem kursu jest rozwinięcie u uczestników praktycznych umiejętności
zarządzania systemem Linux na komputerze osobistym lub serwerze. Zostaną
przedstawione podstawowe informacje na temat budowy i sposobu działania
systemów uniksopodobnych, a szczególnie różnych dystrybucji Linuksa. Zajęcia
są adresowane do wszystkich studentów, którzy chcieliby sprawnie korzystać na
co dzień z systemów linuksowych i którzy są zdania, że to użytkownik powinien
mieć władzę na komputerem, a nie komputer nad użytkownikiem. Mimo że
osiągnięcie tego celu wymaga sporego zaangażowania, wiedzy i praktycznych
umiejętności, nie zakłada się wstępnego doświadczenia słuchaczy w zakresie
administrowania Linuksem. Wystarczy wola odłączenia myszy i chęć pracy z
terminalem tekstowym.

### ORIENTACYJNY SPIS ZAGADNIEŃ PORUSZANYCH NA ZAJĘCIACH

#### I. WSTĘP: ŻYCIE Z LINUKSEM

  1. Hardware i software. Budowa komputera i struktura oprogramowania podstawowego. Jądro i przestrzeń użytkownika. Proces rozruchu komputera. Instalacja systemu i rozpoczęcie pracy z Linuksem.
  2. Terminal tekstowy. Powłoka systemowa. Podstawowe polecenia. Uruchamianie programów, standardowe strumienie wejściowe i wyjściowe, potoki. Uruchamianie i zatrzymywanie procesów. Zarządzanie plikami, prawa dostępu, kopiowanie, archiwizowanie. Edytory tekstu. Przetwarzanie plików tekstowych.
  3. Użytkownik root. Hasła. Su i sudo.

#### II. ZAGADNIENIA SZCZEGÓŁOWE

  1. Hardware i jego diagnostyka, lshw, lsusb, lspci, dmidecode, i2c-tools i in. Urządzenia. Sysfs i udev. Udevd i udevadm.
  2. Dyski. Protokoły SCSI i ATA. USB Storage. Hdparm i smartmontools.
  3. Partycje. MBR i GPT. Narzędzia do partycjonowania dysków, fdisk, parted.
  4. Urządzenia blokowe, device mapper, losetup, dm-crypt, LVM.
  5. Systemy plików. Budowa systemu plików, inode. Księgowanie. Systemy ext2, ext3 i ext4. Tworzenie i zarządzanie systemami plików. Diagnostyka systemów plików, fsck. Montowanie, mount, /etc/fstab itp. Dowiązania, pliki specjalne. FAT i NTFS. Filesystem in userspace. Systemy plików btrfs, ufs, zfs, ffs i in. Szczególne wymagania dysków SSD, discard i fstrim. Linux Directory Structure, katalogi /etc, /usr, /var, /tmp, /boot i ich przeznaczenie.
  6. Przestrzeń wymiany w osobnej partycji i w pliku. Przestrzeń wymiany w pamięci RAM, zram, zswap.
  7. Rozruch komputera. Firmware, Legacy BIOS i UEFI. Konfiguracja, efibootmgr. Inne (Coreboot, Libreboot, U-Boot). Bootloadery drugiego poziomu. GNU Grub 2 i jego konfiguracja. Informacja o Legacy GRUB. Inne popularne bootloadery, Syslinux, LILO, systemd-boot (Gummiboot). Konfiguracja wielosystemowa z BIOS i UEFI, współżycie z systemem MS Windows, rEFInd. PXE i rozruch poprzez sieć komputerową. BOOTP i TFTP. Plymuth i estetyka rozruchu.
  8. Start jądra. Tworzenie i konfigurowanie initramfs. Uruchamianie awaryjne i tryb pojedynczego użytkownika. Moduły jądra, modprobe, lsmod, rmmod, /etc/modules.
  9. Konfiguracja systemu. Katalog /etc i jego struktura.
  10. Uruchamianie przestrzeni użytkownika. System V Init. Proces init, inittab, init.d i rc?.d, runlevels, telinit, update-rc.d, insserv, run-parts. Informacja o Upstart.
  11. Systemd i jego konfiguracja. Filozofia działania systemd. Organizacja i składnia plików konfiguracyjnych. Demony systemd. Jednostki systemd. Cele i metody ich osiągania. Serwisy i inne jednostki.
  12. Zarządzanie użytkownikami. Logowanie do systemu, getty i login. Konsola zdalna i minicom. Hasła, passwd i shadow. PAM. Własność procesów, suid.
  13. Dziennik systemowy, rsyslog, logger, /var/log, journalctl i dmesg. Zdalny zapis dziennika. Protokół SMTP i narzędzia do korzystania z niego.
  14. Synchronizacja czasu, NTP, ntpd, ntpdate, open-ntp, chrony, systemd-timesyncd.
  15. Planowanie wykonania procesów, procesy wsadowe. Cron, crontab, anacron, systemd-timer. Polecenie at.
  16. Zarządzanie procesami i ich diagnostyka, ps, lsof, strace, ltrace. Wysyłanie sygnałów do procesów, kill, killall, nohup. Wątki. Pomiar czasu procesora, obciążenia, zużycia pamięci i operacji wejścia/wyjścia (top, times, vmstat, iostat, iotop, pidstat itp). Priorytety procesów, nice. Komunikacja międzyprocesowa. Gniazda. Dbus. Komunikacja między użytkownikami, wall.
  17. Biblioteki współdzielone, /lib, /usr/lib, ldd, ldconfig, /etc/ld.so.conf, LD_LIBRARY_PATH.
  18. Repozytoria pakietów i dystrybucje Linuksa. Debian, Ubuntu i pakiety deb. Konfigurowanie apt i aptitude. RHEL, Fedora, Centos i rpm. Arch Linux i pacman. Dystrybucje specjalizowane, Kali Linux, Tails i in. Krzyżowanie dystrybucji. Linux from scratch.
  19. Efektywna praca w trybie tekstowym. Powłoki bash (sh, dash, ash), c-shell (csh, tcsh), zsh. Biblioteka readline. Terminal, terminfo, termcap. Screen i tmux. Konfiguracja iterpretera powłoki. Tekst zachęty, Powershell. Lokalizacja i internacjonalizacja, locale, tzdata, kodowanie znaków.
  20. Skrypty powłoki. Narzędzia sed, awk. Polecenia użytkowe wc, tr, sort, head, tail, tee, xargs, grep, find, locate i wiele innych.
  21. Separacja procesów, namespaces, cgroups. Piaskownice, firejail i in. Apparmor. Selinux.
  22. Wirtualizacja. LXC i docker. Qemu i KVM. Xen. Informacja o programie Virtualbox.
  23. Sieci komputerowe i podstawowa konfiguracja sieci w Linuksie. Podstawowe polecenia konfiguracyjne. Konfiguracja statyczna i dynamiczna. DHCP. Gniazda. Bezpieczeństwo i iptables. Usługi sieciowe, sshd, inetd i xinetd. Gniazda systemd. RPC. Usługi nazw, bind9.
  24. Usługi drukowania, lpr i Cups.
  25. Informacja o trybie graficznym (gdyby kiedyś był potrzebny). Serwer wyświetlania X Windows, xinit, startx. Graficzny zarządca logowania (xdm, gdm, sddm, lightdm i in). Zarządca okien (kwin, Metacity, xfwm, Openbox i wiele in). Typy zarządców okien (tiling, stacking, compositing, dynamic). Środowisko graficzne (KDE, Gnome, XFCE i wiele innych). XTerminale (xterm, urxvt, konsole, terminal i in). Niedoskonałości serwera X Windows. Weyland. Zdalny terminal graficzny (xpra, xephyr, xnest, RDP, Winswitch, vnc, x2go, NX tech i in.)
  26. Oprogramowanie Open Source. FSF. Typy licencji. GNU i BSD.

Zakres materiału obejmuje większość zagadnień wymaganych na egzaminach
certyfikacyjnych CompTIA Linux+ (LX0-103 i LX0-104) oraz LPIC-1 (LPI 101 i LPI
102 — Certified Linux Administrator).

### LITERATURA

1. Brian Ward, _Jak działa Linux. Podręcznik administratora_, wydanie II,
   Helion 2015.
2. Evi Nemeth, Garth Snyder, Trent R. Hein, Ben Whaley, Dan Mackin,
   _Unix i Linux. Przewodnik administratora systemów_, wydanie V,
   Helion 2018."
Probability and Statistics,6,"* Wykład
* Rozwiązywanie zadań z komentowaniem
* Indywidualne rozwiązywanie zadań
* Samodzielna praca przy komputerze",winter,True,False,"**Program:**

  1. Pojęcie prawdopodobieństwa, przestrzeń zdarzeń, pojęcie zmiennej losowej, jej rozkład i charakteryzacja.
  2. Zmienne losowe dyskretne (rozkłady: Bernoulliego, geometryczny, Poissona, hipergeometryczny).
  3. Zmienne losowe ciągłe (rozkłady: jednostajny, wykładniczy, gamma, normalny, beta, Weibulla). Charakterystyki zmiennych losowych - momenty.
  4. Rozkłady zmiennych losowych wielowymiarowych (rozkład dwuwymiarowy, rozkład warunkowy, rozkład brzegowy, niezależność dwóch zmiennych losowych); Macierze kowariancji i korelacji. Wielowymiarowy rozkład normalny i szczególny przypadek dwuwymiarowy(elipsa koncentracji, proste regresji).
  5. Funkcje od dwuwymiarowych zmiennych losowych. Wyznaczanie gęstości i dystrybuanty funkcji zmiennych losowych.
  6. Funkcja charakterystyczna i jej własności. Związek funkcji charakterystycznej z momentami zmiennej.
  7. Populacja i próbka. Rozkłady próbkowe (chi-kwadrat, t-Studenta, F-Snedecora). Centralne twierdzenie graniczne.
  8. Estymacja punktowa i przedziałowa. Testowanie hipotez statystycznych. Weryfikacja zgodności rozkładów.
  9. Regresja liniowa i inne rodzaje regresji.
  10. Różne rodzaje analizy wariancji i związek tejże z regresją.

**Zajęcia odbędą się w formie zdalnej.**

**Wykład**: notatki i nagrania wykładów na stronie przedmiotu w SKOSie oraz spotkania w MS Teams. Notatki w postaci wcześniej przygotowanego tekstu (LaTeX) oraz rękopis powstający w trakcie wykładu.

**Ćwiczenia**: forma stacjonarna, co tydzień listy zadań, deklaracje przed ćwiczeniami.

Zaliczenie: na podstawie deklaracji oraz aktywności w trakcie ćwiczeń. 

Ocena końcowa: punkty z ćwiczeń, zadania dodatkowe z list zadań oraz (rozpoczynając od listy 5-6) dodatkowe zadania obliczeniowe, nie więcej niż 4, nie częściej niż co 2 tygodnie.

**Wymagania:**

Algebra: znajomość podstawowych pojęć algebry liniowej -- przestrzeń liniowa,
przekształcenie liniowe i jego macierz, działania na macierzach.  

Analiza: umiejętność obliczania podstawowych całek, całkowanie przez podstawienie i przez części; całki podwójne.

Analiza numeryczna: aproksymacja średniokwadratowa, całkowanie numeryczne.

**Zalecana literatura (podręczniki)**  
**Gernstenkorn, Śródka** – Kombinatoryka i rachunek prawdopodobieństwa.  
**Majsnerowska** – Wprowadzenie do rachunku prawdopodobieństwa z zadaniami.  
Sobczyk – Statystyka.  
Jakubowski, Sztencel – Wstęp do teorii prawdopodobieństwa."
Computer Architecture for Programmers,8,"Wykład, rozwiązywanie zadań z komentowaniem, indywidualne rozwiązywanie zadań, indywidualna analiza kodu źródłowego i kodu maszynowego, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze.",winter,True,False,"Celem przedmiotu jest wprowadzenie słuchaczy do budowy i zasad działania komputerów z punktu widzenia programisty. Studenci nabędą wiedzy z zakresu programowania niskopoziomowego. Po zakończeniu przedmiotu będą rozumieć:

 * reprezentację programów i danych na dysku i w pamięci komputera,
 * wpływ architektury komputera na wydajność aplikacji,
 * mechanizmy sprzętowe używane do implementacji systemów operacyjnych,
 * jak unikać pisania programów podatnych na ataki.

##### Program

1. Reprezentacja danych
   * reprezentacja danych w pamięci komputera
   * arytmetyka na liczbach binarnych w systemie uzupełnień do dwóch
   * arytmetyka na liczbach zmiennopozycyjnych standardu IEEE754
   * problemy wynikające z ograniczeń reprezentacji maszynowych typów numerycznych
2. Programowanie niskopoziomowe
   * reprezentacja pośrednia programów (kod trójadresowy, graf przepływu sterowania)
   * translacja konstrukcji języka C do asemblera procesorów x86-64 (wyrażenia, instrukcje sterujące, typy rekordowe i tablicowe)
   * konwencja wołania procedur i organizacja stosu wywołań (ABI)
3. Konsolidacja i ładowanie
   * proces kompilacji, konsolidacji i ładowania programów (sekcje, relokacje, układ pamięci)
   * reprezentacja programów – format plików ELF
   * biblioteki i konsolidator dynamiczny (ld.so)
4. Podatności programów na ataki
   * błąd przepełnienia stosu
   * wykorzystywanie podatności (wstrzykiwanie kodu, programowanie zorientowane na powroty)
   * sprzętowe i programowe techniki zapobiegania podatnościom (ASLR, W^X)
5. Pamięć masowa i operacyjna
   * hierarchia pamięci i lokalność dostępów
   * organizacja pamięci operacyjnej (czasu dostępu, protokół DDR)
   * dyski magnetyczne (multi-zone recording, buforowanie)
   * dyski półprzewodnikowe (odśmiecanie bloków)
   * komunikacja procesora z urządzeniami peryferyjnymi (przerwania, MMIO, DMA)
6. Pamięć podręczna
   * organizacja pamięci podręcznej (zbiór, blok, znacznik, bity dodatkowe)
   * polityka wymiany bloków (LRU)
   * polityka zapisu (write-back, write-through)
   * analiza i optymalizacja programów pod kątem lokalności dostępów
7. Translacja adresów i pamięć wirtualna
   * motywacja: zarządzanie pamięcią, izolacja, leniwe sprowadzanie danych 
   * przestrzeń adresowa i mechanizm translacji adresów
   * zbiór roboczy i rezydentny, błąd strony
   * hierarchiczna reprezentacja tablicy stron
   * przyspieszanie procesu translacji dzięki TLB
   * przełączanie przestrzeni adresowych
   * problemy na styku translacji adresów i pamięci podręcznej (homonimy i synonimy)
8. Wpływ mikroarchitektury procesora na wydajność programów
   * przetwarzanie superskalarne (procesory Out-of-Order, spekulacja)
   * modelowanie obliczeń grafem przepływu danych
   * przewidywanie skoków (BHT i BTAC)

##### Zajęcia

Większość zajęć do przedmiotu będzie prowadzona w postaci ćwiczeń z deklaracjami. Pozostałe to pracownie programistyczne:

 * programowanie w asemblerze x86-64
 * odpluskwianie programów z użyciem [gdb](https://www.gnu.org/software/gdb/)
 * przeprowadzanie ataków na podatne oprogramowanie
 * optymalizacja programów w języku C

##### Zmiana od roku akademickiego 2021/2022

**W związku ze zmianą wymiaru godzinowego, od roku 2021/2022 zmienia się liczba punktów ECTS z 6 do 8.**"
Project: Competitive Artificial Intelligence,4,"- grupowy projekt programistyczny
- prezentacja
- dyskusja, konsultowanie pomysłów",winter,True,False,"W ramach projektu, kilkuosobowe grupy będą programowały boty grające w jedne z istniejących zawodów AI. 

Poszczególne zespoły nie będą działały w odosobnieniu, lecz na regularnych spotkaniach z prowadzącymi oraz pozostałymi uczestnikami przedmiotu będą prezentować postępy prac, dzielić się wątpliwościami i słuchać pomysłów na alternatywne podejścia. Naszym celem jest wprowadzić do kompetytywnej Sztucznej Inteligencji silny element współpracy i wzajemnej nauki jako środka do osiągania lepszych wyników.

Na koniec projektu, oprócz przedstawienia swojego bota, każda z grup przygotuje też krótki raport z historii jej tworzenia oraz opisujący mechanizmy zaimplementowane w finalnej wersji.


Przeglądowe listy interesujących nas wydarzeń (oczywiście będą nas interesowały aktualne edycje):
- https://www.gocoder.one/blog/ai-game-competitions-list
- https://ieee-cog.org/2022/#COMPETITIONS
- https://icga.org/?page_id=3468
- NeurIPS competitions



Bazowym założeniem jest, że powstałe boty zostaną (jesli będzie to możliwe) wysłane na aktualną edycję wybranych zawodów. W programie przewidujemy również aktywne wspieranie organizowanych w trakcie przedmiotu zawodów CodinGame (charakteryzujących się krótkim czasem trwania od momentu ogłoszenia gry).

Zainteresowani będą mieli okazję włączenia się do badań akademickich, co może stanowić podstawę do pracy magisterskiej lub licencjackiej/inżynierskiej.

Współprowadzącym projekt będzie dr Marek Szykuła."
Project: Machine Learning for Temporal Data Mining,4,zespołowy projekt programistyczny z elementami studiów literatury i prac badawczych,winter,True,False,"Celem projektu jest opracowanie/wykorzystanie/rozszerzenie algorytmów uczenia maszynowego związanych z przetwarzaniem danych czasowych (m.in. szeregów czasowych, modeli ze stanami ukrytymi, itp.) i wykorzystanie ich do konstrukcji prototypu systemu dla wybranego problemu/zbioru danych.

**UWAGA:** Projekt jest przeznaczony dla osób posiadających wiedzę z eksploracji danych i uczenia maszynowego (w zakresie potrzebnym do realizacji projektu) oraz umiejętności techniczne w tym zakresie. Część prac może być wykonywana przez osoby z mniejszym doświadczeniem, ale zalecałbym kontakt emailem i ustalenie tego przed zapisaniem się."
Spectral Graph Theory,6,,winter,True,False,"We would explore the field of Spectral Graph Theory by reading and discussing selected fragments of the following book:
http://cs-www.cs.yale.edu/homes/spielman/sagt/sagt.pdf

This advanced semminar will only be organized if we find a strong group of entusiasts, who would agree to take the challenge of reading and presenting 1 or 2 selected fragments of the book.

As an organizer, I would also participate in this effort. Additionally I would try to comment on the contents being presented.

Depending on the set of people who sign in, the presentations may be either in polish or in english.
However, there are no source materials in polish available.  

This seminar can be considered in relation with another one called ""Advanced LP-based algorithmic techniques"". The one that turns out to be more popular in the vote will be organized."
Project: Coreforge,4,"analiza kodu źródłowego, prezentacja, projekt programistyczny",summer,True,False,"Celem projektu jest praktyczna nauka architektur komputerów poprzez ich implementację w formie umożliwiającej syntezę na układy FPGA. 

W ramach projektu powstaje rdzeń o nazwie Coreblocks, implementujący zestaw instrukcji [RISC-V](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf) (RV32I) w mikroarchitekturze out-of-order. Implementacja będzie miała w założeniu modularny charakter ""generatora rdzeni"", umożliwiający dodawanie, rekonfigurację i wymianę elementów składowych rdzenia bez głębokich zmian w kodzie.

Dalszymi celami projektu są:

* Integracja z generatorem układów SoC (System on Chip) [LiteX](https://github.com/enjoy-digital/litex), co umożliwi użycie rdzenia w charakterze mikrokontrolera.
* Budowa mechanizmów automatycznego testowania, umożliwiających sprawdzanie poprawności oraz parametrów wydajnościowych (np. maksymalna częstotliwość taktowania, liczba użytych zasobów FPGA) w miarę rozwoju projektu.
* Implementacja rozszerzeń architektury (na przykład: instrukcje mnożące i dzielące, instrukcje atomowe, operacje zmiennoprzecinkowe, instrukcje CSR).
* Implementacja [instrukcji uprzywilejowanych](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf) oraz port [OpenSBI](https://github.com/riscv-software-src/opensbi).
* Implementacja i eksperymenty z różnymi rodzajami predyktorów skoków, pamięci cache, itp.

Długoterminowym celem projektu jest uruchomienie na zaimplementowanym rdzeniu systemu operacyjnego Mimiker.

Praca nad projektem będzie miała charakter zespołowy. Student, po przydzieleniu zadania, powinien zapoznać się z wybraną tematyką, ustalić koncepcję implementacji oraz zaprezentować i przedyskutować ją podczas spotkania projektowego. Opracowany kod oraz dokumentacja projektu będzie podlegać recenzji ze strony prowadzącego oraz innych studentów."
Financial Services,5,"Wykład, ćwiczenia",summer,True,False,"**Przedmiot prowadzony przez dr hab., prof. UWr  Edytę Rutkowską z Instytutu Nauk Ekonomicznych.**

#### Cele przedmiotu
1. Przedstawienie kompleksowej wiedzy o istocie, specyfice i cechach charakterystycznych usług
finansowych oraz instytucji je świadczących (instytucji finansowych).
2. Zapoznanie studenta z zagrożeniami i ryzykiem związanym z usługami finansowymi.
3. Zapoznanie z całokształtem regulacji prawnych dotyczących usług finansowych.
#### Treści programowe
Pojęcie i specyfika usług finansowych (usługi bankowe, kredytowe, płatnicze, ubezpieczeniowe,
inwestycyjne); Klient usług finansowych (klient detaliczny, klient profesjonalny, konsument) Źródła
zagrożeń i ryzyka dla klientów usług finansowych. Regulacja usług finansowych w UE.

Podmioty świadczące legalnie usługi finansowe w UE. Zasady podejmowania i prowadzenia
działalności w zakresie świadczenia usług finansowych w UE.

Nowe technologie na rynku usług finansowych. Fin-Tech – problemy pojęciowe i regulacyjne.
Korzyści zagrożenia, - ryzyka dla konsumentów i wyzwania

Umowy o usługi finansowe i ich regulacja w UE - ogólna charakterystyka i tendencje dotyczące ich
regulacji w UE. Koszty usług finansowych (Odpłatność za usługi finansowe)- odsetki, opłaty, prowizje
i inne koszty ponoszone przez klientów). Obowiązki instytucji finansowych wobec klientów usług
finansowych

Usługi depozytowe ich charakterystyka i regulacja

Usługi typu kredytowego ich charakterystyka i regulacja (kredyt bankowy, kredyt hipoteczny, kredyt
konsumencki, konsumencki kredyt hipoteczny, odwrócony kredyt hipoteczny, leasing)

Usługi ubezpieczeniowe ich charakterystyka i regulacja. Dystrybucja usług ubezpieczeniowych

Usługi płatnicze ich charakterystyka i regulacja

Usługi inwestycyjne ich charakterystyka i regulacja

Usługi emerytalne ich charakterystyka i regulacja"
Course: Game Development in Unreal Engine 5,5,"Wykład, indywidualny lub zespołowy projekt programistyczny, samodzielna praca przy komputerze",summer,True,False,"W przeciwieństwie do kursu Unity nie będę omawiał silnika okno po oknie i właściwości po właściwości, zamiast tego pokażę jak napisać pięć przykładowych gier, od początku do końca używając silnika Unreal 5.

Gry które pojawią się na wykładzie:
- rozbijanie ściany z beczek (fizyka, podstawy, blue printy)
- platformówka z przeszkodami (skrypty c++, animacje, postacie humanoidalne)
- lochy (programowanie obiektowe, kolizje, input system)
- czołgi (multi player, game framework)
- TPS (third person shooter, animacje, AI, GUI)

Dodatkowo omówienie systemu technologii oświetlenia globalnego ""Lumen"" oraz systemu ""Nanite"" umożliwiającego budowę scen 3D o bardzo dużym poziomie szczegółowości.

Kurs nie jest od podstaw, co oznacza, że wymaga wcześniejszej znajomości C++ i podstaw programowania."
Combinatorial Optimization under uncertainty,6,wykład,summer,True,False,"Rozważmy portal randkowy (nie tinder), w którym są 44 tysiące kobiet i 44 tysięce mężczyzn. Portal zarabia na miesięcznej subskrypcji, a jego zadaniem jest proponowanie użytkownikom randek. Portal używając danych użytkowników (np. z ankiet na temat cech charakteru, ulubionych filmów i muzyki itd) jest w stanie całkiem nieźle wyestymować dla każdej pary użytkowników prawdopodobieństwo, że dana para się sobie wzajemnie spodoba, o ile tylko pójdzie na randkę.
Pytanie jednak jest następujące: w jaki sposób portal powinien proponować randki, aby zmaksymalizować średnią (lub też totalną w ciągu roku) liczbę szczęśliwie skojarzonych par? Nie możemy przecież wysłać żadnego użytkownika na 100 nieudanych randek, bo do tego czasu zrezygnuje z subskrypcji. Musimy więc robić to ostrożnie. Co więcej dana para, jeśli tylko się sobie spodoba, to natychmiast opuszcza portal (a przynajmniej takie jest sensowne założenie). 
Gdyby nie było tutaj żadnej niepewności i a priori byśmy wiedzieli, które pary się sobie spodobają, a które nie, to naszym zadaniem byłoby obliczenie po prostu maksymalnego skojarzenia w grafie, które możemy zrobić całkiem sprawnie w czasie wielomianowym.
Ale gdy uwzględnimy stochastyczną naturę, czyli że randki mogą się udać albo się nie udać, to problem --- mimo, że cały czas dotyczy skojarzeń w grafach --- staje się nagle zgoła inny. Co więcej, teraz nawet nie tyle, co nie znamy wielomianowego algorytmu, ale nawet nie wiemy, czy ten problem należy do klasy NP. Mimo wszystko na wykładzie zobaczymy 2-aproksymacyjny algorytm dla tego problemu.

Istotą tego przydługiego wstępu była ilustracja faktu, że bardzo często prawdziwie praktyczne problemy mają pewien aspekt niepewności w sobie, a ten z kolei wymusza zupełnie inne podejście do problemu niż w przypadku jego deterministycznego odpowiednika. 
Na wykładzie przedstawię kilka klasycznych modeli niepewności: stochastyczne próbkowanie (przykład portalu randkowego), problem sekretarki (https://en.wikipedia.org/wiki/Secretary_problem), nierówność Proroka (https://en.wikipedia.org/wiki/Prophet_inequality) i algorytmy online oraz jak w tych modelach rozważać struktury kombinatoryczne takie jak skojarzenia lub matroidy (na wykładzie wytłumaczę co to).

Przedmiot będzie mocno matematyczny, a nawet mocno probabilistyczny, jednak nie będziemy potrzebować żadnego zaawansowanego aparatu --- znajomość warunkowej wartości oczekiwanej w zupełności wystarczy."
Tutoring,0,,summer,True,True,"Celem tutoringu jest czuwanie nad właściwą organizacją pracy przez
studenta, śledzenie jego postępów i pomoc w sytuacjach trudnych.

Zajęcia w ramach przedmiotu nie mają wyznaczonych cotygodniowych terminów, lecz odbywają się kilkakrotnie w czasie semestru w terminach wyznaczonych przez prowadzących, w ramach spotkań indywidualnych lub grupowych. Dodatkowo prowadzący są do
dyspozycji studentów na bieżąco, gdy pojawiają się problemy związane z tokiem studiów."
Combinatorial optimization,6,"* Ćwiczenia audytoryjne
* Wykład monograficzny",summer,True,False,"**Program:**

1.Matchingi.

Matchingi (skojarzenia) oraz ich uogólnienia pojawiają się w bardzo wielu
kontekstach, bardziej i mniej oczywistych, m.in. przy:

  * różnego typu przydziałach: zadań pracownikom lub maszynom, studentów szkołom itp.

  * obliczaniu podgrafów, w których każdy wierzchołek ma mieć stopień z podanego przedziału. Za pomocą skojarzeń oblicza się np. pokrycia cyklowe (podgrafy, w kt. każdy wierzchołek ma mieć stopień 2) o najmniejszej/największej wadze. Takie pokrycia przydają się z kolei w znajdowaniu optymalnych dróg komiwojażera,

  * aukcjach.

2.Matroidy.

Przykładami matroidów są lasy w grafach i podzbiory niezależnych liniowo
kolumn danej macierzy.

3.Rozlaczne sciezki, T-joins i T-cuts.

T-joiny mają zastosowania m.in. w wykrywaniu cykli o ujemnej wadze.

4.Przeplywy.

**Wymagania:** matematyka dyskretna, algorytmy i struktury danych"
Digital Image Processing,6,"* lecture
* programming lab
* programming project
* tutorial
* individual computer work",summer,True,False,"Przedmiot może się odbyć w języku polskim lub angielskim o czym możemy zadecydować na pierwszych zajęciach  
(Language can be switched to English or Polish, we can decide about it on the first lecture). 

Advances in digital photography have made great interest in Digital Image Processing (DIP) area and created new research field of Computational Photography (CP). In this lecture we will present both classical DIP methods which are the main tools in image editors as well as the new methods from the CP.

**Topics:**

  1. Color Science and High Dynamic Range Imaging
  2. Per pixel operations, histograms, combining images
  3. Geometrical operations eg. distortion correction
  4. Linear filtering and Fourier transforms
  7. Edge detection
  6. Nonlinear filters eg. median, bilateral
  8. Morphological operators: dylation and erosion
  9. Multiresolution representations
  10. Keypoint detection and image registration
  11. Image segmentation, graphcuts and texture synthesis
  12. Gradient domain image processing

**Requirements:** 
 * some maths: Calculus and Algebra 
 * programming skills: prefered C/C++
 * knowledge of Computer Graphics can be beneficial"
Algebra,7,"* Ćwiczenia audytoryjne
* Wykład",summer,True,True,"**Program:**

1. Przestrzenie liniowe. Zbiory liniowo niezależne. Bazy.
2. Macierze i przekształcenia liniowe. Rząd macierzy. Algorytm eliminacji Gaussa.
3. Wyznaczniki. Własności wyznaczników. Rozwinięcie Laplace’a. 
4. Równania liniowe. Zbiór rozwiązań układu równań liniowych. Wzory Cramera.
5. Wartości i wektory własne. Podprzestrzenie niezmiennicze. Wielomian charakterystyczny.
6. Iloczyn skalarny. Rzut ortogonalny. Izometrie i przekształcenia ortogonalne.
7. Elementy geometrii.
8. Grupy — podstawowe pojęcia: rząd grupy, rząd elementu grupy, podgrupa.
9. Grupy permutacji. Rozkład permutacji na cykle. Znak permutacji. 
10. Działanie grupy na zbiorze.
Orbity i stabilizatory. Lemat Burnside’a. Warstwy. Twierdzenie Lagrange’a.
11. Arytmetyka modularna. Relacja podzielności. Pierścienie i pierścienie Zn.
12. Algorytm Euklidesa. Chińskie twierdzenie o resztach.
13. Pierścienie wielomianów. Podzielność wielomianów.
14. Przykład konstrukcji ciała skończonego.

**Wymagania:**
* Matematyka w zakresie szkoły średniej.
* Podstawy analizy
matematycznej.
* Podstawy logiki i teorii mnogości.

**Literatura**

W zasadzie każda książka do algebry liniowej i algebry
powinna pokryć przerabiany materiał. Poniżej przykładowe pozycje.

1. A. Białynicki-Birula, Algebra
2. G. Birkhoff, S. Mac Lane, Przeglad algebry współczesnej
3. B. Gleigchgewicht,
Algebra
4. A. Kostrikin, J. Manin Algebra liniowa i geometria
5. A. Kostrikin, Zbiór zadań z algebry
6. A. Kostrikin, Wstęp do algebra t. 1-3
7. A. Mostowski, M. Stark, Elementy algebry wyższej
8. A. Mostowski, M. Stark, Algebra liniowa
9. J. Rutkowski, Algebra abstrakcyjna w zadaniach"
Deep Learning (project),6,* projekt programistyczny,summer,True,False,"Celem projektu jest doskonalenie umiejętności programowania metod związanych z
głębokim uczeniem (ang. _deep learning_ ).

W ramach projektu omówione zostaną zastosowania głębokich sieci neuronowych do przetwarzania tekstu i obrazów.

W programie projektu przewiduje się programowanie sieci związanych z klasyfikacją, detekcją obiektów oraz segmentacją obrazów za pomocą takich
sieci neuronowych jak:
  * głębokie sieci splotowe (deep convolutional neural networks, CNN)
  * region-based CNN (RCNN)
  * Mask-RCNN
  * Fast-RCNN, Faster-RCNN

Realizacja projektu będzie wymagała zaprogramowanie całości procesu:
* pobeiranie i przetwarzanie danych
* przygotowanie danych do uczenia i testowania
* utworzenie odpowiedniego modelu
* tranowanie i walidacja modelu
* testowanie modelu
* zapisywanie pośrednich stanów modelu
* otwrzoenie podsumowania z istotnymi dla zadania metrykami.


**Wymagania:** wiedza z analizy matematycznej,
ukończenie przedmiotu z sieci neuronowych, umiejętność programowania w języku Python."
Artificial Intelligence,6,"Wykład, prezentacja, rozwiązywanie zadań z komentowaniem, dyskusja, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze, indywidualny projekt programistyczny",summer,True,False,"Sztuczna inteligencja jest dziedziną budzącą emocje. Chyba każdy programista
chciałby, żeby jego programy (przynajmniej niektóre) działały inteligentnie,
czyli tak jak ludzie, tylko szybciej i bardziej bezbłędnie.

Z drugiej strony budzi też obawy: czy ONE (komputery) będą myśleć lepiej niż
MY (ludzie)? Czy komputer lepszy od człowieka (swego twórcy), będzie mógł
tworzyć jeszcze bardziej inteligentne komputery?

Niniejszy wykład ma na celu przedstawienie najistotniejszych wątków sztucznej
inteligencji, czyli dziedziny, która próbuje modelować zachowanie inteligentne
i tworzyć systemy, które to zachowanie przejawiają.

Choć wykład ma być dość ogólny i przeglądowy, będziemy starać się, by student,
który go ukończy, nie tylko wiedział, jak używać wybrane metody sztucznej
inteligencji, ale je również dobrze rozumiał, potrafił zaimplementować i
zmodyfikować na potrzeby konkretnego zadania.

Będziemy omawiać następujące zagadnienia:
* Modelowanie rzeczywistości za pomocą przestrzeni stanów, metody przeszukiwania z więdzą o problemi i bez wiedzy
* Przeszukiwanie metaheurystyczne: hill climbing, symulowane wyżarzanie, beam search, algorytmy ewolucyjne.
* Rozwiązywanie więzów, wnioskowanie w sieci więzów
* programy grające w różne gry (w tym gry z niepełną informacją), zagadnienia uczenia się strategii, podstawy teorii gier, 
* Decyzyjne procesy Markowa, uczenie ze wzmocnieniem
* uczenie z nadzorem i bez nadzoru
* Modelowanie za pomocą logiki, metody wnioskowania
* Sieci Bayesowskie 
* Wybrane elementy innych dziedzin sztucznej inteligencji


Niektóre zagadnienia mają naturalną kontynuację na przedmiotach Machine learning, Eksploracja danych, Neural Networks and Natural Language Processing, Text mining
czy AI for games -- w takich przypadkach będziemy
koncetrowali się na podstawach tych dziedzin, pozostawiając zainteresowanemu
studentowi możliwość ich zgłębienia na dedykowanych przedmiotach.


W przypadku konieczności organizowania zajęć w formie zdalnej, studenci otrzymają nagrane wykłady, ćwiczenia będą w przeprowadzone z deklaracjami i wspólną pracą nad Raportem z ćwiczeń, zadania na pracownie będą konsultowane i odbierane przy użyciu systemu telekonferencyjnego.

Edycja 2022/2023 będzie miała nową sprawdzaczkę do zadań i nieco większy nacisk na zagadnienia uczenia maszynowego"
From Mordor to Matrix. The Fantastic Political Philosophy,3,Wykład,summer,True,True,"* Przedmiot prowadzony przez dr. hab Bartosza Bolechówa z Instytutu Politologii. *

Zapoznanie studentów z problematyką będącą przedmiotem zainteresowania
filozofii oraz antropologii polityki (natura polityki, wspólnoty politycznej i człowieka
jako „zwierzęcia politycznego”; uniwersalne mechanizmy i aporie władzy,
koncepcje strukturalnej organizacji społeczeństwa; pochodzenie, zmienność,
ewolucja– progres, regres, cykliczność - i postulowana wartość moralna ustrojów
oraz instytucji politycznych; światopoglądy, ideologie, modele polityczne i ich
zderzenia z praxis; legitymizacja; dyskurs polityczny; konflikt społeczny;
rewolucja i wojna; mechanizmy fanatyzmu, ekstremizmu i radykalizmu, utopia
jako fikcja spekulatywna; dystopia jako krytyka polityczna, sprzężenie zwrotne
między nieuświadomioną i uświadomioną fikcją a praktyką polityczną) poprzez
analizę utworów, gatunków, konwencji i toposów historycznej oraz współczesnej
fantastyki."
Professional Practice,4,Realizacja zadań postawionych przez pracodawcę.,summer,True,False,Zaliczenie praktyki zawodowej jest wymagane do ukończenia studiów pierwszego stopnia.
Mentoring for Data Science,0,,summer,True,False,A series of meetings with a teacher designated as mentor for Data Science students. Students are welcome to make individual appointments with the mentor whenever they need advice or help in all academic matters.
Sport programming in practice,2,,summer,True,False,"Na zajęciach studenci będą rozwiązywali zadania z zespołowych zawodów  
programistycznych. Każde spotkanie będzie miało formę pięciogodzinnego  
treningu przygotowanego na podstawie jednego z konkursów organizowanych  
w formule ICPC. Głównym celem zajęć jest przygotowanie drużyn, które  
reprezentują Uniwersytet Wrocławski w Akademickich Mistrzostwach Polski  
w Programowaniu Zespołowym, a później w zawodach ICPC. Ta drużynowa  
formuła nie oznacza jednak, że warunkiem uczestniczenia w zajęciach jest  
posiadanie stałej drużyny, gdyż celem naszych spotkań będzie także  
sprawdzenie w praktyce różnych strategii i składów zespołów."
Clone: Financial Services,3,"Wykład, ćwiczenia",summer,True,False,"**Przedmiot prowadzony przez dr hab., prof. UWr  Edytę Rutkowską z Instytutu Nauk Ekonomicznych.**

#### Cele przedmiotu
1. Przedstawienie kompleksowej wiedzy o istocie, specyfice i cechach charakterystycznych usług
finansowych oraz instytucji je świadczących (instytucji finansowych).
2. Zapoznanie studenta z zagrożeniami i ryzykiem związanym z usługami finansowymi.
3. Zapoznanie z całokształtem regulacji prawnych dotyczących usług finansowych.
#### Treści programowe
Pojęcie i specyfika usług finansowych (usługi bankowe, kredytowe, płatnicze, ubezpieczeniowe,
inwestycyjne); Klient usług finansowych (klient detaliczny, klient profesjonalny, konsument) Źródła
zagrożeń i ryzyka dla klientów usług finansowych. Regulacja usług finansowych w UE.

Podmioty świadczące legalnie usługi finansowe w UE. Zasady podejmowania i prowadzenia
działalności w zakresie świadczenia usług finansowych w UE.

Nowe technologie na rynku usług finansowych. Fin-Tech – problemy pojęciowe i regulacyjne.
Korzyści zagrożenia, - ryzyka dla konsumentów i wyzwania

Umowy o usługi finansowe i ich regulacja w UE - ogólna charakterystyka i tendencje dotyczące ich
regulacji w UE. Koszty usług finansowych (Odpłatność za usługi finansowe)- odsetki, opłaty, prowizje
i inne koszty ponoszone przez klientów). Obowiązki instytucji finansowych wobec klientów usług
finansowych

Usługi depozytowe ich charakterystyka i regulacja

Usługi typu kredytowego ich charakterystyka i regulacja (kredyt bankowy, kredyt hipoteczny, kredyt
konsumencki, konsumencki kredyt hipoteczny, odwrócony kredyt hipoteczny, leasing)

Usługi ubezpieczeniowe ich charakterystyka i regulacja. Dystrybucja usług ubezpieczeniowych

Usługi płatnicze ich charakterystyka i regulacja

Usługi inwestycyjne ich charakterystyka i regulacja

Usługi emerytalne ich charakterystyka i regulacja"
Tutoring ISIM,0,,summer,True,True,"Celem tutoringu jest czuwanie nad właściwą organizacją pracy przez
studenta, śledzenie jego postępów i pomoc w sytuacjach trudnych.

Zajęcia w ramach przedmiotu nie mają wyznaczonych cotygodniowych terminów, lecz odbywają się kilkakrotnie w czasie semestru w terminach wyznaczonych przez prowadzących, w ramach spotkań indywidualnych lub grupowych. Dodatkowo prowadzący są do
dyspozycji studentów na bieżąco, gdy pojawiają się problemy związane z tokiem studiów."
Seminar: Analysis of algorithmic problems,3,,summer,True,True,"Uwaga: seminarium planujemy prowadzić (pod taką samą nazwą) zarówno w semestrze zimowym jak i letnim. Można je będzie zaliczyć więcej niż raz.

Zajęcia będą poświęcone analizie trudnych zadań z zawodów programistycznych
typu ICPC, TopCoder, czy Google Code Jam.

Głównym celem spotkań będzie zarówno zapoznanie studentów z ogólnymi
zaawansowanymi technikami algorytmicznymi, które przydają się w takich
problemach, a nie są przedstawiane na wykładzie z Algorytmów i Struktur
Danych, jak i regularne omawianie ciekawszych zadań, które pojawią się na
niedawno przeprowadzonych konkursach. Podczas dyskusji zostaną poruszone także
bardziej praktyczne kwestie sprawnej implementacji skomplikowanych rozwiązań.

Zajęcia są przeznaczone dla studentów, którzy zdobyli już spore doświadczenie
podczas startów w zawodach programistycznych podczas studiów lub z sukcesami
startowali w Olimpiadzie Informatycznej.

Jeśli prowadzenie zajęć stacjonarnych okaże się niemożliwe to seminarium będzie miało formę spotkań online."
Geometric Optimization,6,,summer,True,False,"The course will be given by Sandip Banerjee.
It will cover the following topics:

1) Randomized Incremental Construction (RIC) (2-3 lectures)
* Random sampling in computational geometry
* Convex hull, Dynamic maintenance using RIC
* RIC of Delaunay and Voronoi diagrams.

2) Epsilon-approximation and Epsilon-nets (2 lectures)
* Basic definitions, applications, range space and VC-dimension
 * Discrepancy

3) Geometric covering problems (2-3 lectures)
* Geometric Covering and packing problems
* Geometric hitting set problem

4) Coresets and Clustering (3-4 lectures)
*  Centroid based like k-center, k-median, k-means and Density based clustering
        like min-sum clustering 

5) Metric embedding (3-4 lectures)

 * Basic definition, doubling metric, distortion
 * Emedding into l_p space
 * JL-lemma
 * Probabilistic embedding

6) Network design (2-3 lectures)
* Eucledian spanners
* Well-separated pair decomposition
* Euclidean TSP

Pre-requisite: (i) Algorithm course.(ii) Basic idea of Linear programming and probability
will help but not mandatory. 

Literature: A large part of the course will follow the books:

   (i) Geometric approximation algorithms (Author- Sariel Har-Peled)

   (ii) Algorithmic geometry (Author- J.D. Boissonnat,  Mariette Yvinec and
           Herve Bronniman)"
Diploma Project,4,"Studenci prezentują wyniki etapów realizacji pracy dyplomowej
Podczas zajęć następuje systematyzacja wiedzy i rozwinięcie umiejętności planowania zakresu i przebiegu produktu przedsięwzięcia informatycznego.
Przedmiot  Projekt Dyplomy ma charakter wspomagający przygotowanie, redakcje i kompletacje  dokumentacji  i innych produktów wytwarzanych w celu osiągnięcia celu pracy dyplomowej.
 Zajęcia przygotowują do samodzielnego i świadomego współudziału w analizie zagadnień, kształtowaniu i planowaniu projektów informatycznych.",summer,True,False,W ramach przedmiotu studenci przygotowują prace dyplomową wymaganą do zakończenie studiów lic/inż pod kierunkiem dr. inż Leszka Grocholskiego. Tematy proc dyplomowych wymagają zaakceptowania przez Komisję ds. Prac Dyplomowych.
Object-oriented Software Development,6,"* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",summer,True,False,"Wykład skierowany jest do przyszłych architektów systemów informatycznych oraz
do wszystkich programistów zainteresowanych udoskonaleniem swojego warsztatu.
Celem wykładu jest zapoznanie studentów z kanonem współczesnych narzędzi w
zakresie projektowania obiektowego oprogramowania.

Materiał wykładu obejmuje:

  * podstawy języka UML w zakresie wymaganym przez projekty analityczne i techniczne
  * zasady SOLID i GRASP
  * przegląd katalogu wzorców projektowych (GoF) (m.in. Observer, Builder, Bridge, State, Strategy, Facade, Adapter, Mediator, itd.)
  * przegląd katalogu wzorców architektury aplikacji (wzorce architektoniczne) (m.in. Model-View-Controller, Object-Relational Mapping, Dependency Injection, Service Locator, Mock Object, itd.)
  * przegląd katalogu wzorców architektury systemów (Enterprise Service Bus, Single Sign-on)

Celem pracowni jest praktyczny kontakt z materiałem z wykładu.

Wymagania: ukończony kurs języka Java lub C# (wszystkie przykłady będą
bazowały na języku C#)

Literatura:

  1. Wrycza, Marcinkowski, Wyrzykowski - Język UML 2.0 w modelowaniu systemów informatycznych
  2. Fowler - Refactoring: Improving the Design of Existing Code Gamma, Helm, Johnson, Vlissides: Design Patterns: Elements of Reusable Object-Oriented Software
  3. Fowler - Patterns of Enterprise Application Architecture Microsoft Patterns & Practices - Application Architecture Guide"
Project: Development of the Enrollment System,4,"* Projekt programistyczny
* Pracownia programistyczna",summer,True,False,"W ramach projektu grupa studentów rozwija istniejący System Zapisów na zajęcia: ulepsza istniejące funkcjonalności, usuwa niepotrzebne i wprowadza nowe.

System Zapisów napisany jest w Pythonie z użyciem framework-u Django, a elementy front-endowe zazwyczaj powstają w TypeScript'cie. Jednakowoż znajomość tych technologii nie jest warunkiem koniecznym uczestnictwa w projekcie. Oczekuje się od studentów raczej gotowości do zanurzenia się w dużym, istniejącym projekcie, rozpoznania terenu i wykonywania w nim zadań.

Przedmiot zalicza wymaganie projektu zespołowego. Można uczestniczyć w nim wielokrotnie.

Praca zespołowa studentów oparta jest na GitHubie (issue, pull-request, code-review), a bieżąca komunikacja jest asynchroniczna (z wykorzystaniem komunikatora)."
Seminar: Software Engineering,3,Prepared by students lectures,summer,True,False,"During Seminar Software Engineering Students  present popular standards, methods, tools use during software development. 
In presentation it is particularly important for students who work in leading IT companies to inform less experience students information about what methods they use and what tools they use when developing software.
Seminar aimed at inspiring future software engineers for self-development  and  self-preparation for professional work."
Digital logic,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",summer,True,True,"Wykład jest wprowadzeniem do projektowania układów cyfrowych. Celem wykładu
jest nauczenie zasad rządzących funkcjonowaniem elektroniki cyfrowej oraz
typowych rozwiązań stosowanych przy projektowaniu układów. Wiedza zdobyta na
wykładzie pomoże w zrozumieniu zasady działania mikroprocesorów i
mikrokontrolerów oraz zasad rządzących programowalnymi układami logicznymi
FPGA.

#### Wymagania

Wykład nie wymaga wcześniejszego zaliczenia innych przedmiotów.

#### Program

  1. Wprowadzenie do układów cyfrowych
  2. Technologie implementacji układów cyfrowych
  3. Elementy Veriloga jako języka opisu sprzętu
  4. Optymalizacja funkcji logicznych
  5. Układy arytmetyczne
  6. Podstawowe układy kombinacyjne
  7. Zatrzaski i przerzutniki
  8. Automaty Moore'a i Mealy'ego
  9. Układy sekwencyjne
  10. Budowa prostego procesora

#### Literatura

  * Fundamentals of Digital Logic with Verilog Design; Brown, Vranesic; McGraw-Hill
  * Digital Design: With an Introduction to the Verilog HDL, VHDL, and SystemVerilog (6th Edition); Mano, Ciletti; Pearson"
Programming methodology,9,"wykład, live coding, dyskusja, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań, samodzielna praca przy komputerze",summer,True,True,"Naszym celem jest przygotowanie studentów do używania języków programowania
jako formalnych narzędzi komunikacji między ludźmi, w szczególności jako
technik które mogą i powinny być stosowane do zapanowania nad złożonością
intelektualną dużych systemów. W tym celu zajmiemy się zarówno konkretnymi
narzędziami których projektanci języków programowania dostarczają
programistom, jak i ogólnymi zasadami konstrukcji języków programowania.

Wykład prowadzą Marek Materzok, Maciej Piróg i Filip Sieczkowski.

#### Program:

  1. Elementy programowania
  2. Rekursja i abstrakcja proceduralna
  3. Wprowadzenie do abstrakcji danych
  4. Dane hierarchiczne i własność domknięcia
  5. Dane symboliczne i wielorakie reprezentacje danych
  6. Składnia abstrakcyjna i podstawy ewaluacji
  7. Środowiskowy model obliczeń
  8. Ewaluator metacykliczny
  9. Reprezentacja wartości w metajęzyku
  10. Składnia konkretna jako język dedykowany
  11. Zarządzanie złożonością: kontrakty
  12. Zarządzanie złożonością: systemy typów
  13. Obliczenia z danymi modyfikowalnymi
  14. Elementy programowania współbieżnego
  15. Programowanie w logice"
Economic Policy Policy,3,Wykład,summer,True,False,"*Przedmiot prowadzony przez dr. Mirosława Strusia z  Instytutu Nauk Ekonomicznych.*

Celem przedmiotu jest zapoznanie studentów z podstawami i głównymi
pojęciami polityki gospodarczej w otwartej gospodarce rynkowej, w celu umożliwienia im lepszego
zrozumienia głównych zagadnień i problemów związanych z przebiegiem procesów gospodarczych."
C++ course,5,"Wykład, live coding, analiza programów dostarczonych przez wykładowcę, konsultowanie pomysłów na rozwiązania zadań, samodzielna praca programistyczna w domu oraz na zajęciach.",summer,True,True,"**C++** to język programowania o charakterze obiektowym.
Jest to obecnie jeden z najbardziej znanych i popularnych języków programowania, wykorzystywany w różnych działach IT ale przede wszystkim do programowania systemowego, aplikacji narzędziowych, wykonywania obliczeń inżynierskich oraz do tworzenia gier komputerowych. 
Charakteryzuje się wysoką wydajnością kodu wynikowego, przenaszalnością tego kodu pomiędzy różnymi platformami oraz łatwością tworzenia i używania z bibliotek. 
C++ jest na pewno podstawowym narzędziem pracy milionów programistów na całym świecie.

Język C++ jest potomkiem języka C.
Te dwa języki są do siebie podobne składniowo ale w istocie mocno się różnią.
Prace nad tym językiem rozpoczął duński naukowiec Bjarne Stroustrup już w 1979 roku.
Nazwa języka ukonstytuowała się w roku 1983, kiedy to po raz pierwszy użyto go poza laboratorium naukowym. 
Natomiast pierwszy oficjalny standard C++ ISO/IEC 14882-1998 został opublikowany dopiero w 1998 roku.

Kurs C++ jest poświęcony nauce programowania obiektowego w C++.
Jest to język bardzo różnorodny, dający olbrzymie możliwości optymalizacji kodu, wyposażony w obszerną bibliotekę standardową. 
Na kursie można się zapoznać z bogatą składnią tego języka, wieloma technikami programistycznymi oraz trikami pozwalającymi łatwo rozwiązywać pewne standardowe ale trudne zadania.
Omawiane są także najważniejsze fragmenty biblioteki STL."
Numerical Optimization,8,"Lecture, problem solving in class, individual work at the computer, programming project",summer,True,False,"_Mandatory course for Data Science._

This course is a detailed survey of optimization from both a computational and theoretical perspective. Theoretical topics include convex sets, convex functions, optimization problems, least-squares, linear and quadratic programs, optimality conditions, and duality theory. Special emphasis is put on scalable numerical methods for analyzing and solving general smooth unconstrained problems (e.g. first-order and second-order methods), quadratic programs (e.g. linear least squares), general smooth constrained problems (e.g. interior-point methods), as well as, a family of non-smooth problems (e.g. ADMM method).

The applications in data sciences, such as machine learning, model fitting, and image processing, will be discussed. The computational part covers the following algorithms: gradient method, quasi-Newton methods, proximal gradient method, Nesterov’s accelerated gradient method and stochastic gradient descent method. Students complete hands-on exercises using high-level numerical software.

## Prerequisites
- not scared of math
- good knowledge of linear algebra
- multivariable calculus skills
- programming skills; Python is recommended.

## Topics overview
- (Numerical) Linear algebra review
- Iterative methods solving linear system of equations
- First and second order methods + quasi Newton methods
- Convex Functions
- Unconstrained Optimization
- Stochastic Methods"
Algorithms and Data Structures,9,"wykład, rozwiązywanie zadań z komentowaniem, indywidualne rozwiązywanie zadań, analiza algorytmów (poprawność, złożoność), indywidualne rozwiązywanie zadań programistycznych",summer,True,False,"Zajęcia do przedmiotu prowadzone są razem z zajęciami na poziomie M. Chętni na
Algorytmy i struktury danych (M) powinni zapisywać się na zajęcia do
Algorytmów i struktur danych (L). W praktyce przedmioty różnią się wymiarem
pracowni (liczbą wymaganych zadań), wymaganiami na zaliczenie oraz wymaganiami
na egzaminie.

W bieżącym roku ćwiczenia będą prowadzone w wymiarze 3h tygodniowo, z czego trzecia godzina jest nieobowiązkowa na poziomie L."
Cryptography,6,"wykład, wykład interaktywny, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów",summer,True,False,"**Cel zajęć:**

Celem wykładu jest zapoznanie uczestnikow z nowoczesnymi metodami służącymi do
ochrony prywatnosci danych elektronicznych, autentyfikacji użytkownikow
systemow komputerowych, zabezpieczaniu przed nieuprawnionymi modyfikacjami
danych i innymi tego typu zastosowaniami opartymi na technikach
kryptograficznych. Znaczenie tego typu metod ujawnia się szczegolnie ostro w
epoce powstawania globalnych sieci komputerowych, gdzie systemy operacyjne nie
gwarantują już bezpieczeństwa.

Głowny nacisk położony zostanie na prezentację metod albo obecnie stosowanych,
bądź też wchodzących do praktyki. Niemniej jednak uczestnicy wykładu będą
mieli okazję zapoznania się z materiałem teoretycznym będącym podstawa dla
zrozumienia tych metod.

Uczestnicy zajęc przygotowani zostaną do pracy w zakresie projektowania i
użytkowania systemow w zakresie problematyki bezpieczeństwa.

**Program:**

  * podstawowe rodzaje funkcji kryptograficznych, szyfrowanie symetryczne, asymetryczne, hashowanie, itp.;
  * podstawowe protokoły kryptograficzne: dzielenie tajemnic, zobowiązanie bitowe, pieniądze cyfrowe, elektroniczne wybory;
  * algorytmy symetryczne: DES, IDEA, rozszerzenia DES-a, RC5;
  * tryby pracy: ECB, CBC, CFB;
  * kryptoanaliza rożnicowa, liniowa, błędow;
  * algorytmy asymetryczne: RSA, ElGamal;
  * funkcje hashujące: oparte o dyskretny logarytm, MD5, tryby pracy;
  * generatory pseudolosowe: LFSR, BBS;
  * podpisy cyfrowe: ElGamal, DSA, ślepe podpisy, kanał podprogowy, podpisy niezaprzeczalne,
  * uwierzytelnianie: challenge and response, dowody interakcyjne i z wiedzą zerową, protokoł Schnorra, podpisy cyfrowe przez uwierzytelnianie;
  * administracja kluczami: przechowywanie kluczy, uzgadnianie kluczy, protokoł Diffie-Hellmana i jego pochodne;
  * plastikowe pieniądze: smart cards, PIN;
  * protokoły zabezpieczania komunikacji: Kerberos, ssh, SSL, cyfrowa komunikacja telefoniczna;
  * szyfrowanie systemow plikow;
  * protokoły obrotu finansowego
  * systemy oparte na krzywych eliptycznych.

**Wymagania:** Matematyka dyskretna"
Neural Networks and Natural Language Processing,6,"* Programming project
* Programming laboratories
* Research project
* Lecture

In case of further University lockdown the course will be offered remotely:

* Lectures will be delivered over a videconference system and recorded
* Assignments will be graded using a combination of automatic grading tools and presentations over conferencing systems
* The project will feature presentations given to other students
* The final exam may be held remotely in the form of quizzes and oral evaluations during 1-on-1 calls",summer,True,False,"Neural Networks allow creation of programs that are learned rather than written. This means that instead of implementing a concrete algorithm, the program applies patterns that are automatically found in the data. For example, a translation system such as Google Translate can be created by applying a deep neural network to a large corpus of translated documents. The aim of this course is to present the basics of how neural networks work, both from a more theoretical and practical point of view. Neural Networks can be applied to a wide spectrum of tasks, including image and video processing, creating game playing agents, financial data analysis, or even using a computer as a writer, painter or composer. We will try to address many such issues with the emphasis on natural language processing.

The lecture can be treated as a continuation of the following courses: Machine Learning, and Natural Language Processing.

The first part of this course is shared with the Neural Networks and Deep Learning. However, students who have finished NN-DL can enroll in this course, and obtain 50% of ECTS points (there will be special rules for them, allowing them to concentrate only on the new material).
 

The lecture will be accompanied by computer exercises, including small exercises illustrating key topics, slightly more demanding tasks giving better understanding of neural networks and a larger project that will give you the opportunity to tackle a real world machine learning problem.

We will introduce the PyTorch deep learning framework, and PyTorch-based popular NLP libraries (Flair, AllenNLP)

This course will have two lecturers: Rafał Nowak, for the first part and Paweł Rychlikowski for the second part."
Computer networks,6,"* wykład 
* ćwiczenia warsztatowe
* rozwiązywanie zadań z komentowaniem 
* indywidualne/grupowe rozwiązywanie zadań
* indywidualny  projekt programistyczny",summer,True,False,"Wykład jest wstępem do szerokiej tematyki sieci komputerowych. Przedstawione będą na nim podstawowe zasady działania sieci komputerowych, ze szczególnym uwzględnieniem sieci opartych na protokole TCP/IP, oraz przegląd zastosowań sieciowych spotykanych w Internecie. Nacisk położony będzie na przedstawienie słuchaczowi mechanizmów, protokołów i algorytmicznych podstaw stojących za problemami komunikacji w sieciach, a także na praktyczne wykorzystanie
elementów tej wiedzy.

**Omówione zostaną następujące zagadnienia:**

1. Podstawowe pojęcia, protokoły, model warstwowy.
2. Warstwa sieciowa: adresowanie CIDR, routing, protokoły IP i ICMP, tworzenie tablic routingu oparte o stan łączy i wektory odległości, systemy autonomiczne, budowa routera, NAT.
3. Warstwa łącza danych i fizyczna: Ethernet, sieci bezprzewodowe, dostęp do współdzielonego nośnika (CSMA/CD, CSMA/CA).
4. Warstwa transportowa: niezawodny transport, mechanizmy okna przesuwnego, kontrola przepływu, kontrola przeciążenia, protokoły UDP i TCP. 
5. Warstwa zastosowań: DNS, HTTP, poczta elektroniczna, sieci P2P, serwery proxy, współpraca z NAT.
6. Programowanie gniazd: gniazda surowe, datagramowe i strumieniowe. 
7. Podstawy kodowania i kryptografii: kody detekcyjne (CRC) i korekcyjne, szyfrowanie, podpisy cyfrowe, RSA, SSL, PGP.
8. Podstawy bezpieczeństwa sieci.

**Wymagania wstępne:**

Zrealizowane przedmioty:

* Algebra lub Matematyka dyskretna
* Systemy operacyjne lub Systemy komputerowe

Niezbędne kompetencje:

* Znajomość grup i pierścieni. 
* Znajomość tematyki procesów, sygnałów i komunikacji międzyprocesowej.
* Obsługa wiersza poleceń w systemie Linux, umiejętność pisania prostych skyptów w powłoce.
* Dobra umiejętność programowania w C lub C++."
Game Testing,6,"wykłady, wykłady interaktywne, nadzorowane rozwiązywanie problemów,
indywidualne / zbiorowe rozwiązywanie problemów, analiza wymagań i przypadków testowych (poprawność, testowalność, złożoność, planowanie i wykonywanie testów)",summer,True,False,"Nie naprawimy ułomności natury ludzkiej. Programiści i inżynierowie oprogramowania będą nadal popełniać błędy; projektanci gier wprowadzą exploity, artyści zapomną o ważnych szczegółach.
To od testerów gry zależy czy wystąpią  przerwy w zabawie z niedopracowaną grą i czy gra odniesie komercyjny sukces.  Celem przedmiotu Testowanie gier jest pomoc w doskonaleniu umiejętności wystarczająco dobrego testowania gier komputerowych."
Theoretical Foundations of Programming Languages,6,"* Wykład
* Ćwiczenia",summer,True,False,"Programy i języki programowania (funkcyjne) będą rozpatrywane jako obiekty matematyczne. Nacisk będzie położony na związki programowania z logiką i dowodami formalnymi (izomorfizm Curry'ego-Howarda). Będą omawiane systemy typów, polimorfizm, podtypowanie, teoretyczne podstawy języków obiektowych. 
Jako ""język programowania"" będzie wykorzystywany przede wszystkim rachunek lambda, ale będą też przykłady w językach Haskell, OCaml, Idris, ...

Wcześniejsza znajomość rachunku lambda ani izomorfizmu Curry'ego-Howarda  nie jest wymagana.

Nauczanie zdalne
W razie konieczności możliwe jest przejście na tryb zdalny. Materiały do wykładów będą umieszczane na SKOSie (jak zawsze), a wykład będzie prowadzony on-line z wykorzystaniem wybranej platformy. Zadania na ćwiczenia też będą umieszczane na SKOSie (jak zwykle), rozwiązania studentów będą dostarczane za pośrednictwem SKOSa, a prowadzący zapewni informację zwrotną. Ćwiczenia też będą prowadzone on-line. Wskazani studenci będą prezentowali swoje rozwiązania na forum grupy z możliwością dyskusji."
Advanced Distributed Algorithms,6,"* Ćwiczenia audytoryjne
* Wykład",summer,True,False,"Obliczenia rozproszone stanowią obecnie naturalny sposób przetwarzania
informacji – od sieci globalnych jak Internet do systemów wieloprocesorowych
czy wielordzeniowych. Środowisko rozproszone daje możliwość przyspieszenia
obliczeń dzięki podziale zadań na wiele komputerów. Jednocześnie dane, na
których prowadzone są obliczenia są często rozproszone w sieci (niedostępne w
całości poszczególnym komputerom), co stanowi istotne utrudnienie i wymaga
kosztownej komunikacji. Dlatego oprócz czasu obliczeń i zużywanej lokalnie
pamięci, w konstrukcji algorytmów rozproszonych kluczowe są też inne miary
jakości, m. in.:

  * liczba rund komunikacji koniecznych do zakończenia obliczeń,
  * rozmiar przesyłanych pojedynczych wiadomości jak i sumaryczny ruch w sieci konieczny do rozwiązania problemu,
  * opóźnienia (latency) w dostarczaniu wiadomości,
  * stabilizacja (osiągnięcie stabilnego pożądanego stanu obliczeń).

Celem wykładu jest zapoznanie studentów z najpopularniejszymi obecnie modelami
obliczeń rozproszonych oraz problemami **algorytmicznymi** w nich
występującymi. W szczególności wykład skoncentrowany będzie na rozwiązywaniu
problemów grafowych w środowisku rozproszonym, a także na problemach
algorytmicznych związanych komunikacją i koordynacją współpracujących
jednostek, odpornościa na błędy, współdzieleniem łączy komunikacyjnych i
innych zasobów. Rozważane będą klasyczne modele obliczeń rozproszonych (Local,
Congest, pamięć dzielona) jak i nowsze (Congested Clique, radio/wireless
networks, MapReduce).

Wykład obejmować będzie m.in. następujące problemy w różnych modelach obliczeń
**rozproszonych** :

  1. Rozproszone kolorowanie grafu (sieci)
  2. Wyznaczenie składowych spójności grafu, (minimalnych) drzew spinających, BFS
  3. Wyznaczanie najkrótszych ścieżek, problemy rutingu
  4. Wyznaczanie maksymalnego zbioru niezależnego, minimalnego zbioru dominującego
  5. Wyznaczanie minimalnych/maksymalnych cięć w grafie
  6. Klastrowanie i dekompozycja sieci
  7. Rozgłaszanie (broadcasting) i zbieranie (gathering) informacji, elekcja lidera, łamanie symetrii w sieciach (ad hoc).
  8. Problemy algorytmiczne w środowisku z pamięcią dzieloną.

Tematyka wykładu będzie zbliżona m.in. do wykładów:

  * [ETH](https://disco.ethz.ch/courses/podc/)
  * [Aalto](https://users.ics.aalto.fi/suomela/da/)
  * [Yale](http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf)

Na wykładzie przyjmuje się, że studenci znają materiał z przedmiotu Algorytmy
i Strutkury Danych, posiadają też podstawową wiedzę z rachunku
prawdopodobieństwa.

Uwaga. Program przedmiotu nie pokrywa się z programem przedmiotu _Algorytmy
rozproszone_ prowadzone. Studenci mogą zaliczać oba przedmioty.

**Literatura**

  1. David Peleg. Distributed Computing: A Locality-Sensitive Approach Society for Industrial and Applied Mathematics (SIAM), 2000, ISBN 0-89871-464-8
  2. Hagit Attiya, Jennifer Welch. Distributed Computing: Fundamentals, Simulations and Advanced Topics McGraw-Hill Publishing, 1998, ISBN 0-07-709352 6
  3. Juraj Hromkovic, Ralf Klasing, Andrzej Pelc, Peter Ruzicka, Walter Unger. Dissemination of Information in Communication Networks Springer-Verlag, Berlin Heidelberg, 2005, ISBN 3-540-00846-2
  4. Skrypty do wymienionych powyżej wykładów na różnych uczelniach.

###### Przewidywana formie zajęć w przypadku konieczności prowadzenia zajęć zdalnie:

- wykłady i ćwiczenia będą prowadzone w formie wideokonferencji."
Seminar: Computer Graphics,3,"* samodzielna praca
* przygotowanie prezentacji
* prezentacja
* dyskusja",summer,True,False,"Celem seminarium jest przegląd ciekawszych prac z ostatnich lat dotyczących szeroko rozumianej grafiki komputerowej. Wymagana jest znajomość tematyki minimum na poziomie wykładu z podstaw grafiki komputerowej i ciekawość wiedzy, część prac może dotykać tematyki przetwarzania obrazów czy też ogólniej wizji komputerowej. Omawiać będziemy prace z wiodących konferencji takich jak np. ACM SIGGRAPH, EUROGRAPHICS.

Uczestnicy seminarium zapoznają się ze stanem bieżących badań w wybranych tematach i nabędą umiejętność dalszego zgłębiania rozwoju grafiki komputerowej poprzez śledzenie i czytanie prac z renomowanych konferencji naukowych. 

Odnośniki:
 * http://www.siggraph.org
 * http://www.eg.org
 * http://kesen.realtimerendering.com"
Clone: Ethics for the thinking,3,"Wykład, dyskusja",summer,True,False,"Na co dzień etyka nie jest ci potrzebna. Wiesz co robić. Ale czasem sprawy się komplikują…
- w twojej pracy leży laptop. Nikt go nie używa, nikt się nim nawet nie interesuje. Gdybyś go wziął, nikt by się nawet nie zorientował. Przydałby ci się taki laptop…
- spotykasz się z dziewczyną. Wiesz, że nigdy nie zwiążesz się z nią na poważnie, choć ona bardzo na to liczy. Powiedzieć jej o tym? Po co – jej bliskość jest ci tak przyjemna. A może, co gorsze, przydarzyła wam się „wpadka”? Na szczęście jest pewne proste rozwiązanie. Ale czy faktycznie jest ono tak proste, jak weekendowy wyjazd do Austrii lub Holandii?
- zostać w tym kraju czy wyjechać na stałe? Choć masz stąd tożsamość, wykształcenie i miłe obyczaje świąteczne, to jednak tkwienie w tym całym bałaganie... Co prawda mógłbyś zostać i próbować zmieniać swoje najbliższe otoczenie, mógłbyś swoją wiedzą pomnażać dobrobyt  jego mieszkańców, ale z drugiej strony wyjeżdżasz i masz święty spokój, no i te zarobki…

W tego typu sytuacjach zaczynasz się zastanawiać na tym co jest dobre, a co złe, co jest słuszne a co niewłaściwe, co jest powinne a co przeciwpowinne, co jest twoim obowiązkiem, a czego nie wolno ci robić, co jest godne zasługi, a co godne potępienia. Im dłużej się jednak zastanawiasz, tym bardziej zdajesz sobie sprawy z tego, że tak naprawdę nie rozumiesz znaczenia tych pojęć. Wartość, obowiązek, cnota, honor, dobro, powinność, szczęście  – wszystkie te pojęcia są jakoś związane z moralnością, ale czym się od siebie różnią? Co oznaczają?

Ten kurs daje ci możliwość zapoznanie się z podstawowymi sposobami odpowiedzi na pytanie o sens pojęć moralnych. Tok myśli będzie prowadzony w porządku historycznym, zaczniemy od Sokratesa i Platona, a skończymy na współczesnej fenomenologii. Nie zniechęcaj się jednak, bo w etyce, jak w całej filozofii, stare nie oznacza przestarzałe. Dawne koncepcje są laboratorium współczesnego myśliciela. Tak więc poprzez dzieje refleksji etycznej będziemy starali się o analizę podstawowych pojęć moralnych. 

Bądź jednak świadomy, że odbycie tego kursu nie sprawi, że rozstrzyganie twoich problemów moralnych stanie się łatwe. Choć będziesz bardziej świadomy czym jest obowiązek, ale wciąż będziesz musiał sam ustalać, co jest twoim obowiązkiem w tej konkretnej chwili. Będziesz wiedział czym jest wartość, ale sam będziesz musiał rozstrzygać, za którą z dwóch opcji dylematu moralnego kryje się wyższa wartość. Jaka więc korzyść z tego kursu? Subtelniejszy język do przemyśleń moralnych i budowy własnego światopoglądu, większa samoświadomość w sytuacjach granicznych. To już chyba coś?


**Przedmiot będzie prowadzony przez dr. Marcina Drofiszyna z Katedry Logiki i Metodologii Nauk.**"
Scala in Practice,5,"* Lectures (theory & live-coding)
* Programming exercises & demos
* Code reviews
* Reading",summer,True,False,"Scala is currently one of the most popular programming languages, with a [high demand](https://insights.stackoverflow.com/survey/2019?utm_source=Iterable&utm_medium=email&utm_campaign=dev-survey-2019#top-paying-technologies) amongst software development companies, globally.


It’s functional & object oriented dual nature, static typing, high expressiveness & JVM integration makes it a perfect choice for many companies. User’s include the likes of Twitter, LinkedIn, Infor, Netflix &  Amazon, amongst others.  These companies use Scala to create web portals, big data applications... and code-generators [[ScalaUA 2019](https://www.youtube.com/watch?v=DLjALS_Lbn8&feature=youtu.be)].

The goal of this course is to introduce students to the syntax of the language, along with the frameworks and libraries associated with it, which are a standard in the industry.

**Course Syllabus:** 
 
#### I. Scala syntax
 * Code standards  
 * Types
 * Classes & objects
 * Traits
 * Functions & closures
 * Collections
 * Case classes & pattern matching
 * Lambdas
 * Implicit parameters
 * Futures
 * Cooperation with Java

#### II. Frameworks & libraries
 * Scala in commercial applications
 * Build tool - [[Sbt](https://www.scala-sbt.org)] 
 * Testing - [[ScalaTest](http://www.scalatest.org/)] 
 * Database access - [[Slick](http://scala-slick.org/)] 
 * Web applications - [[Play Framework](https://www.playframework.com)]  
 * Concurrent and distributed applications [[Akka](https://akka.io)]
 * Functional Programming - [[Cats](https://typelevel.org/cats/)] 

#### III. Glimpse into the future of Scala [[Dotty compiler](https://dotty.epfl.ch/)] 
 
&nbsp;  

**Entry Recommendations**: Java, Object Oriented Programming & basics of Web Development.



**Process during (possible) remote studying:**
All lectures & labs are online via [meet.google.com](https://meet.google.com/).

###### Lectures: ######
* All students have cameras & mics disabled
* All questions are asked via chat-box
* After online session slides from lectures will be available in SKOS

###### Labs: ######

* The only way to gain points is to send the code to email (michal.kowalczykiewicz@cs.uni.wroc.pl) before the deadline
* Lab hours are optional Q/A sessions"
Design and development of .NET Windows Applications,5,"* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",summer,True,False,"Celem wykładu jest przedstawienie systemu operacyjnego Windows widzianego
oczami programisty z szerokiej perspektywy technologii .NET. Pracownia daje
okazję do zmierzenia się z szeregiem typowych zadań programistycznych w
środowisku Windows.

**Program:**

  1. Omówienie wewnętrznych mechanizmów Windows.
  2. Zapoznanie z interfejsem programowania Win32API.
  3. Omówienie platformy .NET i języka C#
  4. Przegląd biblioteki standardowej platformy .NET, m.in:
    * oprogramowanie interfejsu użytkownika (Windows.Forms, WPF),
    * komunikacja z systemami baz danych (ADO.NET, Linq2SQL, Entity Framework)
    * integracja różnych języków platformy .NET: VB.NET, MSIL."
Seminar: Software Testing,3,"- samodzielny wybór i lektura materiałów,
- przygotowanie i wygłoszenie prezentacji,
- wysłuchanie i zrozumienie wygłoszonych referatów,
- uczestnictwo w dyskusji.",summer,True,False,"Seminarium dotyczy metod, technik, norm, narzędzi testowania.
Oprócz testowania systemów obiektowych (modele, wzorce, narzędzia) ważne będą
również testy akceptacji, pokrycie testami, automatyzacja testów itp.

**Program:**

  1. Wytwarzanie oprogramowania sterowane testami
  2. Testy akceptacji
  3. Automatyczne testowanie interfejsów
  4. Modele testów
  5. Wzorce projektowania testów
  6. Narzędzia testowania
  7. Projektowanie automatyzacji testów
  8. Zgodne z RODO testowanie oprogramowania

****"
Object-oriented programming,6,"* wykład
* prezentacja rozwiązań i live coding
* samodzielna implementacja zadań
* realizacja i prezentacja projektu programistycznego",summer,True,True,"Celem zajęć jest poznanie jednego z najpowszechniej stosowanego paradygmatu programowania: programowania obiektowego. Program obejmuje zarówno przedstawienie podstawowych pojęć takich jak klasa, obiekt, dziedziczenie czy metody wirtualne, jak i praktykę  wykorzystania tych elementów w budowaniu złożonych programów za pomocą wzorców projektowych.

Naukę programowania obiektowego będą wspierać języki obiektowe, zarówno te z tzw. statycznym typowaniem jak i dynamicznym."
Design of database applications,5,"* Pracownia programistyczna
* Wykład",summer,True,False,"Dobrze zaprojektowana aplikacja przetwarzająca i prezentująca dane ma wiele warstw i komponentów o określonych odpowiedzialnościach. Celem wykładu jest zaprezentowanie, jak dobrze taki typ aplikacji zaprojektować i oprogramować.
Podczas wykładów oraz towarzyszących im pracowni będziemy poznawać i budować kolejne elementy rozwiązania, aby ostatecznie otrzymać kompletny, działający system.

**Program**

Składa się z dwóch głównych części

**Część 1: DBMS**

  1. Podstawy Microsoft SQL Server
  2. Język SQL
  3. Programowanie w T-SQL
  4. Kursory, wyzwalacze, funkcje i procedury
  5. Transakcje i blokady
  6. Optymalizacja w tym normalizacja, indeksy i plany wykonania
  7. Przegląd wybranych baz danych typu NoSQL

**Część 2: System informatyczny**

  1. Podstawy uruchomienia rozwiązania w chmurze
  2. Architektura Microservices, podstawy konteneryzacji
  3. Architektury aplikacji z bazą danych
  4. Przegląd Domain-Driven Design
  5. Wzorce CQRS i Event Sourcing
  6. Podstawy testowania
  7. Wzorzec repozytorium, w tym narzędzia ORM i LINQ
  8. Walidacja danych
  9. Modele danych i automapper
  10. Prezentacja danych, w tym
      - sposoby prezentacji informacji
      - stronicowanie, sortowanie, filtry
      - wzorzec specyfikacji
  11. Integracja systemów, w tym
      - wzorce integracyjne
      - usługi danych, protokół OData
      - API management
      - podstawy federacji tożsamości
  12. Skalowalność rozwiązań, 
  13. Zarządzanie transakcjami, transakcje rozproszone
  14. Podstawy analizy danych i raportowania

**Wymagania:** Umiejętność programowania na dowolnej platformie
programistycznej oraz znajomość materiału z kursu WWW"
Advanced Data Mining,6,"samodzielne czytanie literatury, prezentacja, dyskusja",summer,True,False,"_**UWAGA**: W przypadku takiej konieczności, w roku akademickim 2020/21 zajęcia mogą być prowadzone zdalnie: wykłady będą prowadzone online przez Google Meet lub podobne narzędzie interaktywnej komunikacji, a pracownie będą miały formę indywidualnych spotkań online._

Celem przedmiotu jest zapoznanie słuchaczy z zaawansowanymi algorytmami eksploracji danych, dotyczącymi głównie systemów rekomendujących, redukcji wymiarowości, eksploracji danych temporalnych i systemów wspomagania decyzji. Zajęcia pomocnicze skupiają się na rozwiązywaniu przykładowych problemów świata rzeczywistego za pomocą zaawansowanych algorytmów eksploracji danych.

Ogólny program zajęć:
1. Zaawansowane zagadnienia eksploracji danych.
2. Dane sekwencyjne i temporalne. Wielowymiarowe szeregi czasowe. Prognozowanie metodami stochastycznymi i uczenia maszynowego. Grupowanie i klasyfikacja szeregów czasowych, danych temporalnych i sekwencyjnych. Wzorce charakterystyczne w szeregach czasowych.
3. Systemy rekomendujące. Collaborative Filtering i jego rozszerzenia. Faktoryzacja macierzy i jej rozszerzenia. Grupowanie produktów i użytkowników w systemach rekomendujących. Praktyczne problemy systemów rekomendujących: dokładność (ang. accuracy), pokrycie (ang. coverage), różnorodność (ang. diversity), nowość (ang. novelty) i inne miary oceny systemów rekomendujących.
4. Redukcja wymiarowości. Liniowa redukcja wymiarowości przestrzeni danych. Nieliniowa redukcja wymiarowości przestrzeni danych (w tym przekształcenia kernelowe). Zanurzenia sąsiedztw punktów danych (podejścia deterministyczne i probabilistyczne). Ekstrakcja cech charakterystycznych danych.
5. Eksploracja danych złożonych i nieustrukturalizowanych. Dane geoprzestrzenne. Trajektorie ruchu GPS.
5. Systemy wspomagania decyzji. Wybrane zastosowania zaawansowanej eksploracji danych.

This lecture focuses on advanced data mining algorithms for processing big, complex and unstructured data. It mainly concerns recommendation systems, dimensionality reduction with neighborhood embedding, temporal data mining and decision support systems. In recommendation systems, various approaches from simple collaborative filtering to advanced matrix factorization are presented and discussed in the context of their practical relevance, concerning not only the popular MSE or MAE measures, but also the coverage, diversity, and novelty of recommendations. In temporal data mining, beside the analysis of regular time series with machine learning methods, such as Support Vector Regression and Neural Networks, unstructured temporal data are studied. Additional topics may concern unstructured datasets, such as irregular multidimensional time series, GPS tracks or medical images."
Ethics for the thinking,5,"Wykład, dyskusja",summer,True,False,"Na co dzień etyka nie jest ci potrzebna. Wiesz co robić. Ale czasem sprawy się komplikują…
- w twojej pracy leży laptop. Nikt go nie używa, nikt się nim nawet nie interesuje. Gdybyś go wziął, nikt by się nawet nie zorientował. Przydałby ci się taki laptop…
- spotykasz się z dziewczyną. Wiesz, że nigdy nie zwiążesz się z nią na poważnie, choć ona bardzo na to liczy. Powiedzieć jej o tym? Po co – jej bliskość jest ci tak przyjemna. A może, co gorsze, przydarzyła wam się „wpadka”? Na szczęście jest pewne proste rozwiązanie. Ale czy faktycznie jest ono tak proste, jak weekendowy wyjazd do Austrii lub Holandii?
- zostać w tym kraju czy wyjechać na stałe? Choć masz stąd tożsamość, wykształcenie i miłe obyczaje świąteczne, to jednak tkwienie w tym całym bałaganie... Co prawda mógłbyś zostać i próbować zmieniać swoje najbliższe otoczenie, mógłbyś swoją wiedzą pomnażać dobrobyt  jego mieszkańców, ale z drugiej strony wyjeżdżasz i masz święty spokój, no i te zarobki…

W tego typu sytuacjach zaczynasz się zastanawiać na tym co jest dobre, a co złe, co jest słuszne a co niewłaściwe, co jest powinne a co przeciwpowinne, co jest twoim obowiązkiem, a czego nie wolno ci robić, co jest godne zasługi, a co godne potępienia. Im dłużej się jednak zastanawiasz, tym bardziej zdajesz sobie sprawy z tego, że tak naprawdę nie rozumiesz znaczenia tych pojęć. Wartość, obowiązek, cnota, honor, dobro, powinność, szczęście  – wszystkie te pojęcia są jakoś związane z moralnością, ale czym się od siebie różnią? Co oznaczają?

Ten kurs daje ci możliwość zapoznanie się z podstawowymi sposobami odpowiedzi na pytanie o sens pojęć moralnych. Tok myśli będzie prowadzony w porządku historycznym, zaczniemy od Sokratesa i Platona, a skończymy na współczesnej fenomenologii. Nie zniechęcaj się jednak, bo w etyce, jak w całej filozofii, stare nie oznacza przestarzałe. Dawne koncepcje są laboratorium współczesnego myśliciela. Tak więc poprzez dzieje refleksji etycznej będziemy starali się o analizę podstawowych pojęć moralnych. 

Bądź jednak świadomy, że odbycie tego kursu nie sprawi, że rozstrzyganie twoich problemów moralnych stanie się łatwe. Choć będziesz bardziej świadomy czym jest obowiązek, ale wciąż będziesz musiał sam ustalać, co jest twoim obowiązkiem w tej konkretnej chwili. Będziesz wiedział czym jest wartość, ale sam będziesz musiał rozstrzygać, za którą z dwóch opcji dylematu moralnego kryje się wyższa wartość. Jaka więc korzyść z tego kursu? Subtelniejszy język do przemyśleń moralnych i budowy własnego światopoglądu, większa samoświadomość w sytuacjach granicznych. To już chyba coś?


**Przedmiot będzie prowadzony przez dr. Marcina Drofiszyna z Katedry Logiki i Metodologii Nauk.**"
Warsztaty: Jak założyć firmę?,3,,summer,True,False,"Zajęcia będą miały formę warsztatów. Uczestnicy będą proszeni o opracowanie (w
formie krótkiego referatu będącego wprowadzeniem do dyskusji) jednego z
tematów lub “case study” i udział w dyskusji. Przewiduję udział “anioła
biznesu”, założycieli start-upów, szefów małych firm, osób, którym się nie
bardzo udało (sprzedali start-upy), osób, które rozpędziły kulejące małe
firmy.

Tematy do dyskusji:

Co oferować: tanie usługi, unikalne usługi czy produkt.

Cel strategiczny: sprzedać firmę po zbudowaniu marki, czy budować z myślą o
trwałej niezależnej firmie.

Jaki produkt: istniejący niezależnie, czy po zbudowaniu włączony do większego
systemu.

Jak znaleźć niszę?

Jak ocenić wielkość rynku?

Czy myśleć o rynku lokalnym (Polska), czy globalnym?

Jak poszukiwać partnerów i klientów.

Finansowanie: gdzie są pieniądze? (prywatne i publiczne, granty dla start-
upów).

Przykłady udanych startupów (w Polsce i za granicą)?

Na ogół się nie udaje, co wtedy?

Firma rodzinna (koleżeńska), czy zatrudniająca liderów spoza grona znajomych?

Zrobimy to sami, czy kupimy usługę?

Czy zaczynać zaraz po studiach (lub jeszcze w takcie), czy zdobyć wcześniej
doświadczenie w korporacji?

Ile informatyki w produkcie (usłudze)?

Czy korzystać z usług księgowych, prawników, pijarowców? Gdzie ich szukać?

Czy nawiązywać kontakty z sieciami społecznymi start-upowców."
Formal Languages and Computational Complexity,9,Wykład i ćwiczenia,summer,True,False,"Program przedmiotu obejmuje zagadnienia związane z teorią językow formalnych
(wykłady A1 - A8) w zakresie istotnym z punktu widzenia wykształcenia
informatycznego, a także dostatecznym dla stworzenia zasobow naturalnych
przykładow dla części B i C. Następnie przechodzi się do zagadnień związanych
z pojęciami rozstrzygalności i nierozstrzygalności (wykłady R1 -- R8).
Ostatnia część kursu poświęcona jest wybranym, elementarnym zagadnieniom
złożoności obliczeniowej."
Introduction to databases,6,"Wykład, wykład interaktywny, samodzielne rozwiązywanie zadań, dyskusja, rozwiązywanie zadań z komentowaniem, ćwiczenia warsztatowe, samodzielny projekt programistyczny",summer,True,False,"Celem wykładu jest omówienie zasad konstrukcji relacyjnych baz danych oraz
opanowanie przez słuchaczy umiejętności profesjonalnej obsługi systemu baz
danych od strony użytkownika, czyli:

  * umiejętności projektowania i tworzenia relacyjnych baz danych dla rzeczywistych zagadnień;
  * sprawnego wyszukiwania i odzyskiwania informacji z baz danych przy pomocy języków SQL.
  * pisania aplikacji z dostępem do baz danych;
  * efektywnego wykorzystania dodatkowych możliwości systemu (perspektyw, transakcji, więzów, itp.).

Ponadto wykład pozwala słuchaczom poznać elementy systemów baz danych spoza
warstwy użytkownika (system nadzoru transakcji, zapewnienia bezpieczeństwa i
optymalizacji) oraz zapoznać się z innymi koncepcjami baz danych
wykraczającymi poza standard relacyjny (np. grafowe bazy danych, elementy
rozproszonych baz danych).

**Program wykładu:**

  1. Podstawowe pojęcia baz danych i modelowanie konceptualne.
  2. Relacyjne bazy danych. Języki opisu danych i języki zapytań. SQL.
  3. Elementy aktywnych baz danych (więzy integralności, wyzwalacze).
  4. Elementy systemów baz danych (transakcje, bezpieczeństwo i autoryzacja danych, połączenie relacyjnych języków zapytań z językami macierzystymi).
  5. Teoria relacyjnych baz danych (zależności funkcyjne, normalizacja i denormalizacja).
  6. Metody pisania aplikacji z dostępem do baz danych.
  7. Inne modele baz danych (m.in. bazy grafowe, przetwarzanie dużych danych).

**Program ćwiczeń i pracowni:**

  1. Zajęcia konwersatoryjne pomagające w praktycznym opanowaniu projektowania relacyjnych baz danych.
  2. Opanowanie zapytań w językach SQL.
  3. Zajęcia laboratoryjne pozwalające zapoznać się z systemami zarządzania bazami danych (PostgreSQL itp.).
  4. Wykonanie kompletnego projektu niewielkiej bazy danych.

**Wymagania:** Podstawowa znajomość logiki nabyta np. na Logice dla
informatyków lub Wstępie do matematyki; Podstawowa znajomość algorytmiki, np.
Algorytmy i struktury danych (L); Umiejętność programowania wystarczająca do
napisania aplikacji."
Curves and Surfaces in Computer Graphics,6,"* wykład,
* wykład interaktywny,
* ćwiczenia audytoryjne,
* pracownia programistyczna,
* projekt programistyczny.",summer,True,False,"Krzywe i powierzchnie to podstawowe obiekty grafiki komputerowej. To właśnie przy ich pomocy można modelować skomplikowane kształty i sceny, którym nadaje się później cechy realistyczne i wykorzystuje na przykład w tak modnej ostatnio animacji komputerowej.

Głównym celem wykładu jest przedstawienie podstawowych wiadomości na temat narzędzi pozwalających efektywnie reprezentować i modelować krzywe oraz powierzchnie różnego typu i wygładzać przy ich pomocy dane. Szczególny nacisk położony będzie na omówienie odpowiednich technik i algorytmów z tym związanych, które pozwolą uczestnikom zajęć przygotować własny edytor krzywych lub powierzchni.

  
**Wymagania**

* analiza numeryczna (L lub M),
* umiejętność programowania.

**Program**

1\. Podstawowe pojęcia (działania na punktach i wektorach, kombinacja barycentryczna punktów, otoczka wypukła, długość łuku krzywej, krzywizna).

2\. Reprezentacja krzywych. Krzywe interpolacyjne. Krzywe Béziera. Krzywe sklejane. Krzywe wygładzające.

3\. Reprezentacja powierzchni. Powierzchnie interpolacyjne Lagrange'a. Prostokątne i trójkątne płaty Béziera i ich gładkie łączenie. Powierzchnie sklejane. Powierzchnie wygładzające. Powierzchnie Coonsa i Gordona.

**Literatura**

  * P. Dierckx, _Curve and Surface Fitting with Splines_ , Clarendon Press, Oxford 1993.
  * G. Farin, _Curves and Surfaces for CAGD. A Practical Guide_ , Morgan-Kaufmann, 2002.
  * J. Hoschek, D. Lasser, _Fundamentals of Computer Aided Geometric Design_ , AK Peters, Wellesley (Ma) 1993.
  * J. F. Hughes, A. van Dam, M. McGuire, D. F. Sklar, J. D. Foley, S. K. Feiner, K. Akeley, _Computer Graphics. Principles and Practice_ , Addison-Wesley, 2013.
  * P. Kiciak, _Podstawy modelowania krzywych i powierzchni_ , WNT, Warszawa 2019."
Linux system administration,5,"* Wykład
* Pracownia komputerowa, w tym prezentacja rozwiązań zadań przy komputerze",summer,True,False,"Celem kursu jest rozwinięcie u uczestników praktycznych umiejętności
zarządzania systemem Linux na komputerze osobistym lub serwerze. Zostaną
przedstawione podstawowe informacje na temat budowy i sposobu działania
systemów uniksopodobnych, a szczególnie różnych dystrybucji Linuksa. Zajęcia
są adresowane do wszystkich studentów, którzy chcieliby sprawnie korzystać na
co dzień z systemów linuksowych i którzy są zdania, że to użytkownik powinien
mieć władzę na komputerem, a nie komputer nad użytkownikiem. Mimo że
osiągnięcie tego celu wymaga sporego zaangażowania, wiedzy i praktycznych
umiejętności, nie zakłada się wstępnego doświadczenia słuchaczy w zakresie
administrowania Linuksem. Wystarczy wola odłączenia myszy i chęć pracy z
terminalem tekstowym.

### ORIENTACYJNY SPIS ZAGADNIEŃ PORUSZANYCH NA ZAJĘCIACH

#### I. WSTĘP: ŻYCIE Z LINUKSEM

  1. Hardware i software. Budowa komputera i struktura oprogramowania podstawowego. Jądro i przestrzeń użytkownika. Proces rozruchu komputera. Instalacja systemu i rozpoczęcie pracy z Linuksem.
  2. Terminal tekstowy. Powłoka systemowa. Podstawowe polecenia. Uruchamianie programów, standardowe strumienie wejściowe i wyjściowe, potoki. Uruchamianie i zatrzymywanie procesów. Zarządzanie plikami, prawa dostępu, kopiowanie, archiwizowanie. Edytory tekstu. Przetwarzanie plików tekstowych.
  3. Użytkownik root. Hasła. Su i sudo.

#### II. ZAGADNIENIA SZCZEGÓŁOWE

  1. Hardware i jego diagnostyka, lshw, lsusb, lspci, dmidecode, i2c-tools i in. Urządzenia. Sysfs i udev. Udevd i udevadm.
  2. Dyski. Protokoły SCSI i ATA. USB Storage. Hdparm i smartmontools.
  3. Partycje. MBR i GPT. Narzędzia do partycjonowania dysków, fdisk, parted.
  4. Urządzenia blokowe, device mapper, losetup, dm-crypt, LVM.
  5. Systemy plików. Budowa systemu plików, inode. Księgowanie. Systemy ext2, ext3 i ext4. Tworzenie i zarządzanie systemami plików. Diagnostyka systemów plików, fsck. Montowanie, mount, /etc/fstab itp. Dowiązania, pliki specjalne. FAT i NTFS. Filesystem in userspace. Systemy plików btrfs, ufs, zfs, ffs i in. Szczególne wymagania dysków SSD, discard i fstrim. Linux Directory Structure, katalogi /etc, /usr, /var, /tmp, /boot i ich przeznaczenie.
  6. Przestrzeń wymiany w osobnej partycji i w pliku. Przestrzeń wymiany w pamięci RAM, zram, zswap.
  7. Rozruch komputera. Firmware, Legacy BIOS i UEFI. Konfiguracja, efibootmgr. Inne (Coreboot, Libreboot, U-Boot). Bootloadery drugiego poziomu. GNU Grub 2 i jego konfiguracja. Informacja o Legacy GRUB. Inne popularne bootloadery, Syslinux, LILO, systemd-boot (Gummiboot). Konfiguracja wielosystemowa z BIOS i UEFI, współżycie z systemem MS Windows, rEFInd. PXE i rozruch poprzez sieć komputerową. BOOTP i TFTP. Plymuth i estetyka rozruchu.
  8. Start jądra. Tworzenie i konfigurowanie initramfs. Uruchamianie awaryjne i tryb pojedynczego użytkownika. Moduły jądra, modprobe, lsmod, rmmod, /etc/modules.
  9. Konfiguracja systemu. Katalog /etc i jego struktura.
  10. Uruchamianie przestrzeni użytkownika. System V Init. Proces init, inittab, init.d i rc?.d, runlevels, telinit, update-rc.d, insserv, run-parts. Informacja o Upstart.
  11. Systemd i jego konfiguracja. Filozofia działania systemd. Organizacja i składnia plików konfiguracyjnych. Demony systemd. Jednostki systemd. Cele i metody ich osiągania. Serwisy i inne jednostki.
  12. Zarządzanie użytkownikami. Logowanie do systemu, getty i login. Konsola zdalna i minicom. Hasła, passwd i shadow. PAM. Własność procesów, suid.
  13. Dziennik systemowy, rsyslog, logger, /var/log, journalctl i dmesg. Zdalny zapis dziennika. Protokół SMTP i narzędzia do korzystania z niego.
  14. Synchronizacja czasu, NTP, ntpd, ntpdate, open-ntp, chrony, systemd-timesyncd.
  15. Planowanie wykonania procesów, procesy wsadowe. Cron, crontab, anacron, systemd-timer. Polecenie at.
  16. Zarządzanie procesami i ich diagnostyka, ps, lsof, strace, ltrace. Wysyłanie sygnałów do procesów, kill, killall, nohup. Wątki. Pomiar czasu procesora, obciążenia, zużycia pamięci i operacji wejścia/wyjścia (top, times, vmstat, iostat, iotop, pidstat itp). Priorytety procesów, nice. Komunikacja międzyprocesowa. Gniazda. Dbus. Komunikacja między użytkownikami, wall.
  17. Biblioteki współdzielone, /lib, /usr/lib, ldd, ldconfig, /etc/ld.so.conf, LD_LIBRARY_PATH.
  18. Repozytoria pakietów i dystrybucje Linuksa. Debian, Ubuntu i pakiety deb. Konfigurowanie apt i aptitude. RHEL, Fedora, Centos i rpm. Arch Linux i pacman. Dystrybucje specjalizowane, Kali Linux, Tails i in. Krzyżowanie dystrybucji. Linux from scratch.
  19. Efektywna praca w trybie tekstowym. Powłoki bash (sh, dash, ash), c-shell (csh, tcsh), zsh. Biblioteka readline. Terminal, terminfo, termcap. Screen i tmux. Konfiguracja iterpretera powłoki. Tekst zachęty, Powershell. Lokalizacja i internacjonalizacja, locale, tzdata, kodowanie znaków.
  20. Skrypty powłoki. Narzędzia sed, awk. Polecenia użytkowe wc, tr, sort, head, tail, tee, xargs, grep, find, locate i wiele innych.
  21. Separacja procesów, namespaces, cgroups. Piaskownice, firejail i in. Apparmor. Selinux.
  22. Wirtualizacja. LXC i docker. Qemu i KVM. Xen. Informacja o programie Virtualbox.
  23. Sieci komputerowe i podstawowa konfiguracja sieci w Linuksie. Podstawowe polecenia konfiguracyjne. Konfiguracja statyczna i dynamiczna. DHCP. Gniazda. Bezpieczeństwo i iptables. Usługi sieciowe, sshd, inetd i xinetd. Gniazda systemd. RPC. Usługi nazw, bind9.
  24. Usługi drukowania, lpr i Cups.
  25. Informacja o trybie graficznym (gdyby kiedyś był potrzebny). Serwer wyświetlania X Windows, xinit, startx. Graficzny zarządca logowania (xdm, gdm, sddm, lightdm i in). Zarządca okien (kwin, Metacity, xfwm, Openbox i wiele in). Typy zarządców okien (tiling, stacking, compositing, dynamic). Środowisko graficzne (KDE, Gnome, XFCE i wiele innych). XTerminale (xterm, urxvt, konsole, terminal i in). Niedoskonałości serwera X Windows. Weyland. Zdalny terminal graficzny (xpra, xephyr, xnest, RDP, Winswitch, vnc, x2go, NX tech i in.)
  26. Oprogramowanie Open Source. FSF. Typy licencji. GNU i BSD.

Zakres materiału obejmuje większość zagadnień wymaganych na egzaminach
certyfikacyjnych CompTIA Linux+ (LX0-103 i LX0-104) oraz LPIC-1 (LPI 101 i LPI
102 — Certified Linux Administrator).

### LITERATURA

1. Brian Ward, _Jak działa Linux. Podręcznik administratora_, wydanie II,
   Helion 2015.
2. Evi Nemeth, Garth Snyder, Trent R. Hein, Ben Whaley, Dan Mackin,
   _Unix i Linux. Przewodnik administratora systemów_, wydanie V,
   Helion 2018."
Probability and Statistics,6,"* Wykład
* Rozwiązywanie zadań z komentowaniem
* Indywidualne rozwiązywanie zadań
* Samodzielna praca przy komputerze",summer,True,False,"**Program:**

  1. Pojęcie prawdopodobieństwa, przestrzeń zdarzeń, pojęcie zmiennej losowej, jej rozkład i charakteryzacja.
  2. Zmienne losowe dyskretne (rozkłady: Bernoulliego, geometryczny, Poissona, hipergeometryczny).
  3. Zmienne losowe ciągłe (rozkłady: jednostajny, wykładniczy, gamma, normalny, beta, Weibulla). Charakterystyki zmiennych losowych - momenty.
  4. Rozkłady zmiennych losowych wielowymiarowych (rozkład dwuwymiarowy, rozkład warunkowy, rozkład brzegowy, niezależność dwóch zmiennych losowych); Macierze kowariancji i korelacji. Wielowymiarowy rozkład normalny i szczególny przypadek dwuwymiarowy(elipsa koncentracji, proste regresji).
  5. Funkcje od dwuwymiarowych zmiennych losowych. Wyznaczanie gęstości i dystrybuanty funkcji zmiennych losowych.
  6. Funkcja charakterystyczna i jej własności. Związek funkcji charakterystycznej z momentami zmiennej.
  7. Populacja i próbka. Rozkłady próbkowe (chi-kwadrat, t-Studenta, F-Snedecora). Centralne twierdzenie graniczne.
  8. Estymacja punktowa i przedziałowa. Testowanie hipotez statystycznych. Weryfikacja zgodności rozkładów.
  9. Regresja liniowa i inne rodzaje regresji.
  10. Różne rodzaje analizy wariancji i związek tejże z regresją.

**Zajęcia odbędą się w formie zdalnej.**

**Wykład**: notatki i nagrania wykładów na stronie przedmiotu w SKOSie oraz spotkania w MS Teams. Notatki w postaci wcześniej przygotowanego tekstu (LaTeX) oraz rękopis powstający w trakcie wykładu.

**Ćwiczenia**: forma stacjonarna, co tydzień listy zadań, deklaracje przed ćwiczeniami.

Zaliczenie: na podstawie deklaracji oraz aktywności w trakcie ćwiczeń. 

Ocena końcowa: punkty z ćwiczeń, zadania dodatkowe z list zadań oraz (rozpoczynając od listy 5-6) dodatkowe zadania obliczeniowe, nie więcej niż 4, nie częściej niż co 2 tygodnie.

**Wymagania:**

Algebra: znajomość podstawowych pojęć algebry liniowej -- przestrzeń liniowa,
przekształcenie liniowe i jego macierz, działania na macierzach.  

Analiza: umiejętność obliczania podstawowych całek, całkowanie przez podstawienie i przez części; całki podwójne.

Analiza numeryczna: aproksymacja średniokwadratowa, całkowanie numeryczne.

**Zalecana literatura (podręczniki)**  
**Gernstenkorn, Śródka** – Kombinatoryka i rachunek prawdopodobieństwa.  
**Majsnerowska** – Wprowadzenie do rachunku prawdopodobieństwa z zadaniami.  
Sobczyk – Statystyka.  
Jakubowski, Sztencel – Wstęp do teorii prawdopodobieństwa."
Computer Architecture for Programmers,8,"Wykład, rozwiązywanie zadań z komentowaniem, indywidualne rozwiązywanie zadań, indywidualna analiza kodu źródłowego i kodu maszynowego, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze.",summer,True,False,"Celem przedmiotu jest wprowadzenie słuchaczy do budowy i zasad działania komputerów z punktu widzenia programisty. Studenci nabędą wiedzy z zakresu programowania niskopoziomowego. Po zakończeniu przedmiotu będą rozumieć:

 * reprezentację programów i danych na dysku i w pamięci komputera,
 * wpływ architektury komputera na wydajność aplikacji,
 * mechanizmy sprzętowe używane do implementacji systemów operacyjnych,
 * jak unikać pisania programów podatnych na ataki.

##### Program

1. Reprezentacja danych
   * reprezentacja danych w pamięci komputera
   * arytmetyka na liczbach binarnych w systemie uzupełnień do dwóch
   * arytmetyka na liczbach zmiennopozycyjnych standardu IEEE754
   * problemy wynikające z ograniczeń reprezentacji maszynowych typów numerycznych
2. Programowanie niskopoziomowe
   * reprezentacja pośrednia programów (kod trójadresowy, graf przepływu sterowania)
   * translacja konstrukcji języka C do asemblera procesorów x86-64 (wyrażenia, instrukcje sterujące, typy rekordowe i tablicowe)
   * konwencja wołania procedur i organizacja stosu wywołań (ABI)
3. Konsolidacja i ładowanie
   * proces kompilacji, konsolidacji i ładowania programów (sekcje, relokacje, układ pamięci)
   * reprezentacja programów – format plików ELF
   * biblioteki i konsolidator dynamiczny (ld.so)
4. Podatności programów na ataki
   * błąd przepełnienia stosu
   * wykorzystywanie podatności (wstrzykiwanie kodu, programowanie zorientowane na powroty)
   * sprzętowe i programowe techniki zapobiegania podatnościom (ASLR, W^X)
5. Pamięć masowa i operacyjna
   * hierarchia pamięci i lokalność dostępów
   * organizacja pamięci operacyjnej (czasu dostępu, protokół DDR)
   * dyski magnetyczne (multi-zone recording, buforowanie)
   * dyski półprzewodnikowe (odśmiecanie bloków)
   * komunikacja procesora z urządzeniami peryferyjnymi (przerwania, MMIO, DMA)
6. Pamięć podręczna
   * organizacja pamięci podręcznej (zbiór, blok, znacznik, bity dodatkowe)
   * polityka wymiany bloków (LRU)
   * polityka zapisu (write-back, write-through)
   * analiza i optymalizacja programów pod kątem lokalności dostępów
7. Translacja adresów i pamięć wirtualna
   * motywacja: zarządzanie pamięcią, izolacja, leniwe sprowadzanie danych 
   * przestrzeń adresowa i mechanizm translacji adresów
   * zbiór roboczy i rezydentny, błąd strony
   * hierarchiczna reprezentacja tablicy stron
   * przyspieszanie procesu translacji dzięki TLB
   * przełączanie przestrzeni adresowych
   * problemy na styku translacji adresów i pamięci podręcznej (homonimy i synonimy)
8. Wpływ mikroarchitektury procesora na wydajność programów
   * przetwarzanie superskalarne (procesory Out-of-Order, spekulacja)
   * modelowanie obliczeń grafem przepływu danych
   * przewidywanie skoków (BHT i BTAC)

##### Zajęcia

Większość zajęć do przedmiotu będzie prowadzona w postaci ćwiczeń z deklaracjami. Pozostałe to pracownie programistyczne:

 * programowanie w asemblerze x86-64
 * odpluskwianie programów z użyciem [gdb](https://www.gnu.org/software/gdb/)
 * przeprowadzanie ataków na podatne oprogramowanie
 * optymalizacja programów w języku C

##### Zmiana od roku akademickiego 2021/2022

**W związku ze zmianą wymiaru godzinowego, od roku 2021/2022 zmienia się liczba punktów ECTS z 6 do 8.**"
Project: Competitive Artificial Intelligence,4,"- grupowy projekt programistyczny
- prezentacja
- dyskusja, konsultowanie pomysłów",summer,True,False,"W ramach projektu, kilkuosobowe grupy będą programowały boty grające w jedne z istniejących zawodów AI. 

Poszczególne zespoły nie będą działały w odosobnieniu, lecz na regularnych spotkaniach z prowadzącymi oraz pozostałymi uczestnikami przedmiotu będą prezentować postępy prac, dzielić się wątpliwościami i słuchać pomysłów na alternatywne podejścia. Naszym celem jest wprowadzić do kompetytywnej Sztucznej Inteligencji silny element współpracy i wzajemnej nauki jako środka do osiągania lepszych wyników.

Na koniec projektu, oprócz przedstawienia swojego bota, każda z grup przygotuje też krótki raport z historii jej tworzenia oraz opisujący mechanizmy zaimplementowane w finalnej wersji.


Przeglądowe listy interesujących nas wydarzeń (oczywiście będą nas interesowały aktualne edycje):
- https://www.gocoder.one/blog/ai-game-competitions-list
- https://ieee-cog.org/2022/#COMPETITIONS
- https://icga.org/?page_id=3468
- NeurIPS competitions



Bazowym założeniem jest, że powstałe boty zostaną (jesli będzie to możliwe) wysłane na aktualną edycję wybranych zawodów. W programie przewidujemy również aktywne wspieranie organizowanych w trakcie przedmiotu zawodów CodinGame (charakteryzujących się krótkim czasem trwania od momentu ogłoszenia gry).

Zainteresowani będą mieli okazję włączenia się do badań akademickich, co może stanowić podstawę do pracy magisterskiej lub licencjackiej/inżynierskiej.

Współprowadzącym projekt będzie dr Marek Szykuła."
Project: Machine Learning for Temporal Data Mining,4,zespołowy projekt programistyczny z elementami studiów literatury i prac badawczych,summer,True,False,"Celem projektu jest opracowanie/wykorzystanie/rozszerzenie algorytmów uczenia maszynowego związanych z przetwarzaniem danych czasowych (m.in. szeregów czasowych, modeli ze stanami ukrytymi, itp.) i wykorzystanie ich do konstrukcji prototypu systemu dla wybranego problemu/zbioru danych.

**UWAGA:** Projekt jest przeznaczony dla osób posiadających wiedzę z eksploracji danych i uczenia maszynowego (w zakresie potrzebnym do realizacji projektu) oraz umiejętności techniczne w tym zakresie. Część prac może być wykonywana przez osoby z mniejszym doświadczeniem, ale zalecałbym kontakt emailem i ustalenie tego przed zapisaniem się."
Spectral Graph Theory,6,,summer,True,False,"We would explore the field of Spectral Graph Theory by reading and discussing selected fragments of the following book:
http://cs-www.cs.yale.edu/homes/spielman/sagt/sagt.pdf

This advanced semminar will only be organized if we find a strong group of entusiasts, who would agree to take the challenge of reading and presenting 1 or 2 selected fragments of the book.

As an organizer, I would also participate in this effort. Additionally I would try to comment on the contents being presented.

Depending on the set of people who sign in, the presentations may be either in polish or in english.
However, there are no source materials in polish available.  

This seminar can be considered in relation with another one called ""Advanced LP-based algorithmic techniques"". The one that turns out to be more popular in the vote will be organized."
Concurrent programming,3,,,False,False,"_Przedmiot będzie prowadzony w drugiej połowie semestru - pierwsze zajęcia
odbędą się **11 kwietnia**._

Współbieżność pozwala na zorganizowanie programu w formie komponentów, które
są wykonywane niezależnie i komunikują się ze sobą tylko wtedy, kiedy to
konieczne. Współbieżność ma fundamentalne znaczenie dla programów
podlegających interakcji ze swoim środowiskiem, np. agentów, interfejsów GUI,
systemów operacyjnych itd. Obecnie jednak można ją z pożytkiem wykorzystać
praktycznie w każdej aplikacji, ponieważ wysokopoziomowe mechanizmy
programowania współbieżnego pozwalają pisać efektywne programy, wykorzystujące
procesory wielordzeniowe.

Celem zajęć jest zapoznanie studentów ze współczesnymi mechanizmami
programowania współbieżnego (na ile to możliwe w tak krótkim czasie). Będą
przedstawione mechanizmy niskopoziomowe (wątki z pamięcią współdzieloną i
blokadami wewnętrznymi), narzędzia tradycyjne (egzekutory i pule wątków,
zmienne atomowe, kolekcje współbieżne i równoległe). Nacisk będzie położony na
mechanizmy wysokopoziomowe, m.in. programowanie asynchroniczne (Future i
Promise), strumienie reaktywne i model aktorów (z wykorzystaniem platformy
Akka, dostępnej dla języków Scala i Java).

Programy będą pisane w języku Scala. Scala jest współczesnym
wieloparadygmatycznym językiem programowania posadowionym na platformie JVM (a
także .NET). **Z podstawami programowania w języku Scala studenci zostaną
zapoznani na pierwszych wykładach.**  
Najważniejsze cechy języka Scala są przedstawione na stronie:  
[http://](http://docs.scala-lang.org/tour/tour-of-scala.html)[docs.scala-
lang.org/tour/tour-of-scala.html](http://docs.scala-lang.org/tour/tour-of-
scala.html)

Oprócz wymienionych tam cech Scala wspiera niskopoziomowe programowanie
współbieżne za pomocą wątków, ale oferuje wiele mechanizmów na wyższym
poziomie abstrakcji, np. mechanizm aktorów, mechanizm Future, strumienie
reaktywne, kolekcje współbieżne i równoległe, pamięć transakcyjną.

Na zajęciach w pracowni studenci będą pisali proste programy, których tematyka
będzie zsynchronizowana z zagadnieniami, omawianymi na wykładzie.

Wymagana jest podstawowa znajomość programowania funkcyjnego i obiektowego.

Konieczne jest zaliczenie „Metod programowania”, zalecane jest także
„Programowanie funkcyjne”.

"
Seminarium: Klasyka informatyki,3,,,False,False,
Submodular optimization,6,"wykład, czytanie prac naukowych",,False,False,"Wklęsłość i wypukłość funkcji są jednymi z podstawowych  własności, które pozwalają na efektywne znajdowanie ich minimów i maksimów. To dotyczy jednak tylko funkcji o ciągłej domenie, bo kiedy mamy już do czynienia z problemem kombinatorycznym, tj. funkcją o dyskretnych argumentach, to z pojęcia wklęsłości/wypukłości już siłą rzeczy niestety skorzystać nie możemy.

Istnieje jednak pewien analog wklęsłości/wypukłości w świecie funkcji dyskretnych, nazywany submodularnością, który pozwala na zbudowanie całkiem ładnej teorii pozwalającej na optymalizację bardzo nietrywialnych funkcji pochodzących z różnych kontekstów, a których jedynym wpólnym mianownikiem jest wyabstrahowana submodularność. Na dowód tej rożnorodności i potencji pojęcia zajawmy jedynie, że w gruncie rzeczy to dzięki submodularności właśnie jesteśmy w stanie rozwiązać zarówno problem maksymalnego przepływu jak i minimalnego drzewa rozpinającego w czasie wielomianowym.

Nie jest to więc powszechna wiedza, ale optymalizacja submodularna jest jedną z najstarszych dziedzin informatyki teoretycznej. Ostatnie lata tchnęły w tę dziedzinę drugie życie w związku z coraz większymi jej zastosowaniami w uczeniu maszynowym i sztucznej inteligencji. Pozwala to dopełnić piękne rozważania teoretyczne ich efektywną implementacją, co jest bardzo satysfakcjonujące.

Na dowód tego wystarczy spojrzeć, że co roku na ICML, czyli najważniejszej konferencji machine learningowej, pojawia się około 10 prac, które są poświęcone tej tematyce.

Proponowany przedmiot jest adresowany do studentów, którzy chcieliby poznać podstawy tej dziedziny, a być może nawet wykonać mniej lub bardziej śmiały atempt na spróbowanie swoich sił w badaniach, które w swoim założeniu mogłyby się zakończyć publikacją na konferencji takiej jak ICML właśnie."
Seminar on Algorithms 2015,3,,,False,False,"Seminarium poswięcone będzie względnie świeżym osiągnięciom algorytmicznym. W
jego ramach omawiane będą wybrane wyniki zaprezentowane w ostatnich latach na
wiodących konferencjach algorytmicznych. Dla umożliwienia w miarę szerokiego
wyboru tematow, zajęcia te mają dwoch prowadzących: Marcina Bieńkowskiego i
Jarosława Byrkę.

**UWAGA:** Seminarium odbywa się corocznie i można w nim brać udział
wielokrotnie.  

**Wymagania:**

  * Dobra znajomość materiału z Algorytmow i struktur danych.
  * Mile widziane zaliczenie jednego z przedmiotow: algorytmy probabilistyczne, algorytmy aproksymacyjne, algorytmy online, algorytmy grafowe, algorytmy rozproszone.

"
Course on Practical C# Enterprise Software Development,4,,,False,False,"**Course Description:** This course will be provided by Credit Suisse to give
students exposure to real-world software development. The course will consist
of a set of lectures and a large course project in which students will learn
and apply practical skills. The course project will be a financial application
similar to the systems used for pricing and risk calculations in Credit
Suisse. The students will have access to technical leaders at Credit Suisse
through the lectures and tutorials to learn from professionals who are
building business critical applications.

**Recommended Prerequisites:** Familiarity with object oriented programming
and computer science concepts is required for this course. Some exposure to C#
is recommended, but is not required for ambitious students. A useful course to
have taken prior to enrollment is **Windows Programming course**.

**Expected Workload:** The instruction time for this course will be 90 minutes
of lecture and 90 minutes of tutorial per week. We expect students to spend
4-6 hours per week outside instructional time on course work and assignments.

**Event Title & Presenter Description:**

  * **Lecture 1: Course Introduction**  

Introduction to Investment Banking and Enterprise Software:

    * Differences between university / personal project and enterprise software (i.e. why are you taking this course): reliability, performance, scalability, long-term maintainability, documentation & analysis
    * What is an Investment Bank and what does it do? Sales & Trading, Corporate Finance, Research, FO/MO/BO layering
    * What are the basic financial markets and products? Stocks, Bonds, Commodities, and Forex
    * High-level introduction to the kinds of systems: trade capture, market data, risk engines, pricing applications
  * **Lecture 2: Introduction to C#**   

An overview of the C# language:

    * Visual Studio
    * Hello World Console Example : methods, properties, variables, loops, input and output
    * Conventions to follow for readable code
    * Collections & Generics
    * LINQ
    * Extension Methods
    * Lambda Expressions
    * Anonymous Types
    * Default & Named Parameters
    * Dynamic Types

**Assignment:** set up dev environment and write an application to capture
names and addresses and sort them alphabetically.

**Tutorial:** Assignment help: Open office hours for any students to get some
help with Visual Studio or with assignment of the week

  * **Lecture 3: How to model a random stock process**  

Introduce random processes (Brownian motion) and discuss ways to simulate a
simple stock process (log-normal model). Technical depth of this lecture will
be tailored to the audience.

**Assignment:** students use this knowledge to implement a simple stock model
based on some provided code.

**Tutorial:** Assignment help: Help students with understanding the business
facts and/or implementation details of the stock model assignment

  * **Lecture 4: How to price options**  

Discuss what options are and why people might be interested in them. Walk-
through an example of how to compute price and risks for options in a log-
normal model.

**Assignment:** students use this knowledge to implement simple stock pricing
on log-normal model based on some provided code.

**Tutorial:** Assignment help: Help students with understanding the business
facts and/or implementation details of the stock pricing assignment

  * **Lecture 5: Requirements Specification & Analysis **  

This lecture will introduce the course project and the majority of the
requirements. Instead of providing a completely formed specification, the
lecture will explain how users needs are turned into requirements which are
then turned into a specification

Topics:

    * Use case analysis; how to interview users and understand their process needs, and how to understand the difference between what a user says they want and what they actually need
    * What is a requirement? Functional and non-functional requirements
    * Use cases : what these are and how to specify them
    * UML - High Level UML Diagram.
    * Business Requirements Documents : what they are and why they matter 
      * Present a partial BRD for the course project

**Assignment:** The provided BRD is incomplete. The assignment is to fill in
specific sections.

**Tutorial:** Meet the users  & assignment help: Open office hours for
students to get help with the assignment. They will be able to interview the
""users"" for the assignment system to clarify the requirements.

  * **Lecture 6: Networking & Dependency Injection**  

This lecture will be the first of 2 introducing the main technologies that the
students will need to implement their server(s)

    * Dependency Injection 
      * The concept of the pattern and why it's a good idea
      * Implementing DI using Unity
    * Networking 
      * Networking and Web Service Basics 
        * TCP
        * HTTP
        * REST & SOAP
      * ASP.Net Web API
      * Example of creating a web service

**Assignment:** Given the interface for the market data system, write a dummy
client and server using Web API that communicate via a REST web service.

**Tutorial:** Assignment tech help: Tech and debugging help with the week 's
assignment

  * **Lecture 7 Threading**  

This lecture will be the second of 2 introducing the main technologies that
the students will need to implement their server(s)

    * Threading basics: Processes, Threads, Concurrency, etc.
    * .Net Threading Primitives 
      * Lock, Mutex, Semaphore
      * Example of creating a critical section
    * Creating Threads
    * Performance 
      * ThreadPool
      * Locking is bad: Double-Check locking pattern
    * TPL 
      * What is the task parallel library?
      * Example of using it to run jobs in parallel

**Assignment:** Modify last week 's assignment so that the client creates
concurrent connections to the server and the server code is thread-safe

**Tutorial:** Assignment tech help: Tech and debugging help with the week 's
assignment

  * **Lecture 8: Testing and QA**  

This lecture will introduce the concepts of testing and the overall quality
process

Testing

    * Black box testing vs. white box testing
    * Integration tests vs. unit tests
    * Mocking
    * Examples using MSTest and RhinoMocks

Quality

    * How QA and development teams work together
    * Documents / artifacts that developers and QA use to communicate
    * Examples of how to write a test case from a user story

**Assignment:**

    1. Write unit tests for the market data server interface and a mock that allow the tests to pass.
    2. Write test cases for some of the requirements

**Tutorial:** Assignment tech and documentation help: QA and developers on
hand to help the students with the assignment

  * **Lecture 9: GUI Design and HTML5 introduction**  

The lecture will be the first of 2 introducing the concepts that the students
will need to build their front-end applications

    * Wireframing and practical demo using Balsamiq
    * Using wireframes to validate use cases and GUI requirements
    * Introduction to HTML5 
      * The basics of HTML5 and web layout
      * Javascript and AngularJS

**Assignment:** Create wireframes for the UIs for their application

**Tutorial:** Meet the Users: Review wireframes with  ""users"" to ensure the
teams have met the requirements

  * **Lecture 10: HTML5 Design Patterns**  

This lecture will help the students understand how to build loosely-coupled
data-driven UIs in HTML5

    * MVVM and Why Code Behind is a bad thing
    * AngularJS Deep Dive

**Assignment:** create the UIs for the main project

**Tutorial: **UI technical help: Students bring in their UIs for help from
HTML5 experts****

  * **Lecture 11: End-user documentation**  

This lecture will teach the students about the kinds of documentation that
should accompany production software, with examples

    * System and feature documentation
    * Version Release notes
    * Developer and Support Documentation

**Tutorial:** Project Help: Experts available to the students to provide any
help they need to prepare for the final presentations

  * **Lecture 12 & 13: Project Presentations**  

Individual 15 minutes project presentations.

"
Seminar: Computer Systems Architecture,3,,,False,False,"Celem seminarium jest pogłębienie znajomości tematów omawianych na wykładzie
“Architektury Systemów Komputerowych” oraz zapoznanie się zagadnieniami
pobocznymi.

****

Przewiduje się, że student wygłosi prelekcję na jeden z niżej wymienionych
tematów:

  * elementy mikroarchitektury współczesnych procesorów:

    * techniki przewidywania skoków,

    * spekulatywne metody wykonywania instrukcji,

    * integracja translacji adresów z pamięcią podręczną,

    * obsługa przerwań,

    * sprzętowe wątki.

  * modele pamięci w systemach wieloprocesorowych,

  * sprzętowe wsparcie dla wirtualizacji,

  * techniki generowania wydajnego kodu maszynowego,

  * analiza bieżących i historycznych systemów komputerowych i mikroarchitektur,

  * porównanie architektur zestawu instrukcji: CISC, RISC, VLIW,

  * architektura [Mill](http://millcomputing.com/docs/),

  * wydajne techniki symulacji sprzętu, 

  * języki opisu sprzętu i architektury.

****

Dodatkowo student będzie musiał wykonać pracę programistyczną polegającą na:

  * naprawieniu / modyfikacji / rozszerzeniu wybranego symulatora architektury MIPS,

  * implementacji procesora MIPS w języku Verilog / VHDL,

  * zaprogramowaniu symulatora MIPS na poziomie mikroarchitektury, 

  * zbieraniu informacji dot. wykonania programu z użyciem narzędzia [Pin](https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool).

****

W zależności od stopnia skomplikowania pracy studenci będą mogli organizować
się w zespoły.

## Materiały:

  * [Computer Architecture: A Quantitative Approach](http://booksite.elsevier.com/9780123838728/)

  * [Memory Systems: Cache, DRAM, Disks](http://booksite.elsevier.com/9780123797513/)

  * [Modern Processor Design](http://highered.mcgraw-hill.com/sites/0070570647/)

"
przedmiot w wersji roboczej,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",,False,False,"

"
Evolutionary Algorithms,6,"* Projekt programistyczny
* Pracownia programistyczna
* Projekt badawczy
* Wykład",,False,False,"_**UWAGA**: W przypadku takiej konieczności, w roku akademickim 2020/21 zajęcia mogą być prowadzone zdalnie: wykłady będą prowadzone online przez Google Meet lub podobne narzędzie interaktywnej komunikacji, a pracownie będą miały formę indywidualnych spotkań online._

Algorytmy ewolucyjne to część inteligencji obliczeniowej zajmująca się
heurystycznym rozwiązywaniem problemów optymalizacji.  
  
Algorytmy ewolucyjne znajdują zastosowanie w rozwiązywaniu problemów
optymalizacji, dla których nie można użyć algorytmów tradycyjnych (m.in. kiedy
takie algorytmy nie istnieją lub są zbyt kosztowne obliczeniowo, kiedy problem
optymalizacji nie może być zdefiniowany matematycznie, kiedy wystarczające są
rozwiązania przybliżone lub dostatecznie dobre z praktycznego punktu
widzenia).  
  
Przykładami rozważanych problemów optymalizacji są z jednej strony dobrze
znane problemy NP-zupełne (dla których algorytmy ewolucyjne starają się
dostarczyć rozwiązania dostatecznie dobre z punktu widzenia praktycznych
zastosowań), a z drugiej strony rozmaite problemy praktyczne trudne do
sprecyzowania w sposób matematyczny (m.in. takie w których nieznany jest
analityczny wzór funkcji celu, ale znana jest metoda liczenia jej wartości, na
przykład przez wykonanie pewnych symulacji).  
  
Praktyczne problemy optymalizacji rozwiązywane algorytmami ewolucyjnymi
dotyczą systemów ekspertowych, systemów klasyfikacji i rozpoznawania obiektów
czy systemów wspomagania decyzji. Popularne jest stosowanie algorytmów
ewolucyjnych do analizy obrazów, w tym zdjęć satelitarnych i obrazów
medycznych, do analizy danych ekonomicznych i finansowych, zwłaszcza danych
wysokiej i ultra wysokiej częstotliwości, do konstrukcji systemów kontroli
lotów, do konstrukcji sztucznej inteligencji w grach, itp.  
  
Pierwsza część wykładu dotyczyć będzie podstawowych algorytmów ewolucyjnych do
rozwiązywania klasycznego problemu optymalizacji, ich konstrukcji i adaptacji
do konkretnych problemów praktycznych i teoretycznych oraz implementacji.
Druga część wykładu dotyczyć będzie nowoczesnych algorytmów ewolucyjnych
przeznaczonych do rozwiązywania trudniejszych problemów, takich jak
optymalizacja wielomodalna, optymalizacja wielokryterialna i optymalizacja
dynamiczna.  
  
Wykład wymagać będzie podstawowej wiedzy z zakresu rachunku prawdopodobieństwa
i statystyki (na przykład zaliczenie wykładu RPiS). Podczas pracowni wymagana
będzie umiejętność programowania w klasycznych językach programowania (C/C++,
Java, Python), a przydatna może okazać się też umiejętność programowania w
popularnych narzędziach używanych do analizy danych, takich jak Matlab czy
Octave (narzędzi tych będzie można nauczyć się samemu w pierwszych tygodniach
zajęć lub równocześnie uczęszczać na kurs z nowoczesnych języków przetwarzania
danych).  
  
Program wykładu:  
1\. Wprowadzenie do algorytmów ewolucyjnych.  
2\. Podstawowe algorytmy ewolucyjne: algorytmy genetyczne, strategie
ewolucyjne, programowanie genetyczne, programowanie ewolucyjne.  
3\. Zaawansowane algorytmy ewolucyjne odkrywające wiedzę o problemie
optymalizacji.  
4\. Równoległe i rozproszone algorytmy ewolucyjne.  
5\. Algorytmy optymalizacji wielomodalnej.  
6\. Algorytmy optymalizacji wielokryterialnej.  
7\. Algorytmy optymalizacji dynamicznej.  
8\. Wybrane zastosowania algorytmów ewolucyjnych."
Seminar: Efficient Implementation of Algorithms,3,,,False,False,"To nie jest typowe seminarium. Każde spotkanie ma dwie części. Podczas
pierwszej studenci rozwiązują zadania typowe (w większym lub mniejszym
stopniu) dla zawodow programistycznych typu AMPPZ, CERC,… . W drugiej części
dyskutujemy nad metodami ich rozwiązań.

Cel zajęć wybiega daleko poza przygotowania drużyn reprezentujących UWr na
zawodach. Jak pokazuje wieloletnie doświadczenie, zajęcia w zasadniczy sposob
pogłębiają zrozumienie algorytmow,  poprawiają biegłość w programowaniu i
umiejętność rozwiązywania problemow. To są umiejętności chyba najczęściej
sprawdzane obecnie przy rekrutacji przez „topowe firmy"" (Google, Microsoft,…)

    
    
    ''Uwagi: przedmiot przystępny już dla bardziej zaangażowanych studentow 1-go roku''
      
    zalecane Algorytmy i Struktury Danych 
      
    
    

"
Clone: Computing for Computer Scientists,6,"* Wykład interaktywny
* Prezentacja
* Samodzielna praca przy komputerze
* Pracownia programistyczna
* Dyskusja",,False,True,"Celem przedmiotu jest przybliżenie studentom pierwszego roku podstawowych narzędzi do współtworzenia, kompilowania, uruchamiania, publikowania oraz dokumentowania swoich oraz cudzych programów.

Ten kurs jest planowany na 10 godzin wykładu, 10 godzin pracowni oraz 3 punkty ECTS.

Program przedmiotu:

  * Praca w systemie Linux: pliki, procesy, użytkownicy, potoki i strumienie, kompilowanie i uruchamianie programów. 
  * Polecenie ssh oraz podstawy kryptografii.
  * Systemy kontroli wersji na przykładzie systemu git.
  * LaTeX.

Pracownia będzie głównie polegała na samodzielnym zgłębianiu tematów poruszanych na wykładzie. W wielu przypadkach zadania na pracowni będą wymagały od studentów samodzielnego znalezienia rozwiązania w dokumentacji lub
internecie."
Compiler construction,6,,,False,False,"The course covers most of the translation from C (and C++) into native
computer code. This complicated process cannot be understand without theory,
so you have to be good at theory. You also must be good at programming,
because there will be programming exercises. The course is intended for people
who actually like all aspects of computer science. We will be using an
intermediate representation called LLVM. It has the advantage that it is well-
documented, well-designed, and there is good tool support.

"
Seminar: Agile Software Development,3,,,False,False,"Seminarium będzie poświęcone zwinnym technikom wytwarzania oprogramowania oraz
wykorzystania ich w obszarach analizy/zbierania wymagań, projektowania i
modelowania, implementacji, testowania… Punktem wyjściowym będzie oczywiście
""Manifesto for Agile Software Development"" Alistaira Cockburna i Boba Martina,
skąd przejdziemy do zestawu typowych metod i praktyk agile’owych,
[m.in](http://m.in). XP, ATDD, DDD, EventStorming, BDD, Story Mapping, Impact
Mapping, C4, SCRUM, Kanban, zarówno na poziomie małych jak i wielkich
zespołów.

"
Theoretical Foundations of Concurrent Processes,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Z procesami współbieżnymi obecnie informatycy muszą radzić sobie nieustannie,
zarówno w środowiskach zwartych (architektury wielordzeniowe), jak i
rozproszonych (np. protokoły sieciowe). Projektowanie i analiza takich
systemów nie jest łatwym zadaniem. Wykorzystanie istniejących narzędzi do
modelowania i badania własności systemów współbieżnych wymaga znajomości
teorii, na których są one oparte, czyli algebr procesów.  
  
Algebry procesów służą do opisywania i badania zachowania systemów
współbieżnych za pomoca środków algebraicznych. ""Klasyczne"" algebry procesów
to CCS (Calculus of Communicating Systems, R.Milner), CSP (Communicating
Sequential Processes, T.Hoar) i ACP (Algebra of Communicating Processes,
J.A.Bergstra, J.W.Klop).  
  
W trakcie wykładu zostanie przedstawiona algebra mCRL2, będąca rozszerzeniem
ACP o typy danych (w stylu języków programowania funkcyjnego, z funkcjami
wyższego rzędu), czas i multiakcje. Jest ona zaimplementowa w postaci ciągle
rozwijanego pakietu narzędzi mCRL2 (http://www.mcrl2.org/). Będą przedstawione
m.in. etykietowane systemy przejść, bisymulacja, specyfikacja własności
procesów, logika Hennessy’ego-Milnera, μ-rachunek, a także najważniejsze
narzędzia z pakietu mCRL2.

Wymagania:

Metody programowania

Logika dla informatyków

Wskazane zaliczenie programowania fukcyjnego

Literatura:  
1\. Baeten J.C.M., Basten T., Reniers M.A., Process Algebra: Equational
Theories of Communicating Processes, Cambridge University Press, Cambridge
2010.  
2\. Fokkink W.J., Introduction to Process Algebra (2nd ed.), Springer-Verlag,
Berlin 2007.  
3\. Fokkink W.J., Modelling Distributed Systems, Springer-Verlag, Berlin 2007.  
4\. Groot J.F., Mousavi M.R., Modeling and Analysis of Communicating Syatema,
MIT Press, Cambridge, Mass. 2014  
5\. Sangiorgi D., Introduction to Bisimulation and Coinduction, Cambridge
University Press, Cambridge 2012.

"
Mathematical Analysis 2,6,"*Wykład

*Ćwicienia audytoryjne",,False,True,"**Opis przedmiotu:**  
Wykład jest kontynuacją przedmiotu obowiązkowego _Analiza matematyczna_. W
jego ramach zostaną przedstawione: funkcje wielu zmiennych, równania
rózniczkowe, funkcje analityczne.  
  
**Program wykładu:**

  1. Funkcje dwóch zmiennych: granice funkcji, funkcje ciągłe.
  2. Pochodne cząstkowe funkcji, różniczka funkcji, pochodna kierunkowa.
  3. Wzór Taylora. Ekstrema funkcji, zastosowanie ekstremów.
  4. Całki podwójne.
  5. Równania różniczkowe rzędu pierwszego.
  6. Równania różniczkowe drugiego rzędu.
  7. Układy równań różniczkowych.
  8. Funkcje zespolone elementarne.
  9. Pochodna, całka.
  10. Wzór całkowy Cauchy'ego. Szeregi Taylora i Laurenta.
  11. Residua. Zastosowania residuów.

**Wymagania:**  
Analiza matematyczna 1 (z oceną 4, 4+, 5).  
  
**Literatura:**

  * R.Rudnicki, Wykłady z analizy matematycznej, PWN, Warszawa, 2001.
  * M.Gewert, Z.Skoczylas, Analiza matematyczna 2, CiS, Wroclaw, 2000.
  * M.Gewert, Z.Skoczylas, Równania różniczkowe zwyczajne, CiS, Wroclaw, 2000.
  * S.Banach, Rachunek różniczkowy i całkowy,t.1,2. Lwów,1929.
  * P.Romanowski, Szeregi Fouriera, Teoria pola, Funkcje analityczne i specjalne, Przeksztalcenie Laplac'a, Warszawa, 1963.
  * W.Krysicki, L.Włodarski, Analiza matematyczna w zadaniach, I,II, PWN, Warszawa, 2000."
Seminar: The implementation of functional languages,3,prezentacja studencka,,False,False,"W ramach seminarium omowione zostaną klasyczne techniki i rozwiązania stosowane w kompilatorach języków funkcyjnych takich jak Ocaml, SML, Scheme i Haskell, jak również nowe osiągnięcia w dziedzinie implementacji języków funkcyjnych. Wśród omawianych tematów znajdą się:

  * interpretery
  * osadzone języki dziedzinowe (EDSL)
  * ewaluacja częściowa i generowanie kompilatorów
  * kompilacja przez transformacje programów 
  * analiza statyczna i optymalizacja programów
  * generowanie kodu pośredniego
  * maszyny abstrakcyjne 
  * poprawność kompilatorów"
Computer architecture,6,,,False,False,"> _""Każda wystarczająco zaawansowana technologia jest nieodróżnialna od magii.""_ --- Arthur C. Clarke.

Celem wykładu jest przedstawienie studentom organizacji współczesnych maszyn obliczeniowych: procesorów wielordzeniowych, kart graficznych GPGPU, akceleratorów obliczeń (sieci neuronowe, przetwarzanie genomu); oraz środków przechowywania danych: pamięci DRAM i nieulotnej pamięci półprzewodnikowej. 

Zajęcia są skierowane do studentów, którzy czują niedosyt po wykładzie z _Architektur systemów komputerowych_ i _Logiki cyfrowej_, i chcą:
 * zrozumieć po co w procesorze jest aż kilka miliardów tranzystorów,
 * nauczyć się organizować wydajne oprogramowanie korzystające z procesorów wielordzeniowych i GPGPU,
 * dowiedzieć się z czego wynikają algorytmy optymalizacji kodu maszynowego w kompilatorach,
 * poznać kilka ciekawych algorytmów _online_ implementowanych w sprzęcie,
 * zaprojektować własny procesor.

Wykład będzie prowadzony na podstawie materiałów [Onura Mutlu](http://people.inf.ethz.ch/omutlu/) z [ETH Zurich](https://inf.ethz.ch/department/awards-rankings/rankings.html) do wykładów [Digital Design & Computer Architecture](https://safari.ethz.ch/digitaltechnik/spring2021) i [Computer Architecture](https://safari.ethz.ch/architecture/fall2020). 

**Uwagi od wykładowcy:** Będę prowadzić te zajęcia po raz pierwszy. Oznacza to, że będę się douczać, listy zadań będą niedopracowane, a organizacja zajęć będzie momentami pozostawiać wiele do życzenia. W związku z tym planuję nieco luźniejsze tempo pracy niż na pozostałych przedmiotach, które prowadzę.

Jeśli jesteś zainteresowany tematem, to obejrzyj godzinną prezentację [Indistinguishable From Magic: Manufacturing Modern Computer Chips](https://www.youtube.com/watch?v=NGFhc8R_uO4).

##### Tematy wykładów

1. Potokowe przetwarzanie instrukcji.
2. Przetwarzanie przerwań.
3. Wykonanie poza porządkiem programu (out-of-order)
4. Dataflow, wykonywanie spekulacyjne i atak Spectre.
5. Przewidywanie skoków.
6. Organizacja pamięci i atak RowHammer.
7. Kontrolery pamięci i obliczenia w modułach pamięci.
8. Polityki wymiany dla pamięci podręcznych.
9. Procesory graficzne GPU.
10. Prefetching.
11. Systemy wieloprocesorowe.
12. Synchronizacja pamięci podręcznych w SMP.
13. Organizacja sieci między rdzeniami.
14. Pamięci półprzewodnikowe dla dysków SSD.
15. Architektury do wyspecjalizowanych obliczeń."
Software Testing,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład monograficzny",,False,False,"Testowanie jest podstawą procesu tworzenia wysokiej jakości oprogramowania.

Przedmiot zapoznaje studentow z podstawowa wiedzą oraz praktycznymi
umijetnościami dotyczącymi testowania oprogramowania. Studenci poznają proces
testowy, techniki i narzędzia testowania. Uczą sie analizowac podstawę testow
oraz projektowac, implementować, analizować testy.

Zakres wykładu obejmuje wiedzę wymaganą do egzaminu ISTQB: Certifikowany
tester - poziom podstawowy.

Ćwiczenia i pracowania zapoznaja z praktycznymi metodami i automatycznymi
narzędziami testowania wspólcześnie stosowanymi podczas wytwarzania
oprogramowania"
Algorithmic game theory,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Teoria gier jako podejscie do problemow decyzyjnych z niepewnoscia w danych.

Zagadnienia:

  * Gry (cooperative/noncooperative):

  1. strategie
  2. equilibria

  * Mechanizmy decyzyjne:

  1. Z pieniedzmi (np. aukcje)
  2. Bez pieniedzy (np. glosowania)
  3. Sprawiedliwy podzial

  * Podzial kosztow inwestycji pomiedzy uzytkownikow
  * ""price of anarchy"" w kontekscie uzytkowania sieci transportowej

Wyklad bedzie zawieral trudniejsze elementy (zlozonosc znajdowania
equilibirum) ale powinien byc zrozumialy dla lepszych studentow trzeciego roku
studiów licencjackich i wiekszosci studentow drugiego stopnia.

Materialy:

Nisan, Routhgardan, Tardos, Vazirani. Algorithmic game theory.

http://www.cambridge.org/journals/nisan/downloads/Nisan_Non-printable.pdf"
Photorealistic Computer Graphics,6,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład",,False,False,"Niektórzy uważają, że każdy informatyk powinien zaimplementować ray tracer.
Chodź można to oczywiście zrobić w jedno popołudnie to tu mamy cały przedmiot
i semestr na to zadanie i dzięki temu efekt da na pewno dużo więcej
satysfakcji. W ramach przedmiotu na wykładzie przedstawiane są podstawy
teoretyczne, a na pracowni realizujemy implementacje ray tracera od prostego
klasycznego, aż do fizycznie poprawnego opartego o metody Monte Carlo. W
tegorocznej wersji wykładu przy implementacji skupimy się na metodach
renderingu, zaś do przyspieszania ray tracingu będzie można użyć gotowych
rozwiązań jak np. embree.

Celem wykładu jest przedstawienie realistycznych metod syntezy obrazów. Wykład
przedstawia podstawy fizyczne transportu światła, które pozwalają na
wyprowadzenie poprawnych algorytmów obliczających oświetlenie. Opisywane
metody można podzielić na dwa typy: metody Monte Carlo oparte na śledzeniu
promieni i metody radiosity. Głównym tematyem wykładu będą metody Monte Carlo
począwszy od prostego śledzenia ścieżek przez dwukierunkowe śledzenie ścieżek
i metody hybrydowe takie jak mapa fotonów. Pozwoli to na zrozumienie i nabycie
umiejętności wyprowadzania własnych fizycznie poprawnych metod renderingu.
Wykład zawiera także opis metod mapowania obliczonego oświetlenia o wysokim
zakresie dynamicznym do zakresu możliwego do wyświetlenia (algorytmy mapowania
tonów).

**Program:**

  * Metoda śledzenia promieni i algorytmy przyspieszające
  * Podstawy fizyczne transportu światła
  * Metody Monte Carlo
  * Śledzenie promieni i metody Monte Carlo w obliczaniu oświetlenia (path tracing, mapy fotonów, metoda Metroplis,...)
  * Metoda radiosity
  * Obrazy o wysokim zakresie dynamicznym, mapowanie tonów

**Wymagania:** Podstawy grafiki komputerowej, Rachunek prawdopodobieństwa,
Analiza matematyczna

"
Analysis of variance,6,"* Pracownia programistyczna
* Wykład",,False,False,"Wielowymiarowa analiza danych.

  1. Tworzenie macierzy wariancji-kowariancji dla zbioru danych.
  2. PCA -- metoda kierunków głównych. Rzutowanie zbioru obserwacji na podprzestrzeń o mniejszej liczbe wymiarów tak aby zachować jak najwięcej wariancji. W praktyce polega to na obliczeniu wektorów własnych odpowiadających największym wartościom własnym macierzy wariancji-kowariancji.
  3. Opisanie zmiennych i osobników w terminach kierunków głównych. Które zmienne i w jakim stopniu składają się na kierunki główne? Które osobniki i w jakim stopniu składają się na kierunki główne?
  4. CA -- analiza odpowiedniości. Zadanie podobne do PCA, ale dotyczące zmiennych jakościowych. Wartością zmiennej nie są tutaj liczby lecz kategorie (na przykład odpowiedź na pytanie z odpowiedzią A, B lub C).
  5. Tworzenie średniego profilu wiersza i średniego profilu kolumny. Wskazanie na pewną miarę odległości, która wiąże odpowiedzi z testem niezależności chi-kwadrat. Pozostała część bardzo podobna do metody PCA.
  6. MCA -- wielowymiarowa analiza odpowiedniości. Jest to dla przykładu analizowanie wyników ankiet z wieloma pytaniami w formie wyboru z listy.
  7. HCPC -- hierarchizacja osobników na podstawie analizy PCA/MCA. Tworzenie drzewa ilustrującego podział wyjściowego zbioru na kilka grup.

Literatura:

  * Husson, Le, Pages -- Exploratory Multivariate Analysis by Example Using R
  * Greenacre -- Theory and Applications of Correspondence Analysis.
  * Mirkin -- Clustering for Data Mining: A Data Recovery Approach."
Seminar on Computer Graphics 2017,3,,,False,False,"Celem seminarium jest przegląd ciekawszych prac z ostatnich lat dotyczących
szeroko rozumianej grafiki komputerowej. Wymagana jest znajomość tematyki
minimum na poziomie wykładu z podstaw grafiki komputerowej i ciekawość wiedzy,
część prac dotyczy tematyki przetwarzania obrazów. Omawiać będziemy prace z
wiodących konferencji takich jak ACM SIGGRAPH, EUROGRAPHICS.

Uczestnicy seminarium zapoznają się ze stanem bieżących badań w wybranych
tematach i nabędą umiejętność dalszego zgłębiania rozwoju grafiki komputerowej
poprzez śledzenie i czytanie prac z renomowanych konferencji naukowych."
Operating System Principles,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",,False,False,"**Wstęp.** Systemy operacyjne są specyficznym oprogramowaniem. Ich ewolucja
trwa już ponad pół wieku, a poszczególne systemy są użytkowane przez
dziesiątki lat. Na przykład historia jednego z nowszych systemów operacyjnych,
Linuxa, sięga początku lat 90. XX wieku. Współczesne systemy operacyjne to
oprogramowanie liczące miliony wierszy kodu źródłowego. Można używać komputera
(dowolnego: od smartfonu do mainframe'a), korzystać z licznych aplikacji i nie
rozumieć, jak działa oprogramowanie podstawowe. Jednak podobnie jak
posiadaczowi prawa jazdy nie godzi się nie wiedzieć, dlaczego samochód się
toczy (nawet pod górę), studentowi, a zwłaszcza studentowi informatyki, nie
wypada nie rozumieć elementarnych zasad działania systemów operacyjnych.

**Przeglądowy wykład z systemów operacyjnych** (SO) jest oparty na najlepszych
światowych podręcznikach tego przedmiotu (zob. wykaz literatury podany niżej i
powtórzony w załączniku na końcu). Wykład obejmuje: zagadnienia wstępne, w tym
szkic historycznych uwarunkowań w projektowaniu SO, ogólny przegląd struktur
systemów komputerowych, struktury systemów operacyjnych, architekturę i
funkcje jądra SO, planowanie i synchronizowanie procesów (wątków), problemy
zakleszczeń, zarządzanie pamięcią hierarchiczną, organizację dysków, pamięć
wirtualną, systemy plików, przegląd podsystemów wejścia-wyjścia, uwagi o
systemach rozproszonych (jest im poświęcony **osobny wykład** ) oraz
zagadnienia ochrony i bezpieczeństwa ( **osobny wykład** ). Specjalny nacisk
jest kładziony na poprawną, standardową polsko-angielską terminologię
systemów.

Systemy operacyjne rozwiązują zasadnicze problemy efektywnego, wygodnego i
bezpiecznego eksploatowania systemów komputerowych. Ich specjalizowane
realizacje odnajdujemy w postaci systemów baz danych (zob. **inny wykład** )
lub systemów wbudowanych ( **inny wykład** ). Zarządzanie chmurami w Sieci,
maszyny wirtualne i Internet rzeczy też zaliczamy do najnowszych odmian SO.
Natomiast sam interfejs graficzny (GUI) systemów nie jest częścią systemu
operacyjnego, stanowi jego ,,okrycie"" (por. **odrębny wykład** : komunikacja
człowiek-komputer).

Znajomość podstawowych zasad działania systemów operacyjnych jest elementem
ogólnego wykształcenia informatyka. Osoby zaawansowane w problematyce systemów
operacyjnych mogą pogłębiać swoją wiedzę i doświadczenia na **osobnym,
specjalistycznym wykładzie**. ****

**Podręczniki**

1\. Stallings W.: _Systemy operacyjne. Organizacja wewnętrzna i zasady
projektowania._ _Wydanie dziewiąte_. Gliwice, Helion 2018 (podręcznik w
przygotowaniu; bogate materiały pomocnicze w Sieci).

2\. Stallings W.: _Operating Systems Internals and Design Principles. Ninth
Edition_. Pearson Education 2018 (w przygotowaniu).

3\. Tanenbaum A. S., Bos H.: _Systemy operacyjne. Wydanie czwarte_. Gliwice,
Helion 2016.

4\. Silberschatz A., Galvin P. B., Gagne G.: _Podstawy systemów operacyjnych._
_Wydanie siódme_. Warszawa, Wydawnictwa Naukowo-Techniczne 2005.

5\. Silberschatz A., Galvin P. B., Gagne G.: _Operating Systems Concepts.
Ninth Edition._ _International Student Version_. John Wiley  & Sons 2013.

6\. Tanenbaum A. S.: _Strukturalna organizacja systemów komputerowych._
_Wydanie piąte_. Gliwice. Helion 2006

7\. Zasoby Sieci.

W trakcie semestru materiały pomocniczne do wykładu są udostępniane na
odpowiedniej stronie witryny SKOS.

17-05-22, 20-05-04 zpl..IIUWr

___________________________________________________________

Załącznik Nr 5

**OPIS PRZEDMIOTU/MODUŁU KSZTAŁCENIA (SYLABUS)**

1\.

|

Nazwa przedmiotu/modułu w języku polskim

**_Systemy operacyjne. Podstawy_**  
  
---|---  
  
2\.

|

Nazwa przedmiotu/modułu w języku angielskim

_Operating System Principles_  
  
3\.

|

Jednostka prowadząca przedmiot

_Instytut Informatyki_  
  
4\.

|

Kod przedmiotu/modułu  
  
5\.

|

Rodzaj przedmiotu/modułu _(obowiązkowy lub fakultatywny)_

_Gwarantowany_  
  
6\.

|

Kierunek studiów

_Informatyka_  
  
7\.

|

Poziom studiów _(I lub II stopień lub jednolite studia magisterskie)_

_I stopień_  
  
8\.

|

Rok studiów _(jeśli obowiązuje_ )

_2-3 rok (zalecane)_  
  
9\.

|

Semestr _(zimowy lub letni)_

_Zimowy_  
  
10\.

|

Forma zajęć i liczba godzin

_30 godzin wykładu, 30 godzin ćwiczeń-pracowni, egzamin_  
  
11\.

|

Imię, nazwisko, tytuł/stopień naukowy osoby prowadzącej zajęcia

_Zdzisław Płoski, mgr_  
  
12\.

|

Wymagania wstępne w zakresie wiedzy, umiejętności i kompetencji społecznych
dla przedmiotu/modułu

_Podstawowa znajomość architektury sprzętowej komputerów_

_elementarna znajomość któregoś z języków programowania systemów (C lub C++),_

_zamiłowanie do encyklopedycznego porządkowania informacji,_

_dogłębnego pojmowania koncepcji i krytycznej refleksji terminologicznej._  
  
13\.

|

Cele przedmiotu

_Przeglądowy wykład ""Podstawy systemów operacyjnych""_ _przedstawia
elementarne,_

_ugruntowane zagadnienia związane z budową i działaniem systemów
operacyjnych._

_Celem przeglądu jest zapoznanie słuchaczy z podstawowymi koncepcjami i
zasadami_

_działania wieloprogramowego systemu operacyjnego ogólnego przeznaczenia_

_ze szczególnym uwzględnieniem działania jego jądra._

_Poruszane są następujące zagadnienia:_

_1._ _Przegląd systemów komputerowych_

_2._ _Przegląd systemów operacyjnych_

_3._ _Procesy, wątki, problemy synchronizacji_

_4._ _Procesory i wieloprocesory, planowanie przydziału_

_5._ _Hierarchia pamięci, zarządzanie pamięcią główną i masową_

_6._ _Wejście-wyjście i systemy plików_

_7._ _Problemy ochrony i bezpieczeństwa SO_

_8._ _Wirtualizacja, chmury i Internet rzeczy_

_9._ _Ogólne zasady projektowania dużych systemów_

_10._ _Systemy operacyjne w przekroju historycznym_

_11\. Polska i angielska terminologia dziedziny (wskroś wykładu)_  
  
14\.

|

Zakładane efekty kształcenia

|

**_KMSO_01:_** _rozumie zasady działania jądra wieloprogramowego systemu
operacyjnego ze szczególnym uwzględnieniem zarządzania procesami (planowania
procesów) i pamięcią_

|

**_KW_18:_** _zna zasady działania systemów operacyjnych ze szczególnym
uwzględnieniem procesów, współbieżności, planowania zadań i zarządzania
pamięcią_  
  
---|---  
  
**_KMSO_02:_** _zna i docenia problematykę bezpieczeństwa systemów
operacyjnych, potrafi uwzględniać ją w codziennej eksploatacji systemów_

|

**_KW_25:_** _zna podstawowe pojęcia bezpieczeństwa systemów informatycznych,
rozumie ryzyko i odpowiedzialność związane z systemami informatycznymi,
rozumie zagrożenia związane z przestępczością elektroniczną_  
  
**_KMSO_03:_** _umie zainstalować i zestroić (odpowiednio sparametryzować)
typowy system operacyjny komputera osobistego; potrafi instalować niezbędne
oprogramowanie systemowe i użytkowe_

|

**_KU_17:_** _potrafi zainstalować i skonfigurować wybrany system operacyjny
oraz nim administrować, w tym instalować potrzebne oprogramowanie_  
  
**_KMSO_04:_** _zna i rozumie hierarchię pamięci w systemach operacyjnych,
powody jej organizacji i zasady działania; orientuje się w zasadach działania
i korzyściach z użytkowania pamięci wirtualnej, a także w jej ograniczeniach_

|

**_KU_18:_** _: potrafi wyjaśnić na czym polega zarządzanie pamięcią w
systemach operacyjnych, co to jest hierarchia pamięci, co to jest pamięć
wirtualna_  
  
**_KMSO_05:_** _potrafi zrealizować programowo i przetestować proste
scenariusze synchronizacji procesów współbieżnych, rozróżnia i rozumie
mechanizmy synchronizacji procesów i wątków_

|

**_KU_19:_** _opisuje problemy związane z wykonywaniem programów
współbieżnych; rozumie mechanizmy synchronizacji procesów_  
  
****

__

Symbole kierunkowych efektów kształcenia, _np.: K_W01_ _*_ , _K_U05,K_K03_

****  
  
15\.

|

Treści programowe

_● Rys historyczny_

_● Pojęcie systemu operacyjnego, przegląd typów systemów operacyjnych,_

_ewolucja systemów operacyjnych_

_● Struktury systemów komputerowych, pomocne rozwiązania sprzętowe_

_● Struktury systemów operacyjnych_

_● Procesy i wątki_

_● Planowanie przydziału procesora_

_● Synchronizowanie procesów_

_● Zakleszczenia_

_● Zarządzanie zasobami pamięci (hierarchia pamięci, pamięć wirtualna, systemy
plików)_

_● Systemy wejścia-wyjścia_

_● Struktura pamięci masowej_

_● Wzmianka o systemach rozproszonych (_ _osobny wykład_ _)_

_● Zagadnienia ochrony_

_● Problemy bezpieczeństwa_

_● Przykłady konkretnych systemów (_ _opcjonalnie_ _)_  
  
16\.

|

Metody kształcenia

_Wykład, ćwiczenia-pracownia_  
  
17\.

|

Zalecana literatura _(podręczniki)_

1\. Stallings W.: _Systemy operacyjne. Organizacja wewnętrzna i zasady
projektowania_.

Wydanie dziewiąte. Gliwice, Helion 2018 (podręcznik w przygotowaniu;

bogate materiały pomocnicze w Sieci).

2\. Stallings W.: _Operating Systems Internals and Design Principles._ _Ninth
Edition_.

Pearson Education 2018 (w przygotowaniu).

3\. Tanenbaum A. S., Bos H.: _Systemy operacyjne. Wydanie czwarte_.

Gliwice, Helion 2016.

_4._ Silberschatz A., Galvin P. B., Gagne G.: _Podstawy systemów
operacyjnych._

_Wydanie siódme_. Warszawa, Wydawnictwa Naukowo-Techniczne 2005.

_5._ Silberschatz A., Galvin P. B., Gagne G.: _Operating Systems Concepts._
_Ninth Edition._

_International Student Version_. John Wiley  & Sons 2013.

_6._ Tanenbaum A. S.: _Strukturalna organizacja systemów komputerowych._

_Wydanie piąte_. Gliwice. Helion 2006  
  
18\.

|

Forma zaliczenia poszczególnych komponentów przedmiotu/modułu, sposób
sprawdzenia

osiągnięcia zamierzonych efektów kształcenia:

_Wykład: egzamin_

seminarium: -

_Laboratorium: praca końcowa_

_Konwersatorium: interakcyjny dorobek semestralny_

Inne: -  
  
19\.

|

Język wykładowy

_Polski_  
  
20\.

|

Nakład pracy studenta

_Łącznie 60 godzin_  
  
Forma aktywności studenta

_Praca własna offline, czynne uczestniczenie w ćwiczeniach (rozwiązywanie
zadań,_

_udział w dyskutowaniu problemów), samodzielne wykonanie elementów_

_oprogramowania systemowego ze szczególnym uwzględnieniem zaprojektowania,_

_wykonania i udokumentowania eksperymentu z synchronizacji._

|

liczba godzin na zrealizowanie aktywności  
  
Godziny zajęć (wg planu studiów) z nauczycielem:

_\- wykład: 30_

_\- ćwiczenia: 20_

_\- laboratorium: 10_

\- inne: -

|  
  
Praca własna studenta:

_\- przygotowanie do zajęć: tak, 15..25 godzin,_

_\- czytanie wskazanej literatury: tak, 15..30 godzin,_

_\- napisanie raportu z zajęć: tak, 15 godzin,_

_\- przygotowanie do egzaminu: tak, 15..20 godzin_

|  
  
Łączna liczba godzin

_60 (zajęcia na uczelni) + 60..90 (praca własna studenta) = 120..150_

|  
  
Liczba punktów ECTS

_6_

|  
  
|  |  |"
Operating System - tutoring,0,,,False,False,"Na zajęciach prowadzący będzie odpowiadał na pytania dotyczące bieżących list
zadań i tematów pojawiających się na wykładzie ""Systemy Operacyjne"". Oprócz
tego w postaci interaktywnego wykładu będą przedstawiane treści rozszerzone w
zależności od potrzeb i sugestii np.:

  * wybrane elementy systemu Linux (np. initd, nss, pam, proc, udev, lvm)
  * programowanie z użyciem POSIX API,
  * organizacja wewnętrzna jądra FreeBSD (np. zarządzanie procesami, pamięcią, urządzeniami wejścia-wyjścia, bootloader)
  * tematy dodatkowe na podstawie książki ""Modern Operating Systems"", wydanie czwarte, A. Tanenbaum (maszyny wirtualne, bezpieczeństwo, mikrojądra)

"
Seminar on Foundations of Object-Oriented Languages,3,,,False,False,"Seminarium poświęcone będzie semantyce i systemom typow językow zorientowanych
obiektowo. Jego celem jest prezentacja fundamentalnych pojęć dotyczących
obiektowości (m.in.: self, dynamiczne wiązanie metod, klasy, dziedziczenie,
podtypowanie, kowariancja i kontrawariancja, specjalizacja metod) przy użyciu
modeli teoretycznych takich językow, opartych na rachunku lambda, wraz z
odniesieniem do istniejących językow zorientowanych obiektowo takich jak
Simula 67, C++, Smalltalk, Eiffel, Java, Ocaml i Scala.  
  
Literatura:  
  

  1. A Theory of Objects. Martin Abadi and Luca Cardelli. Springer-Verlag, 1996.
  2. Theoretical Aspects of Object-Oriented Programming: Types, Semantics and Language Design. Carl A. Gunter and John C. Mitchell. The MIT Press, 1993.
  3. Foundations of Object-Oriented Languages: Types and Semantics. Kim Bruce. The MIT Press, 2002."
Logic Programming,6,,,False,False,"Logika towarzyszyła komputerom niemal od ich początku jako narzędzie
wyrażające ich własności i umożliwiające dowodzenie tych własności. Idea
użycia logiki jako samodzielnego języka programowania narodziła się nieco
poźniej: w latach siedemdziesiątych XX wieku. Można ją podsumować za pomocą
następujących ,,rownań'':

program = zbior aksjomatow obliczenie = budowanie dowodu wynikania pewnego
twierdzenia z tego zbioru aksjomatow

Pierwszy realizujący tę ideę system automatycznego dowodzenia twierdzeń został
nazwany Prologiem (od Programmation en Logic), od czasu jego powstania wiele
zespołow badawczych pracowało nad uczynieniem z Prologu rzeczywiście
przydatnego języka programowania, ktory umożliwiałby szybkie pisanie
efektywnych aplikacji związanych ze sztuczną inteligencją, badaniami
operacyjnymi, rozpoznawaniem językow naturalnych, translacją, automatycznym
dowodzeniem twierdzeń i bazami danych.

Podczas wykładu zostaną przedstawione teoretyczne podstawy programowania
logicznego (powiemy między innymi o takich zagadnieniach jak operacyjna,
teoriomodelowa i stałopunktowa semantyka programow logicznych), omowimy
rownież Prolog, ze wszystkimi jego cechami wykraczającymi poza ideę czystego
programowania w logice, umożliwiającymi pisanie efektywniejszych programow (w
tej części wykład będzie krotką powtorką i rozszerzeniem materiału uczonego na
Programowaniu oraz Metodach programowania). Sporo uwagi będzie poświęcone
pragmatyce programowania logicznego i jego przykładowym zastosowaniom (ze
szczegolnym uwzględnieniem sztucznej inteligencji).

Omowimy bazujące na Prologu języki Mercury (jedna z najszybszych mutacji
Prologa) oraz Goedel (jeden z wariantow Prologu z typami). Przedstawimy
roznież sposoby łączenia językow logicznych z obiektowymi, funkcjonalnymi,
wspołbieżnymi i imperatywnymi.

Omowimy rownież podstawy programowania z więzami, paradygmatu, ktory z jednej
strony sprawił, że programowanie logiczne zaczęło być używane w aplikacjach
przemysłowych (w dziedzinie badań operacyjnych), a z drugiej daje wielkie
możliwości pisania dużo efektywniejszych rozwiązań ""łamigłowkowych"" zadań, z
ktorymi mieliście do czynienia na pracowni z programowania.

Wykładowi będą towarzyszyć ćwiczenia połączone z pracownią.

**UWAGA** Wykład najprawdopodobniej będzie odbywał się co dwa lata, ostatnia
edycja była w roku akademickim 2005/2006.

**Wymagania:** Programowanie lub Metody programowania, Logika dla informatyk
ow

"
"Modern Platforms for Big Data Analytics, Graphics and Visualisation",2,,,False,False,
Course: Practical C# Enterprise Software Development,4,,,False,False,"**Developing fault-tolerant distributed trading systems**

**Course Description:** This course will be provided by Credit Suisse to give
students exposure to real-world software development of fault-tolerant
distributed trading systems with a web user interface. The course will consist
of a set of lectures and tutorials. Weekly assignments will bring students
ever closer to having the final project complete. The course project will be a
financial application similar to the systems used for pricing and risk
calculations in Credit Suisse. A mock legacy system will be replaced by the
students ' implementation component-by-component. It will be acceptable to use
some of the legacy components in the final project in exchange for a mark
penalty. The students will have access to technical leaders at Credit Suisse
through the lectures and tutorials to learn from professionals who are
building business critical applications.

**Recommended Prerequisites:** Familiarity with object oriented programming
and computer science concepts is required for this course. Some exposure to
Java is recommended, but is not required for ambitious students. Students can
decide to produce the backend in Java or C#, with an understanding that the
lectures will cover only examples of the java implementation. A useful course
to have taken prior to enrollment is the Websites course.



**Expected Workload:** The instruction time for this course will be 90 minutes
of lecture and 90 minutes of tutorial per week. We expect students to spend
4-6 hours per week outside instructional time on course work and assignments.



**Event**

|

**Title & Presenter**

|

**Description**  
  
---|---|---  
  
**Lecture 1**

|

Introduction to Financial Markets



|

Introduction to Investment Banking

*         Time Value of Money

*         Interest Rates

*         Spot vs Term market

*         Spot market interuments

o    Equities

o    Bonds

o    FX

o    Commodities

*         Term market contracts

o    Futures

o    Swaps

o    Options  
  
**Tutorial**

|

Business Analysis

|

*         Introduction to the final project

*         Introduction to Business analysis

*         Lifecycle of a project

*         Eliciting requirements



**Assignment:** Convert business requirements to functional ones in order to
understand what it is that we will be building over the next 12 weeks  
  
**Lecture 2**

|

Zookeeper 1

|

Fault-tolerant distributed systems



**Assignment:** A simple system implementation based on zookeeper using CS-
given code (Market moves, pricing and a collection of trades provided)  
  
**Tutorial**

|

Zookeeper demonstration

|

A walkthrough of a piece of Zookeeper-based code with an explanation of why
all the different mechanisms were used and how they provide fault-tolerance
and high scalability  
  
**Lecture 3**

|

Testing and QA / Behaviour Driven Development

|

This lecture will introduce the concepts of testing and the overall quality
process

Testing

-          Black box testing vs. white box testing

-          Integration tests vs. unit tests

-          Mocking

Quality

-          How QA and development teams work together

-          Documents / artifacts that developers and QA use to communicate

-          Examples of how to write a test case from a user story

Using BDD in practice



**Assignment** :

1\. Write unit tests for some of the components and use mocks to allow the
tests to pass.

2\. Write test cases for some of the requirements  
  
**Tutorial**

|

BDD

|

Further BDD examples, assignment help  
  
**Lecture 4**

|

Zookeeper 2

|

Continuing the explanation of Zookeeper mechanisms and patterns

** **

**Assignment:** students use this knowledge to implement simple stock pricing
on log-normal model based on some provided code.  
  
**Tutorial**

|

Zookeeper demonstration 2

|

Demonstration of a simple worker listening for changes on the zookeeper tree
and reacting to it  
  
**Lecture 5**

|

Recap

|

This slot is to be used for any additional explanation required on any of the
topics  
  
**Tutorial**

|

Recap

|

Open office hours in the lab  
  
**Lecture 6**

|

RESTful WebService & Web Sockets

|

Web services, REST, Web Sockets



**Assignment:** Implement web services for the final project. The system
should now get and send data to all the legacy components (with RESTful
interfaces)  
  
**Tutorial**

|

Assignment tech help

|

Tech and debugging help with the week's assignment  
  
**Lecture 7**

|

HTML5 + ecosystem

Website design

|

HTML5 and ecosystem

Website design, wireframing



**Assignment:** Design the front-end  
  
**Tutorial**

|

Presentation of front-end designs

|

Students to present their designs to a CS graphical designer  
  
**Lecture 8**

|

React.js

|

Front-end development in React.js



**Assignment:**

1)     Write unit tests for the market data server interface and a mock that
allow the tests to pass.

2)     Write test cases for some of the requirements  
  
**Tutorial**

|

Assignment tech and documentation help

|

QA and developers on hand to help the students with the assignment  
  
**Lecture 9**

|

-

|

-  
  
**Tutorial**

|

Recap

|

Open office hours in the lab  
  
**Lecture 10**

|

MongoDB

|

Mongo DB



**Assignment:** Implementing the trade store in MongoDB  
  
**Tutorial**

|

MongoDB lab

|

Using MongoDB to store trades  
  
**Lecture 11**

|

Brownian Motion

|

Introduce the random processes (Brownian motion) and discuss ways to simulate
a simple stock process (log-normal model). Technical depth of this lecture
will be tailored to the audience.



**Assignment:** Replace the legacy market data component with own
implementation  
  
**Tutorial**

|

QS Help

|

Experts from Quantitative Strategies to help with the understanding of
Brownian motion  
  
**Lecture 12**

|

Option Pricing and Risk Calc

|

Discussion on what options are and why people might be interested in them.

Walk-through of an example of how to compute price and risks for options in a
log-normal model. Calculating the PV and risk of options.



**Assignment:** Replace the legacy pricing component with own implementation  
  
**Tutorial**

|

QS Help

|

Experts from Quantitative Strategies to help with the understanding of Option
Pricing  
  




"
Artificial Intelligence for Games: Team projects,4,* Projekt programistyczny,,False,False,"Celem przedmiotu jest praktyczne, pogłębione wykorzystanie wiedzy oraz
umiejętności nabytych na kursie Sztucznej inteligencji w grach. W
szczególności można będzie rozwijać projekt rozpoczęty podczas AI4Games.

W ramach tego przedmiotu realizowane będą projekty grupowe, które, jeśli będą
odpowiednio dobrej jakości, mogą stanowić podstawę do pracy
licencjackiej/inżynierskiej lub magisterskiej.

Proponowane tematy (lista niepełna, część projektów znajduje się już w pewnej
fazie realizacji):

  * proceduralny generator map do gry Heroes of Might and Magic III;
  * generowanie zasad gier szachopodobnych;
  * stworzenie gracza GGP (Stanford's GGP, General Video Game Playing, Simplified Boardgames);
  * bot grający w grę [Dota 2](https://developer.valvesoftware.com/wiki/Dota_Bot_Scripting);
  * bot grający w grę [StarCraft II](https://us.battle.net/forums/en/sc2/topic/20751934997);
  * machine learning w karciankach online (np. Hearthstone, TES:Legends)
  * implementacja agenta na zawody organizowane w ramach konferencji naukowych poświęconych AI, np. GECCO, [CIG](http://cig16.image.ece.ntua.gr/competitions/);
  * wykorzystanie technik proceduralnego generowania zawartości do tworzenia contentu gier (np. generowanie map świata w Cywilizacji VI);
  * inne tematy zaproponowane jako projekty w ramach AI4Games.

Lista projektów jest otwarta.

"
Artificial Intelligence for Games,6,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład",,False,False,"**Artificial Intelligence for Games**

(przedmiot może być prowadzony w języku angielskim na życzenie studentów)

Wykład ma na celu przedstawienie metod sztucznej inteligencji wykorzystywanych
na potrzeby gier. Do tematu podejdziemy z trzech stron: omawiając algorytmy
służące do grania w gry, proceduralnego generowania ich zawartości oraz
wykorzystywane w silnikach gier. Chciałbym zobrazować jak wiele różnorodnych i
skomplikowanych algorytmów znajduje się w przeciętnej grze oraz dać możliwość
ich zaprogramowania korzystając z multimedialnych platform do walk AI.

Oprócz tego znaczna część kursu będzie polegała na omówieniu aktualnie
prowadzonych badań w dziedzinie Artificial Intelligence / Computational
Intelligence in games. Omówimy sobie m.in. metody AI wspomagające tworzenie
gier (głównie oparte na algorytmach ewolucyjnych), ideę i postępy w dziedzinie
General Game Playing oraz algorytm MCTS wykorzystywany m.in. w Google
DeepMind's AlphaGo.

Kurs jest przeznaczony dla osób bezpośrednio zainteresowanych tematyką, a
także chcących pogłębić swoją wiedzę związaną z AI - nie tylko w kontekście
gier; oraz chcących pogłębić swoją wiedzę związaną z programowaniem gier - nie
tylko w kontekście AI. Kurs wymaga dobrej znajomości podstaw Sztucznej
inteligencji oraz umiejętności programistycznych.

Wykonane w ramach kursu projekty, jeśli będą odpowiednio dobrej jakości, mogą
stanowić podstawę do pracy licencjackiej, inżynierskiej lub magisterskiej.

**Struktura kursu:**

Zaliczenie oparte będzie na:

  * kilku małych zadaniach (w pierwszej części semestru); 
  * (prawdopodobnie) drobnym egzaminie połówkowym; 
  * projekcie grupowym (2-3 osoby) wykonywanym w drugiej części semestru;
  * raporcie z projektu zaliczanym do egzaminu. 

Proponowane tematy projektów to:

  * implementacja agenta na zawody organizowane w ramach konferencji naukowych poświęconych AI, np. [CIG](http://cig16.image.ece.ntua.gr/competitions/);
  * wykorzystanie technik proceduralnego generowania zawartości do tworzenia ineteresujących i przydatnych obiektów (najlepiej związanych z grami); 
  * zaprogramowanie ciekawej gry umożliwiającej podpinanie AI stworzonych przez użytkowników; 
  * ... lub też inne zaproponowane przez studentów.

**Literatura:**

  * głównie prace naukowe z dziedziny (udostępniane przez wykładowcę)
  * N. Shaker, J. Togelius, M. J. Nelson, Procedural Content Generation in Games (<http://pcgbook.com/>)
  * I. Millington, J. Funge, Artificial Intelligence for Games (2nd Ed.)
  * M. Buckland, Programming Game AI by Example
  * S. Rabin (ed.), Game AI Pro^2: Collected Wisdom of Game AI Professionals
  * S.J. Russell, P. Norvig, Artificial Intelligence A Modern Approach (3rd Ed.)

**Wstępny program wykładu:**

  * Monte Carlo Tree Search, advanced min-maxing
  * General Game Playing
  * Search-based Procedural Content Generation
  * Grammar-based and constraint-based PCG
  * Game Generation
  * Movement, pathfinding: A* (real-time, dynamic environment), hierarchical pathfinding, crowds movement
  * Decision making: decision trees, automata, fuzzy logic, ...
  * Tactic and Strategy, 
  * NPC behaviour modelling
  * Neuroevolution in games

"
Digitizing the real world,6,,,False,False,"Capturing realistic 3D models of real objects, and humans is of great interest
for many disciplines and industries including video-games, film, architecture,
marketing, and art.

This course will present different methods, hardware, and algorithms for
digitizing geometry, material properties, motion, and lighting, as well as
different ways to represent, edit, and reproduce these inside the computer.
The course will combine the fundamentals of different aspects of digitizing
reality with the presentation of industrial standards and state-of-the-art
research.

  * 3D Scanning, Structure from Motion, Photometric Stereo, Shape from Shading.
  * Reflectance Capture, and Texture mosaicking. 
  * Lighting Capture / HDR Imaging
  * Motion Capture

**References and interesting sites:**

<http://medusa.disneyresearch.com/>

<http://www.gris.informatik.tu-darmstadt.de/projects/multiview-environment/>

<http://www.pauldebevec.com/>

<http://research.microsoft.com/en-us/projects/surfacerecon/>

<http://www.robots.ox.ac.uk/~vgg/hzbook/>

**Requirements**

C/C++. Basic Algebra. Computer Graphics and Image Processing will be useful.

**Note**

Assistance to the Lectures is compulsory.

Evaluation will be through Labs.

"
IT Architecture,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Podczas tworzenia systemów informatycznych, szczególnie dużych, dobra
architektura jest jednym z ważniejszych aspektów, o które należy zadbać.
Dobra, czyli taka, która zapewni realizację wymagań zarówno funkcjonalnych,
jak i nie funkcjonalnych, która umożliwi rozwój i utrzymanie systemu w
granicach akceptowalnych kosztów na przestrzeni lat. Nie bez znaczenia są
także metody pracy, które mogą sprzyjać tworzeniu dobrej architektury, mogą
też to utrudniać. Bardzo popularną w ostatnich latach metodą wspierającą
tworzenie dobrej architektury jest Domain Driven Design i tą właśnie metodyką
zajmiejmy się przez przeważającą część semestru.

W ramach wykładu zostaną poruszone następujące zagadnienia:

  * Introduction to IT Architecture, different roles
  * Architectural styles like REST, Microservices, etc.
  * Requirements management
  * Ways of working: TDD, Agile
  * Domains, Subdomains, and Bounded Contexts
  * Context Maps
  * Architecture
  * Entities and Value Objects
  * Services
  * Domain Events
  * Modules
  * Aggregates
  * Factories
  * Repositories
  * Integrating Bounded Contexts
  * Application
  * Integration patterns and practices
  * Enterprise Architecture and TOGAF

Wykład będzie miał charakter głównie teoretyczny, chociaż niewykluczona jest
również część praktyczna.

**Wymagania**

Biegłość programowania w technologii obiektowej, podstawy baz danych.

**Literatura**

  1. Eric Evans, _Domain-Driven Design: Tackling Complexity in the Heart of Software_ , Prentice Hall, 2003
  2. Vernon Vaughn, _Implementing Domain-Driven Design_ , Addison-Wesley Professional, 2013

"
IT Security in practice,6,,,False,False,"Celem zajęć jest dogłębne zaznajomienie się z różnymi aspektami bezpieczeństwa
komputerowego. Punktem odniesienia będzie certyfikacja CISSP, wszestronna i
najbardziej rozpoznawalna certyfikacja w zakresie bezpieczeństwa
komputerowego. Wykład będzie głównie teoretyczny, niemniej dla każdego
zagadnienia będzie omawiana praktyczna realizacji na przykładzie dużej
korporacji.

W ramach CISSP rozważanych jest 8 następujących obszarów:

  * **Security and Risk Management** (Security, Risk, Compliance, Law, Regulations, and Business Continuity)
  * **Asset Security** (Protecting Security of Assets)
  * **Security Engineering** (Engineering and Management of Security)
  * **Communication and Network Security** (Designing and Protecting Network Security)
  * **Identity and Access Management** (Controlling Access and Managing Identity)
  * **Security Assessment and Testing** (Designing, Performing, and Analyzing Security Testing)
  * **Security Operations** (Foundational Concepts, Investigations, Incident Management, and Disaster Recovery)
  * **Software Development Security** (Understanding, Applying, and Enforcing Software Security)

**Literatura**

  1. _Official (ISC)2 Guide to the CISSP CBK_ , Third Edition, (ISC)2 Press, 2015
  2. Shon Harris, _CISSP All-In-One Exam Guide_ , McGraw-Hill/Osborne Media, 2012

"
Programmers' Team Engineering,3,"* Pracownia programistyczna
* Wykład",,False,False,"Na przedmiocie Inżynieria Oprogramowania oraz podczas wielu wykładów na
obozach ZOSIA prezentowane są techniki i narzędzia, których zespoły
programistyczne używają, by usprawnić swoją pracę. W związku z tym student ma
szansę poznać wiele alternatywnych narzędzi i „metodyk”. Podczas tego kursu
postaramy się uchwycić sens stojący za tymi technikami. Przyjrzymy się
historii wielkich projektów informatycznych, ale również dokonaniom nauk
społecznych i naszym własnym doświadczeniom.

Podczas pracowni spróbujemy poczuć, jakie problemy naturalnie pojawiają się w
zespole programistycznym, i jak można je rozwiązywać za pomocą dostępnej dziś
Inżynierii Zespołu Programistycznego. Zobaczymy jak planować projekt i co z
tych planów potem wychodzi. Zrozumiemy do czego służą wzorce projektowe i jak
popularne języki programowania rozwiązują częste problemy programistów. W tym
celu – przy okazji – studenci będą tworzyć w grupach własne projekty
programistyczne."
Synthesis and Sound Processing,6,,,False,False,"Celem przedmiotu jest zapoznanie studentów z tematyką syntezy i przetwarzanie
dźwięku, w tym m. in.:

\- metody kodowania dźwieku (cyfrowa reprezentacja sygnału dźwiękowego)

\- podstawowe cechy dźwięku (głosność, obwiednia, wysokosc, barwa, faza itp.)
i ich reprezentacja w sygnale

\- synteza addytywna

\- filtry cyfrowe, synteza subtraktywna

\- waveshaping

\- synteza AM i FM

\- echo, pogłos, efekty modulacyjne

\- cyfrowe rezonatory, metoda Karplusa-Stronga

\- pitch shift, frequency shift

\- przetwarzanie spektralne

\- uncontrolled feedback synthesis

\- granulacja

\- języki dedykowane do zastosowań dźwiękowych

\- podstawowa spacjalizacja dźwięku

\- podstawy psychoakustyki

"
Seminar: Information Safety and Security,3,"- samodzielny wybór i lektura materiałów,
- przygotowanie i wygłoszenie prezentacji,
- uczestnictwo w dyskusji.",,False,False,"Seminarium dotyczy praktycznych metod wykrywania niepowołanego dostępu do informacji i zabezpieczania się przed
utratą informacji.

**Program:**

Co najmniej 14 referatów poświęconych następującym zagadnieniom:

- przestępstwa "" komputerowe"",

- sposoby wykrywania włamań i gromadzenie dowodów przestępstw,

- metody zabezpieczania informacji,

- ekspertyzy sądowe z zakresu informatyki,

- zgodne z RODO i innymi standardami wytwarzanie oprogramowania,

- zgodna z RODO i innymi standardami eksploatacja oprogramowania,

- obowiązki Security Officer."
Computational Photography,6,"* Pracownia programistyczna
* Wykład",,False,False,"Computational photography is a relatively new field at the convergence of
photography, computer vision, image processing, and computer graphics. Its
goal is to overcome the limitations of traditional photography using
computational techniques to enhance the way we capture, manipulate, and
interact with visual media. This course covers fundamentals and applications
of hardware and software techniques, with an emphasis on software methods. We
will study many interesting, recent image based algorithms and implement them
to the degree that is possible.

We will cover topics such as

  * Cameras and image formation
  * Image stitching / completion / inpainting
  * Texture synthesis, super-resolution, denoising.
  * Light fields
  * Image based lighting and rendering
  * High dynamic range
  * Intrinsic Images
  * Coded aperture photography
  * Modeling and synthesis using Internet data
  * ... more interesting topics.

**Previous years**

**<http://franchomelendez.com/index.php/computational-photography/>**

**References and sites of interest**

[Computational Photography
Book](http://www.amazon.com/gp/product/1568813139?ie=UTF8&tag=merl-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1568813139
""Computational Photography Book"")

<http://store.elsevier.com/product.jsp?isbn=9780123749147>

<http://web.media.mit.edu/~raskar/photo/>

<http://web.media.mit.edu/~gordonw/CompressiveLightFieldPhotography/>

<http://www.pauldebevec.com/Research/LS/>

<http://www.amazon.com/Color-Imaging-Fundamentals-Erik-Reinhard/dp/1568813449>

"
Computer Vision and Photogrammetry,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",,False,False,"In this course will look at different techniques to acquire 3D models from
images. During the course labs you will implement a 3D reconstruction
pipeline, from 2D images to a 3D geometric model. We will also see some
notions about SLAM and other applications of multi-view geometry.

\- Camera geometry and calibration

\- Feature detection and Matching

\- Stereo and Structure from Motion

\- Shape from Shading and Photometric Stereo

\- Registration, Meshing, and Texturing

Objectives:

\- Get familiar with image processing algorithms and acquire practical
experience.  
\- Understand the concepts of perspective geometry  
\- Get experience with robust computational methods.  
\- Learn about Multi-view geometry, theory and applications.  
\- Implement the most usual tools necessary for multi-view reconstruction.  
\- Understand the full pipeline for 3D reconstruction.

Skills

\- Acquire practice with image processing programming.  
\- Implement and apply linear algebra to a real problem.  
\- Gain knowledge and deep understanding of the photogrammetry and related
problems..

More info:

http://franchomelendez.com/index.php/teaching/computer-vision-and-
photogrammetry/  

"
Seminar: Program certification in Coq,3,,,False,False,"**Overview:**

The Coq proof assistant provides a platform for interactive theorem proving
and for constructing certified programs, i.e., accompanied by a machine-
checked proof that the program satisfies its specification. Such a rigorous
approach to program correctness is crucial when it comes to the verification
of safety-critical software systems used in medicine, nuclear engineering or
transport. It is also an active research direction in compiler verification,
where the goal is to obtain a computer-checked certificate that the compiler
does not introduce bugs.

This seminar is a continuation of the course ""Software foundations in Coq"",
and its main objective is to provide the students with knowledge about program
certification in Coq, and in particular about formalized functional algorithms
and certiied compilers, but also to acquaint them with advanced formalization
techniques of the Coq proof assistant.

**Topics:**

  * weak and strong program specification
  * programming with dependent types
  * verification of functional algorithms and data structures
  * syntax and semantics of programming languages with binders ([POPLmark Challenge](https://www.seas.upenn.edu/~plclub/poplmark/poplmark.pdf))
  * certified compilers, including [CompCert C](http://compcert.inria.fr/compcert-C.html)
  * program extraction from proofs
  * proof by reflection
  * type classes
  * general recursion
  * crafting your own tactics with Ltac

**Prerequisites:**

It is assumed that the student has a basic working knowledge of Coq, logic,
functional programming, and the semantics of programming languages at the
level of [Software
Foundations](http://www.cis.upenn.edu/~bcpierce/sf/current/), taught at the
course Software foundations in Coq.

**Bibliography:**

  * Benjamin C. Pierce. [Software Foundations](http://www.cis.upenn.edu/~bcpierce/sf/current/). 2017.
  * Adam Chlipala. [Certified Programming with Dependent Types](http://adam.chlipala.net/cpdt/). The MIT Press, 2013.
  * Yves Bertot, Pierre Casteran. [Interactive Theorem Proving and Program Development Coq'Art: The Calculus of Inductive Constructions](http://www.cse.chalmers.se/research/group/logic/TypesSS05/resources/coq/CoqArt/). Springer, 2004.
  * Brian E. Aydemir et al., [The POPLmark Challenge](https://www.seas.upenn.edu/~plclub/poplmark/poplmark.pdf), 2005.
  * Xavier Leroy, [Formal Verification of a Realistic Compiler](http://gallium.inria.fr/~xleroy/publi/compcert-CACM.pdf), _Communications of the ACM_ , 52(7):107-115, 2009."
Seminar: IT Security,3,* Wykład,,False,False,"Celem seminarium jest zgłębienie pewnych aspektów szeroko rozumianego
bezpieczeństwa komputerowego zarówno z punktu widzenia teorii, jak i praktyki.
Wśród zagadnień, spośród których będa wybierane tematy do prezentacji są
następujące:

  * Access Control
  * Identity & Access Management
  * Network Security
  * Information Security
  * Risk Management
  * Software Development Security
  * Cryptography
  * Security Architecture and Design
  * Operations Security
  * Business Continuity
  * Disaster Recovery Planning
  * Legal, Regulations, Investigations and Compliance
  * Physical Security
  * Incident Management
  * Malware and Software Attacks
  * Pentesting Applications
  * Pentesting Infrastructure
  * Forensics
  * Auditing

Oczywiście docelowa tematyka zostanie uzgodniona z uczestnikami seminarium.

"
Introduction to Lambda Calculus,6,"Wykład, rozwiązywanie zadań z komentowaniem, indywidualne i grupowe, dyskusja, samodzielne studiowanie literatury",,False,False,"Opis:  
    
    
    Podczas wykładu chciałbym przedstawić rachunek lambda i jego rozwój.
    Wykład powinien być elementarny, choć będzie wykorzystywać język 
    matematyczny, który powinien być znany z wykładu logiki dla informatyków.
    Jego celem jest pokazanie, w jaki sposób kształtowały się pojęcia,
    które dzisiaj są wykorzystywane w różnych językach programowania (np. w Haskelu),
    a także ich precyzyjne określenie i zdefiniowanie. Wykład zostanie uzupełniony 
    o uwagi historyczne i teoretyczne. Są łatwo dostępne i godne polecenia teksty
    ułatwiające opanowanie proponowanego wykładu, na przykład niżej wspomniany
    Introduction to Lambda Calculus.   
    
      
    Program:  
    
    
    # Rachunek lambda -- motywacje, trochę historii.
    #Formalna definicja rachunku lambda, relacje redukcji.
    #Formalizacja pojęcia obliczalności za pomocą rachunku lambda, 
    teza (Turinga)-Churcha, moc rachunku lambda.
    #Własności relacji redukcji, twierdzenie Churcha - Rossera.
    #Rachunek lambda z typami. #Rozstrzygalność prostego systemu typów.
    Twierdzenie o silnej normalizacji. 
    #Związki rachunku lambda z logiką.
    #Elementy semantyki.   
    #Paradoks Kleene'ego-Rossera, modele dla rachunku lambda.
    
      
    Bibliografia:  
    
    
    # H.P. Barendregt, The type free lambda calculus, 
    in J. Barwise, Handbook of Mathematic Logic.

    # H.P. Barendregt, The Lambda Calculus. Its Syntax and Semantics. Elsevier
    
    # H.P. Barendregt, E. Barendsen, Introduction to Lambda Calculus
    
    # H.P. Barendregt,  {\sl Lambda calculi with types}, in: S. Abramsky, 
    D.M. Gabbay and T.S.E. Maibaum (eds.), 
    Handbook of Logic in Computer Science, (1992).
    
    # A. Church, An unsolvable problem of elementary number theory, 
    American Journal of Mathematics 58, (1936).
    
    
    # A. Church, A formulation of the simple theory of types, 
    Journal of Symbolic Logic 5,  (1940).
    
    # R. Loader, Notes on Simply Typed Lambda Calculus, (1998). 
    
    # John C. Reynolds, Theories of Programming Languages."
Application Security,5,"* Pracownia programistyczna
* Wykład",,False,False,"Celem zajeć jest zaprezentowanie różnych aspektów bezpieczeństwa aplikacji.
Omówione zostaną często spotykane luki bezpieczeństwa wraz ze sposobami na ich
unikanie, komponenty aplikacji krytyczne pod względem bezpieczeństwa oraz
dodatkowe elementy związane z bezpieczeństwem, jak np. testowanie czy normy
ISO. Wszystkie prezentowane zagadnienia będą podparte stroną praktyczną, czyli
przeglądem produktów dostępnych na rynku wraz z przykładowym kodem w ulubionym
języku programowania.

##### **Program**

  1. Bezpieczeństwo informacji i aplikacji
    * wprowadzenie do zagadnienia
    * przegląd często spotykanych zagrożeń...
    * ... i sposoby na ich unikanie
    * rankingi OWASP i CWE
    * podstawy kryptografii
  2. Certyfikaty, podpisy elektroniczne, znaczniki czasu
    * podstawy teoretyczne, PKI, zastosowania certyfikatów
    * certyfikaty dostępne na rynku, rola Narodowego Centrum Certyfikacji, usługi kwalifikowane
    * strona praktyczna, przegląd rozwiązań, tworzenie własnych centrów certyfikacji
  3. Uwierzytelnianie i autoryzacja
    * komponenty składowe rozwiązania i ich rola
    * znaczenie w różnych warstwach sieciowych
    * przegląd protokołów i rozwiązań dostępnych na rynku, w tym NTLM i Kerberos
    * mechanizmy kontroli dostępu, w tym RBAC & ABAC
    * procesy związane zarządzaniem tożsamościami i dostępem
  4. Federacja tożsamości i delegacja autoryzacji
    * protokoły OAuth2, OpenID Connect i XACML
    * bezpieczeństwo w różnych typach architektury
    * integracja z usługami firm trzecich: SMS, systemy płatności, Auth0, Google, Facebook
  5. Bezpieczeństwo baz danych
    * przykład rozwiązań proponowanych przez Microsoft SQL Server
  6. Bezpieczeństwo na poziomie infrastruktury
    * bezpieczeństwo serwerów aplikacji
    * przegląd komponentów jak firewalle, proxy, IDS/IPS, WAF
    * znaczenie monitoringu, rola SIEM
  7. Architektura zabezpieczeń
    * znaczenie dobrych wymagań
    * rodzaje kontrolek i ich zastosowanie
    * przegląd i znaczenie podstawowych zasad bezpieczeństwa (ang. security principles)
    * przegląd warstw architektury i ich rola
    * koncepcja tzw. security domains
  8. Testowanie bezpieczeństwa 
    * testy penetracyjne i skany podatności, rodzaje, metodyki
    * przegląd narzędzi do przeprowadzania testów
    * wprowadzenie do hakowania
  9. End-to-end protection i modelowanie zagrożeń
    * metodyka STRIDE
    * zastosowanie narzędzi wspierających
    * baza CVE, kalkulator CVSS
    * przepływy informacji i ich zabezpieczenie
    * kompletność bezpieczeństwa rozwiązania
  10. Bezpieczeństwo w procesie wytwarzania oprogramowania
    * omówienie procesu, przegląd głównych etapów
    * przegląd ważniejszych aktywności, m.in. zbieranie wymagań, analiza ryzyka, threat modelling.
  11. Znaczenie wprowadzenia i utrzymywania polityki bezpieczeństwa

"
Methods of convergence acceleration,6,,,False,False,"Celem seminarium jest zapoznanie jego uczestników z nowymi oraz z klasycznymi
metodami i algorytmami przyspieszania zbieżności ciągów, szeregów i ułamków
łańcuchowych. Do zaliczenia zajęć konieczne będzie wygłoszenie referatu na
temat zasugerowanej przez prowadzącego seminarium metody numerycznej, jak
również jej zaimplementowanie oraz przetestowanie jej skuteczności.

Wymagania

  * analiza matematyczna,
  * analiza numeryczna (L lub M),
  * umiejętność programowania w dowolnym języku z obliczeniami na liczbach zmiennoprzecinkowych (najlepiej długiej precyzji)

"
Student apprenticeship,6,,,False,False,Program praktyki zalezy od firmy w której się odbywa.
Category Theory,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"**Teoria kategorii** to dość abstrakcyjny dział matematyki, który bada
struktury wspólne dla wielu, czasem nawet bardzo odległych dziedzin
matematyki. Teoria kategorii to także pewien język opisu obiektów
matematycznych, będący alternatywą dla języka teorii zbiorów.

Teoria kategorii okazuje się być bardzo użyteczna w informatyce, na przykład w
teorii języków programowania. Pojęcia pochodzące z teorii kategorii
przeniknęły też do codziennego warsztatu programisty pod postacią funktorów,
monad itp. Przedmiot ten pozwoli zrozumieć skąd wzięły się te pojęcia, jakie
są ich własności i jak je wykorzystać w praktyce.

Jedynym wymogiem wstępnym jest zdolność operowania podstawowymi pojęciami
matematycznymi, ale pobieżna znajomość algebry abstrakcyjnej i programowania
funkcyjnego zdecydowanie pomogą w zrozumieniu motywacji dla wielu
abstrakcyjnych i często początkowo nieintuicyjnych definicji.

**Omawiane zagadnienia:**

  * Podstawowe pojęcia teorii kategorii (kategorie, funktory, transformacje naturalne), konstrukcje na kategoriach i w kategoriach
  * Dualność: dwa pojęcia/twierdzenia w cenie jednego
  * Konstrukcje uniwersalne: (ko)produkty, (ko)granice, sprzężenia
  * Domknięte kategorie kartezjańskie i rachunek lambda
  * (Ko)algebraiczne typy danych
  * Monady i ich algebry
  * Kwantyfikatory jako sprzężenia
  * Typy zależne jako sprzężenia

**Literatura:**

Podstawowy podręcznik:

  * Steve Awodey, Category Theory (2nd ed.), Oxford Logic Guides, 2010

Inne podręczniki:

  * Saunders Mac Lane, Categories for the Working Mathematician (2nd ed.), Springer, 1998
  * Michael Barr, Charles Wells, Category Theory for Computing Science, Prentice Hall,1990
  * Harold Simmons, An Introduction to Category Theory, Cambridge University Press, 2011
  * David Spivak, Category Theory for the Sciences, MIT Press, 2014
  * Tom Leinster, Basic Category Theory, Cambridge University Press, 2014"
Design i deployment of cloud systems,6,,,False,False,"Celem zajęć jest przedstawienie tematów związanych z systemami działającymi na
nowoczesnych platformach public cloud (przede wszystkim Amazon Web Services,
Google Cloud Platform i Microsoft Azure). Znaczną część semestru poświęcimy
zrozumieniu koncepcji umożliwiających budowanie systemów o wysokiej
dostępności i skalowalności. Omawiane będą zarówno tematy związane z
architekturą aplikacji, procesami umożliwiającymi jej rozwój, jak również całą
infrastrukturą umożliwiającą działanie systemu (wybór bazy danych i jej
przygotowanie, komunikacja między usługami, sieć wewnętrzna, dystrybuowanie
ruchu od użytkowników, globalny zasięg aplikacji).

Przedmiot ma na celu wyjaśnienie zależności pomiędzy wieloma różnymi aspektami
związanymi z uruchamianiem systemów w chmurze, stąd przydadzą się podstawy z
bardzo wielu różnych przedmiotów, takich jak: sieci komputerowe, algorytmy i
struktury danych czy bazy danych.

Technologie, produkty i koncepcje, które w jakiejś formie pojawią się na
zajęciach: AWS, GCP, Azure, Kubernetes, Docker, mikroserwisy, configuration
management (ansible, chef, puppet, saltstack, terraform), site reliability
engineering, incident management, monitoring, hurtownia danych, wysoka
dostępność i skalowalność, load balancing.

Opis przedmiotu przygotował Mateusz Markiewicz. Przedmiot jest prowadzony
wspólnie z Rafałem Cieślakiem. Opiekunem przedmiotu jest T. Wierzbicki.

"
Seminar on networks and clouds,3,,,False,False,"Tematyka seminarium obejmuje problemy współczesnych sieci komputerowych i
telekomunikacyjnych, w tym dzisiejszego Internetu, budowę Content Delivery
Networks, działanie systemów w chmurze, zagadnienia wysokiej dostępności i
skalowalności usług. Zakres tematyki seminarium jest celowo bardzo duży — to,
o czym będzie mowa na zajęciach zostanie ustalone w ich trakcie, w zależności
od aktualnych zainteresowań uczestników. Zagadnienia sieci komputerowych są w
naszym instytucie dosyć niszowe. Seminarium ma w zamierzeniu spełniać rolę
swego rodzaju „koła zainteresowań”, skupiającego osoby zainteresowane sieciami
komputerowymi, a nie przedmiotu, na którym omawia się szczegółowo jedną
wybraną wąską specjalność.

"
Capturing 3D Humans Project,4,"* Wykład interaktywny
* Projekt programistyczny
* Projekt badawczy",,False,False,"During this project we will implement a software system that will use RGB-D
Cameras (Kinects) working simultaneously to capture 3D objects in movement in
real time. In particular, we are interested in capturing humans in movement.

During the project we will build a system that records video and depth maps,
from different view points simultaneously, and merge the information of all
view points into a coherent 3D model. In order to build this process we will
learn, build and research about the following topics. Students (all or some,
depending on how many students) will have access to the Kinect camera.

\- Camera Calibration and synchronization

\- Pointcloud registration, cleaning, processing...

\- Meshing and textuing

\- Geometry and volumetric data processing

\- Efficient 3D video representation

\- 3D user interfaces

We aim to divide the system in small groups to work on different areas,
depending on knowledge, skills and interests. The course is thought os it is
interactive, taking design, development, and organizational decisions as a
group. Studends are expected to dedicate between 2 and 4 hours per week
working to the project besides the lecturing hours.

We will use the lecturing hours to explain the necessary concepts for the
project, discuss progress, and possible solutions for the different probles to
solve.

The project will involve to do some research and development, as well as the
usage of open source libraries used , such as OpenVDB, PCL, and opencv.

"
Computational Photography B,6,,,False,False,"Computational photography is a relatively new field at the convergence of
photography, computer vision, image processing, and computer graphics. Its
goal is to overcome the limitations of traditional photography using
computational techniques to enhance the way we capture, manipulate, and
interact with visual media. This course covers fundamentals and applications
of hardware and software techniques, with an emphasis on software methods. We
will study many interesting, recent image based algorithms and implement them
to the degree that is possible.

We will cover topics such as

  * Cameras and image formation
  * Image stitching / completion / inpainting
  * Texture synthesis, super-resolution, denoising.
  * Light fields
  * Image based lighting and rendering
  * High dynamic range
  * Intrinsic Images
  * Coded aperture photography
  * Modeling and synthesis using Internet data
  * ... more interesting topics.

**References and sites of interest**

[Computational Photography
Book](http://www.amazon.com/gp/product/1568813139?ie=UTF8&tag=merl-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1568813139
""Computational Photography Book"")

<http://store.elsevier.com/product.jsp?isbn=9780123749147>

<http://web.media.mit.edu/~raskar/photo/>

<http://web.media.mit.edu/~gordonw/CompressiveLightFieldPhotography/>

<http://www.pauldebevec.com/Research/LS/>

<http://www.amazon.com/Color-Imaging-Fundamentals-Erik-Reinhard/dp/1568813449>

**Requirements:**

C++ and Basic Algebra. Computer Graphics and Image Processing will be useful.

**Note**

Whether there will be exam or not is still to be decided.

"
Course: Practical Software Development,5,,,False,False,"**Practical Software Development**

Have you ever wondered how enterprise-class software development looks like?
What are the technologies used by big software companies and what skillset is
necessary to succeed? If your answer is yes this Credit-Suisse sponsored
course might be designed just for you.

**Goal**

The goal is to replace component by component a legacy and underperforming
option trading system. The architecture of new solution is designed to closely
mimic real-life trading systems with all main components in place. Over the
course period students will have a chance to create:

  * Front-end web based user interface
  * Back-end component performing automatic hedging operations
  * Trade store archiving all trading operations
  * Risk engine calculating price and delta risk factor of an option (implementing Black-Scholes model)
  * Market price simulator (based on Brownian Motions)

To mimic real-life development process as closely as possible students will
use SVN to maintain their codebase as well as receive functional
specifications for each component in a format similar to industry standard.

**Technologies**

Over the course period students will have a chance to use:

  * C# or Java for the back-end components (depending on each students preferences; all back-end related handovers are created in both languages)
  * MongoDB as a store (NoSQL)
  * HTML5 with ReactJS Framework for a front-end
  * RESTful API and sockets to maintain component communication

**Prerequisites**

Basic understanding of object-oriented programming is necessary to
participate. All materials are prepared in both C# and Java so language choice
is up to students preferences.

**Workload**

The course is full-semester long. Expected workload outside of class hours
each week is 4-6 hours. There are few recap sessions planned during course
period with no new lecture topic and lab used to aid students with any
potential problems. Additionally Credit-Suisse experts in all used
technologies are available for consultancy over whole course period.

"
Project: autonomous martian rover,4,"* Projekt programistyczny
* Projekt badawczy",,False,False,"Chcemy aby nasz instytutowy łazik potrafił objechać budynek Instytutu
wykorzystując jedynie kamery pokładowe. Pokażmy, że nie tylko w dolinie
krzemowej powstają pojazdy autonomiczne!  
  
Uwaga:  
Projekt odbędzie się w obydwu semestrach, dopuszczalny jest wielokrotny udział
jednego studenta w projekcie.  
Prace wykonane w projekcie mogą stanowić część pracy inżynierskiej lub
magisterskiej.  
  
Nasz uniwersytecki łazik jest świetną platformą do poznawania algorytmów
potrzebnych w autonomicznych pojazdach: całe sterowanie jest cyfrowe (podobnie
jak w samochodach łazik posiada szynę danych CAN), komunikacja z komputerem i
podzespołami wykorzystuje pakiet robotyczny ROS [1], wykonane są narzędzia
znajdujące do wizualizacji stanu łazika (położenie, prędkości kół itp.).
Ponadto łazik może udźwignąć sporej wielkości laptopa, albo minikomputer
pokładowy Nvidia Jetson (którym dysponujemy).  
  
W zeszłym semestrze udało nam się autonomicznie objechać garaż. Nasze
rozwiązanie wykorzystywało głębokie sieci neuronowe sterujące łazikiem na
podstawie obrazu z kamer [2]. Stworzyliśmy też symulator łazika do szybkich
eksperymentów. W kolejnych semestrach chcielibyśmy dodać elementy tworzenia
map i planowania trasy (SLAM).  
  
**Wstępny plan pracy**  
Chcielibyśmy przede wszystkim w pełni wykorzystać możliwości ROSa i pakietów
SLAM RtabMAP [3]. Chcielibyśmy również zaimplementować pracę system w którym
tworzona jest przybliżona mapa przejezdności na podstawie przewidywań sieci
neuronowej [4].  
  
Dostępne jest też wiele tematów usprawniających działanie łazika, przykładowo
automatyczna manipulacja przedmiotami i wykrywanie obiektów.  
  
Przedmiot prowadzony będzie wspólnie z Markiem Materzokiem.  
  
Literatura:  
[1] http://www.ros.org/  
[2] Bojarski, Mariusz, et al. ""End to end learning for self-driving cars.""
arXiv preprint arXiv:1604.07316 (2016). https://arxiv.org/abs/1604.07316  
[3] http://wiki.ros.org/rtabmap_ros  
[4] Hadsell et al., Learning long-range vision for autonomous off-road
driving, Journal of Field Robotics 2009

"
Automated verification,3,"lectures, blackboard problem solving, programming exercises",,False,False,"Half-semester (the first half of the summer semester) introductory course to
automated verification by model checking. Students are encouraged to take
deductive verification course with Małgorzata Biernacka in the second half of
the semester.

Model checking is a collection of algorithmic techniques to verify (i.e.,
prove or disprove) if a given model of a computer system (software or
hardware) meets its formal specification. The specification is given as a
formula in temporal logic. In this course we want to introduce basic concepts
of the theory behind model checking.  
  

Specifically, we are going to cover the following:

  * temporal logics LTL and CTL
  * explicit-state model checking
  * symbolic model checking with ordered binary decision diagrams (OBDD)
  * bounded model checking and reduction to SAT"
"Games, Automata, Logics, and Formal Verification",6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"This course provides an introduction to some of the central ideas of formal
methods in computer science. We mainly focus on as a set of mathematical tools
for understanding complex systems, motivated by Computer-Aided Verification.

The lecture will discuss three interconnected research fields:

  * Automata (on infinite words and trees) 
  * Logical systems (such as temporal and modal logics) for specifying operational behaviour
  * Two-person games as a conceptual basis for understanding interactions between a system and its environment

This course will focus on the theoretical underpinnings, but it might also
include a small practical project.

Requirements: You need to know:

* what is a finite automaton and how the pumping lemma works,  
* first-order logic,  
* notions of reduction and decidability,  
* some basic complexity classes (PSPACE, EXPTIME, NP).

"
Scientific Writing,4,,,False,False,"_Ten przedmiot jest równoważny seminarium na studiach II stopnia._

Planowane zajęcia przeznaczone są przede wszystkim dla doktorantów i
studentów, którzy zamierzają zajmować się pracą twórczą.

Zajęcia będą miały formę warsztatów. Uczestnicy będą pisali teksty, które będą
potem wspólnie poprawiane tak, aby ostateczne wersje były precyzyjne i
zrozumiałe. Ćwiczona będzie też zwięzłość.

Planuję trzy typy ćwiczeń:

  1. Zapisywanie nieco bardziej złożonych rozumowań (takich jak trudniejsze zadania z JFiZO), po polsku i po angielsku. 
  2. Planowanie struktury większych tekstów (przerabianie istniejących prac lub pisanie całkiem nowych).
  3. Opisywanie motywacji, przekonywanie o ważności badań, przeglądy literatury. Pisanie wstępu i streszczenia tak, aby były zrozumiałe nie tylko dla wąskich specjalistów.

Zamierzam przygotować problemy do ćwiczeń, publikacje do krytykowania i
przerabiania, ale będę się cieszył, jeśli słuchacze przyniosą własne problemy.
Będziemy mogli przerabiać (lub redagować) prace własne uczestników. Będę
zachęcał słuchaczy do dyskusji o czytanych przez nich pracach, które są (ich
zdaniem) źle napisane (zbyt trudne, nieprecyzyjne, nieczytelne) lub wręcz
przeciwnie, są wzorowo zredagowane.

Ponadto będziemy rozmawiać o problemach etycznych. Nie tylko o plagiatach, ale
także o tym, jak traktować niepublikowane informacje przekazane przez kolegów,
jak traktować wiedzę zdobytą w trakcie recenzowania prac zgłoszonych na
konferencję lub do czasopisma.

"
Design and implementation of advanced PHP applications,5,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład",,False,False,"Na przestrzeni ostatnich 3-4 lat język PHP przeszedł ogromną metamorfozę.
Engine języka został całkowicie przeprojektowany, składnia języka rozszerzona,
a w ekosystemie pojawiły się narzędzia, bez których trudno wyobrazić sobie
prowadzenie nowoczesnego projektu webowego. Rozwinięciu uległy także
frameworki, odciążające programistę z powtarzalnych problemów i pozwalające na
skupienie uwagi na implementacji wymagań biznesowych. Zespoły pracujące nad
nowoczesnymi aplikacjami opartymi o PHP wykorzystują m.in. techniki OOP, DDD,
CQRS, Event Sourcing do implementacji skalowalnych i rozproszonych systemów o
złożonej logice.  
W trakcie zajęć zapoznamy się więc zarówno z aktualnie wykorzystywanym
ekosystemem PHP (narzędzia, frameworki, etc.) jak i podejściami
wykorzystywanymi przy projektowaniu bardziej złożonego oprogramowania (OOP,
DDD, CQRS, ES). Całość prezentowanych tematów przećwiczymy praktycznie, aż po
wdrożenie na wybranej chmurze. Nie zabraknie również case-studies znanych
projektów (w tym polskich), na przykładzie których przeanalizujemy procesy
projektowania i implementacji.

#### Forma zajęć i zaliczenie

Zajęcia składać się będą z wykładów oraz pracowni. Podczas zajęć na pracowni
realizowany będzie projekt, na którego przykładzie przedstawiony zostanie
pełny cykl pracy. Od szybkiego rozpoznania wymagań biznesowych, przez
implementację, wdrożenie i utrzymanie aplikacji na środowisku serwerowym.
Projekt ten będzie stanowić także podstawę zaliczenia zajęć.

**Wymagania**

Programowanie obiektowe, podstawowa znajomość baz danych.

#### _O prowadzącym:_

_Mariusz Gil - software architect, tech-lead, ex-CTO, a także trener i
konsultant, z branżą IT związany od ponad 17 lat. Absolwent Wydziału
Informatyki i Matematyki UWr. Miał okazję pracować w zespołach m.in. Naszej-
Klasy, Gadu-Gadu, Nextclicka. Organizator eventów dla developerów,
współzałożyciel community PHPers, prelegent na konferencjach developerskich w
USA, Kanadzie, Francji, Niemczech, Słowacji, Ukrainie, Belgii, Holandii,
Litwie. Aktualnie właściciel Source Ministry, pracuje także jako trener w
Bottega IT Minds._

"
Project: creating a chatbot,6,,,False,False,"Celem projektu jest utworzenie bota konwersacyjnego, który mógłby rozmawiać na tematy wszelakie, w szczególności na te związane ze studiami w naszym instytucie. Bardzo istotną funkcją będzie również odpowiadanie na pytania, odwołujące się do wiedzy ogólnej (czerpanej z Wikipedii i innych źródeł). Podstawowym językiem pracy bota będzie język polski, ale być może rozważymy też wprowadzenie innych języków (angielskiego, ukraińskiego, hiszpańskiego). Podczas spotkań będziemy używać języka polskiego, chyba że będzie na sali osoba preferująca język angielski.

Bot (w założeniu) będzie dość złożonym systemem, który łączy tradycyjne podejście
oparte na wzorcach z różnymi zagadnieniami związanymi z przetwarzaniem
tekstów, sieciami neuronowymi, ekstrakcją informacji, modelowaniem języka,
etc.

Niektóre spotkania mogą mieć postać mini-seminariów, podczas których studenci będą przedstawiać prace naukowe związane z agentami konwersacyjnymi i odpowiadaniem na pytania (oczywiście takie prace, które mają szansę być wykorzystane w projekcie)

Można te zajęcia traktować jako kontynuacje przedmiotów Eksploracja tekstów oraz Neural Networks and Natural Language Processing, ale uczestnictwo w którymś z tych kursów nie jest ścisłym wymaganiem
Ponadto niektóre trudne zadania będziemy realizować w łatwych wersjach, koncentrując się na praktycznym wykorzystaniu pewnych technologii,
pomijając (lub redukując) ich podstawy teoretyczne. 

Niektóre moduły być może zostaną (w jakiejś
podstawowej wersji) przygotowane przez prowadzącego przedmiot. Niektóre moduły bota będą realizowane w zespołach."
Principles of programming languages,6,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład",,False,False,"**Overview:**

This course provides students with a deep, working understanding of the
essential concepts of programming languages. These concepts relate to the
semantics of computer programs and are presented in terms of interpreters and
typecheckers, implemented in one of the modern functional languages such as
Ocaml, Racket, or Haskell. The course offers both an analytic view of the
semantics of programming constructs and a hands-on approach to the executable
semantics. In particular, the students are required to implement a number of
small interpreters on a weekly basis, and to carry out a final project
concerning an implementation of a bigger interpreter or a related programming
language processor.

**Topics:**

  * inductive data specification and recursive programming, data abstraction
  * interpreters, abstract machines, compilers and virtual machines
  * static (lexical) and dynamic scope, substitution, variable representation
  * call-by-value, first-class functions and recursion
  * state, call-by-reference, call-by-name, call-by-need
  * interpreters in continuation-passing style (CPS), exceptions, multithreading, control operators
  * CPS transformations
  * computational effects
  * abstract machines as defunctionalized interpreters in CPS
  * deriving a compiler and a virtual machine from an interpreter (optional)
  * simple types, parametric polymorphism, type checking and type inference
  * typed modules
  * basic concepts of object-oriented languages
  * reduction semantics, PLT Redex (optional)
  * abstract machines as refocused reduction semantics (optional)

**Prerequisites:**

It is assumed that the student can program in a functional language and that
she/he is familiar with common programming constructs present in mainstream
programming languages. The course should be accessible to dedicated
undergraduate and graduate students alike.

**Bibliography:**

  * [Essentials of Programming Languages](http://www.eopl3.com/), 3rd edition. Daniel P. Friedman and Mitchell Wand. The MIT Press, 2013.
  * [Programming Languages: Application and Interpretation](http://cs.brown.edu/~sk/Publications/Books/ProgLangs/), 2nd edition. Shriram Krishnamurthi. 2012.
  * [Semantics Engineering with PLT Redex](https://redex.racket-lang.org/). Matthias Felleisen, Robert Bruce Findler, Matthew Flatt. The MIT Press, 2009.
  * [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/full-text/book/book.html), 2nd edition. Harold Abelson, Gerald Jay Sussman, Julie Sussman. The MIT Press, 1996.
  * [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/). Benjamin C. Pierce. The MIT Press, 2002.

"
Project: Evolutionary construction of 2D wheeled vehicles,6,"* Projekt programistyczny
* Pracownia programistyczna
* Projekt badawczy",,False,False,"Projekt dotyczy zastosowania algorytmów ewolucyjnych do konstruowania pojazdów
kołowych w środowisku Box2D. Przykładową realizację można zobaczyć na filmie
opublikowanym na YouTube (<https://www.youtube.com/watch?v=uxourrlPlf8)>.

Celem projektu jest opracowanie algorytmów ewolucyjnych umożliwiających
konstruowanie pojazdów kołowych zdolnych do pokonania zadanych tras, ich
implementacja wraz z wizualizacją rezultatów oraz wykonanie eksperymentów
obliczeniowych potwierdzających skuteczność opracowanych algorytmów. W
zależności od efektywności algorytmów i ich czasu działania, implementacja
może być przeznaczona albo do obliczeń na pojedynczych komputerach, albo do
obliczeń równoległych lub rozproszonych na klastrze obliczeniowym (w II UWr
lub w WCSS).

Oprócz prac typowo projektowych, w ramach przedmiotu konieczne będzie
zapoznanie się z literaturą dotyczącą tematyki projektu oraz bibliotekami i
narzędziami przydatnymi w pracach projektowych (m.in. środowisko Box2D lub
podobne).

"
Internet of Things,6,,,False,False,"Celem przedmiotu jest zaprezentowanie zagadnień związanych z szerego
rozumianym tzw. Internetem rzeczy.

**Program**

  1. Architektura rozwiąząń IoT
  2. Przegląd rozwiązań chmurowych wspierających architekturę IoT
  3. Pojęcia Edge i Fog computing
  4. Wprowadzenie do programowania na Raspberry Pi
  5. Interakcja z rzeczami
  6. Przegląd wzorców komunikacyjnych z zastosowaniem dedykowanych protokołów
  7. Cykl życia urządzeń i związane z tym wyzwania
  8. Zbieranie danych i ich analiza, zastosowanie ML
  9. Bezpieczeństwo rozwiązań IoT
  10. Przegląd praktycznych zastosowań, w tym: 
    * przemysł motoryzacyjny,
    * ochrona zdrowia,
    * rolnictwo,
    * logistyka,
    * marketing i sprzedaż,
    * inteligentne domy i miasta

"
Seminar: Probabilistic Graphical Models,3,,,False,False,"Modele graficzne pozwalają na zapis złożonych rozkładów prawdopodobieństwa w
formie grafu interakcji między zmiennymi: prawdopodobieństw warunkowych (grafy
skierowane) oraz funkcji potencjału (grafy nieskierowane). Taki zapis
umożliwia nam wprowadzenie do modelu naszej wiedzy o zależnościach między
zmiennymi, prowadzenie rozważań jak nasza wiedza o zmiennych wpływa na
niezależności warunkowe albo nawet na rozważanie relacji przyczynowo-
skutkowych. Możemy też prowadzić wnioskowanie: wyznaczyć rozkład na pewnym
zbiorze zmiennych uwarunkowany na innych zmiennych. Choć dokładne wnioskowanie
jest często niewykonalne, istnieje szereg metod przybliżających dokładne
wyniki (filtry cząsteczkowe, aproksymacje wariacyjne). Modele graficzne są
bardzo ogólne i umożliwiają spójne traktowanie łańcuchów Markowa stosowanych w
rozpoznawaniu mowy, filtrów Kalmana stosowanych w robotyce, czy warunkowych
pól prawdopodobieństw stosowanych w przetwarzaniu języka naturalnego.

Modele graficzne łączą się również z sieciami neuronowymi: niektóre sieci
neuronowe dają się zapisać w postaci modeli graficznych (np. sieci typu RBM),
inne zaś stanowią hybrydy w których część prawdopodobieństw definiujących
model graficzny reprezentowane jest przez sieć neuronową (np. autoenkoder
wariacyjny). Jest prawdopodobne, że wymogi dotyczące m.in. przejrzystości
modeli sztucznej inteligencji spowodują powstanie większej ilości podobnych
hybryd w których chociaż sieć wyznacza część rozkładów prawdopodobieństwa to
końcowa odpowiedź wymaga również wnioskowania w modelu graficznym dla którego
możemy udowodnić że przykładowo pewne zmienne wrażliwe (np. płeć, pochodzenie
etniczne) nie wpływają bezpośrednio na wyniki.

**Program:**

Na seminarium chciałbym w formacie ""odwróconych zajęć"" wspólnie ze słuchaczami
przerobić książkę ""Probabilistic Graphical Models"" w zakresie odpowiadającym
kursowi pod tą samą nazwą na Stanfordzie i na Courserze. Na cotygodniowych
spotkaniach spróbujemy wspólnie omówić wykłady i rozdziały z książki oraz
pogłowimy sie nad listami zadań.

**Warunki zaliczenia:**

Aktywne uczestnicotwo w zajęciach (dopuszczalne 2 nieobecności) -
przygotowanie do zajęć i udział w dyskusji dotyczącej omawianych materiałów,
przygotowanie kilku mini-wykładów dotyczących omawianych treści."
Ray Tracing Project,4,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład",,False,False,"Celem projektu jest nabycie umiejętności implementacji efektywnych struktur
przyspieszających ray tracing. W ramach przedmiotu po omówieniu metod
przyspieszania przedstawię podstawy fizyczne transportu światła, które pozwolą
na wyprowadzenie poprawnego algorytmu obliczającego oświetlenie (path tracer).
W ramach projektu każdy napisze od podstaw własny ray tracer (dokładniej path
tracer).

**Program:**

  * Metoda śledzenia promieni i algorytmy przyspieszające
  * Przegląd struktur przyspieszających i heurystyki dla ich konstrukcji
  * Podstawy fizyczne transportu światła
  * Metody Monte Carlo i path tracing

**Wymagania:** wiedza z podstaw grafiki komputerowej, podstawy rachunku
prawdopodobieństwa i analizy matematycznej, umiejętność biegłego programowania
w C/C++

"
"Seminar on IT Security, Cloud Computing, Microservices, and DevOps",3,,,False,False,"Celem seminarium jest zgłębienie aspektów bezpieczeństwa w nowych obszarach
jak Internet of Things, Cloud Computing, Microservices czy DevOps.

"
Blockchain and its applications,6,,,False,False,"Celem przedmiotu jest zapoznanie studentów z technologią blockchain,
podstawami teoretycznymi oraz jej bardzo szeroko rozumianymi zastosowaniami. W
planach jest również utworzenie prostej aplikacji wykorzystującej tę
technologię.

"
Programming in Scala,5,"* Pracownia programistyczna
* Wykład",,False,False,"Celem zajęć jest zapoznanie studentów ze współczesnym wieloparadygmatycznym
językiem programowania Scala. Scala jest posadowiona na platformie JVM (a
także .NET). Scala jest językiem skalowalnym, tzn. ten sam mechanizm językowy
równie dobrze opisuje małe, jak i duże komponenty programowe.

Najważniejsze cechy języka Scala są przedstawione na stronie:
<http://docs.scala-lang.org/tour/tour-of-scala.html>

  * Scala jest językiem z silną typizacją statyczną (system typów zarówno nominalny, jak i strukturalny), łączącym programowanie obiektowe i funkcyjne.
  * Scala jest językiem obiektowym, w którym każda wartość jest obiektem, a każda operacja jest metodą.
  * Scala jest językiem funkcyjnym, w którym każda funkcja jest wartością pierwszej kategorii.
  * Scala umożliwia użycie mechanizmu dopasowania do wzorca.
  * Scala wspiera niskopoziomowe programowanie współbieżne za pomocą wątków, ale oferuje wiele mechanizmów na wyższym poziomie abstrakcji, np. mechanizm aktorów, mechanizm Future, strumienie reaktywne, kolekcje równoległe, pamięć transakcyjną.
  * Możliwa jest „bezszwowa” integracja kodu w językach Scala i Java.

Na wykładzie będą przedstawione konstrukcje językowe języka Scala z
przykładami ich wykorzystania. Na zajęciach w pracowni studenci będą pisali
proste programy, których tematyka będzie zsynchronizowana z zagadnieniami,
omawianymi na wykładzie.

Wymagana jest podstawowa znajomość programowania funkcyjnego i obiektowego,

  * Odersky, L.Spoon, B.Venners, _Programming in Scala_ , Third Edition, Artima, Walnut Creek 2016
  * <http://www.artima.com/pins1ed/> (tu jest dostępne pierwsze wydanie)
  * G.Balcerek. _Język programowania Scala_ _(wyd. 2)_. G. Balcerek 2016

"
Seminar: Parameterized Algorithms,3,* Wykład interaktywny,,False,False,"The course will be given by Syed Mohammad Meesum.

    
    
      
    The course will be providing an introduction to the field of Parameterized Complexity.
    We will begin with stating the basic definitions and goals of the subject.
    I particular we would be focussing on the following.
    
    1. Kernelization -- compressing input instances.
    2. Branching and bounded-depth search trees.
    3. Iterative Compression — a general template for solving some graph deletion problems.
    4. Color Coding / Randomized methods — application to longest path etc.
    5. Parameterization Above Guarantee, LP based methods.
    6. W-hardness — when is a problem not fixed parameter tractable.
    
    By the end of the course, students would be expected to read papers and present them to the class.  
      
    Requirements: basic probability theory, basic complexity theory (NP-completeness).  
      
    Reading: https://www.mimuw.edu.pl/~malcin/book/parameterized-algorithms.pdf"
Seminar: Theory of linear and integer programming,3,,,False,False,"

"
Seminarium: Pathfinding algorithms,3,,,False,False,"**Pathfinding algorithms**

Seminarium ma na celu pokazanie, że problem wyszukiwania drogi na algorytmie
A* się nie kończy, a dopiero zaczyna. A także, że jest to problem bardzo
różnorodny, w praktyce występujący w wielu odmianach i często podlegający
dodatkowym ograniczeniom.

W tym celu chciałbym abyśmy opowiedzieli sobie m.in. o

  * niestandardowych funkcjach heurystycznych (rodzina ALT, ...)
  * hierarchicznych podejściach do przeszukiwania (HPA* i rozszerzenia)
  * asymetrycznych algorytmach dla grafów typu uniform grid (JPS, JPS+, ...)
  * wyszukiwaniu w czasie rzeczywistym (IDA*, DBA*, ...)
  * wyszukiwaniu przy dynamicznym środowisku (D*, D* Lite, ...)
  * równoczesne wyszukiwanie ścieżek dla wielu agentów
  * wyszukiwaniu w niestandardowych grafach (heksy, trójkąty)
  * tworzeniu (dobrze wyglądających) ścieżek w przestrzeni ciągłej 
  * różnych niestandardowych zagadnieniach (np. przeszukiwanie zależne od zawartości ekwipunku postaci)

Materiały przeglądowe:

  * [Pathfinding in Games,](http://drops.dagstuhl.de/opus/volltexte/2013/4333/pdf/4.pdf) Botea et al.
  * [A Comprehensive Study on Pathfinding Techniques for Robotics and Video Games](https://www.hindawi.com/journals/ijcgt/2015/736138/), Algfoor et al.
  * [Grid-Based Path Planning Competition](http://movingai.com/GPPC/), Sturtevant N.

"
Operating Systems (advanced),6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",,False,False,"Na wykładzie skupimy się na poznawaniu funkcji jądra systemu operacyjnego
udostępnianych programiście systemowemu. Oprócz tematów wspólnych dla
większości SO będziemy zapoznawać się z rozwiązaniami dostępnymi w systemach
uniksowych i uniksopodobnych (Linux, FreeBSD, NetBSD, MacOSX, QNX, MINIX3).

#### Wprowadzenie [4h]

  * Jądro, system operacyjny, dystrybucja.
  * Rodzaje systemów operacyjnych (wbudowane, czasu rzeczywistego, rozproszone).
  * Najważniejsze osiągnięcia w dziedzinie systemów operacyjnych.
  * Wywołania systemowe i komunikacja programów z jądrem.
  * Architektura jądra systemu operacyjnego (jądra monolityczne, mikrojądra, exokernel).

#### Procesy i wątki [8h]

  * Przestrzeń adresowa procesu.
  * Zarządzanie procesami i wątkami.
  * Hierarchia procesów.
  * Planowanie zadań.
  * Synchronizacja (wyłączanie przerwań, blokady, zmienne warunkowe).
  * Komunikacja (potoki, gniazda, skrzynki pocztowe)
  * Programowanie współbieżne (logika temporalna).

#### Pamięć [8h]

  * Zarządzanie pamięcią fizyczną (system bliźniaków).
  * Listowy algorytm przydziału.
  * Pule obiektów.
  * Pamięć wirtualna.
  * Zarządzanie przestrzenią wirtualną.
  * Stronicowanie na żądanie, buforowanie stron.
  * Algorytmy wymiany stron.
  * Ładowanie programów, biblioteki współdzielone.
  * Wersjonowanie przestrzeni adresowych (vm_object).

#### Pliki, systemy plików [6h]

  * Operacje na plikach i katalogach.
  * Hierarchia plików, punkty montażowe.
  * Uprawnienia plików.
  * Wirtualny system plików (VFS).
  * Zarządzanie przestrzenią dyskową.
  * Organizacja systemów plików (i-węzły, katalogi).
  * Migawki, dziennikowanie, kopie zapasowe.

#### Tematy dodatkowe [4h]

  * Sterowniki – zasoby, urządzenia, szyny, proces wykrywania urządzeń.
  * Zegar systemowy i zarządzanie czasem.
  * Proces ładowania systemu operacyjnego.
  * Autoryzacja i uwierzytelnianie (PAM).
  * Zapobieganie cyberatakom.
  * Maszyny wirtualne.

"
Semantics of programming languages,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Przedmiot stanowi wprowadzenie do formalnych technik opisu semantyki
(znaczenia) języków programowania oraz formalnych metod wnioskowania o
programach komputerowych. Omawiane na przedmiocie formalizmy znajdują
zastosowanie w projektowaniu i implementacji języków programowania, a także w
konstrukcji i weryfikacji oprogramowania. Wśród poruszanych tematów znajdą
się:

  * definicje indukcyjne
  * semantyka obliczeń imperatywnych, w tym semantyka operacyjna (naturalna) oraz denotacyjna (elementy teorii dziedzin)
  * semantyka obliczeń z interakcją (wejście/wyjście i/lub procesy współbieżne, strukturalna semantyka operacyjna i etykietowane systemy przejść, koindukcja i bisymulacje) 
  * semantyka programów funkcyjnych, w tym rachunek lambda i jego rozszerzenia jako modelowy język funkcyjny (semantyka redukcyjna, maszyny abstrakcyjne, kontynuacje)
  * systemy typów, w tym typy proste (typowanie syntaktyczne, terminacja obliczeń, relacje logiczne), polimorfizm parametryczny (darmowe twierdzenia), modularność (typowanie semantyczne), typy rekurencyjne (indeksowane relacje logiczne), równoważność kontekstowa programów, zaawansowane systemy typów (mutowalny stan, współbieżność, systemy typów i efektów).

W ramach ćwiczeń studenci będą rozwiązywać zadania teoretyczne ilustrujące i
poszerzające treści prezentowane na wykładzie.

**Prowadzący wykład:** Dariusz Biernacki i Filip Sieczkowski

**Wymagania wstępne:** Logika dla informatyków, Metody programowania,
Programowanie funkcyjne

**Literatura:**

  1. _The Formal Semantics of Programming Languages: An Introduction._ Glynn Winskel. Foundation of Computing Series, MIT Press 1993, ISBN 978-0-262-23169-5.
  2. _Semantics Engineering with PLT Redex._ Matthias Felleisen, Robert Bruce Findler, Matthew Flatt. The MIT Press 2009, ISBN 978-0262062756.
  3. _Theories of Programming Languages._ John C. Reynolds. Cambridge University Press 1998, ISBN 978-0521594141.
  4. _Types and Programming Languages._ Benjamin C. Pierce. The MIT Press 2001, ISBN 978-0262162098.
  5. _Advanced Topics in Types and Programming Languages._ Benjamin C. Pierce (editor). The MIT Press 2004, ISBN 978-0262162289.
  6. _Practical Foundations for Programming Languages (2nd edition)._ Robert Harper. Cambridge University Press 2016, ISBN 978-1107150300.

"
Seminar: Software Engineering,3,* Wykład monograficzny,,False,False,"Podczas seminarium omawiane są efektywne metody i standardy stosowane podczas
wytwarzania oprogramowania. Referaty dotyczą zwinnych i ciężkich metodologii
wytwarzania oprogramowania, stosowanych metod i narzędzi..

Podczas seminarium studenci równiez dzileą się wiedzą nt metod i narędzzi
inzynierii oprogramowania stosowanych w firmach w kktórych pracowali/pracują
ew. byli na praktyce."
Seminar: Games and game playing,3,"Wykład, prezentacja, dyskusja, indywidualna praca badawcza.",,False,False,"Na seminarium będziemy referować oryginalne prace dotyczące
gier w sensie klasycznym (takich jak szachy czy gra w karty).

Prace do omówienia będą pochodzić głównie z wiodących konferencji i obejmuje tematykę *Game Playing*: tworzenie agentów (graczy), języki opisu gier, rozwiązywanie gier, sztuczna inteligencja w grach, złożoność gier i General Game Playing.
Podam konkretne propozycje, ale będzie można również zaproponować własną o ile będzie związana z tematem.

W szczególności poszukuję grupy studentów do współpracy. Proponuję dołączenie do mojego [projektu](https://sites.google.com/a/cs.uni.wroc.pl/msz/home/cooperation).
W jego ramach można będzie wykonać pracę badawczo-rozwojową, której zaprezentowanie będzie również formą zaliczenia seminarium.

Trudność będzie zróżnicowana. Przedmiot powinien być przystępny także dla studentów I stopnia (od trzeciego semestru).

---

* AAAI proceedings [<https://www.aaai.org/Library/conferences-library.php>]
* IJCAI proceedings [<https://www.ijcai.org/past_proceedings>]
* ECAI proceedings [<https://www.eurai.org/library/ECAI_proceedings>]
* CIG proceedings [<http://www.ieee-cig.org/proceedings>]

Proszę patrzeć głównie na działy Game Playing oraz Game Theory z ostatnich lat."
Seminar: Algebraic effects,3,,,False,False,"Programming with algebraic effects and handlers is a novel technique of
representing computational effects such as exceptions, mutable state, or
nondeterminism, in a modular way, making it possible to program against an
interface, and with a number of different effects simultaneously, which is
where the more traditional monadic approach often falls short. Effects and
their handlers are rapidly making their way into practical programming, in the
form of dedicated languages (e.g., Eff and Koka), extensions of existing
languages (e.g., OCaml) and libraries.

In this seminar we are going to read a collection of recent research papers on
algebraic effects, identify future research directions in this area and
discuss the design and implementation of a prototypical programming language
supporting algebraic effects, implemented lately by Piotr Polesiuk, a PhD
student at our Institute.

**Literatura:**

  1. Andrej Bauer and Matija Pretnar. An effect system for algebraic effects and handlers _._ LMCS, 2014.
  2. Andrej Bauer and Matija Pretnar. Programming with algebraic effects and handlers. Journal of Logic and Algebraic Methods in Programming, 2015.
  3. Dariusz Biernacki, Maciej Piróg, Piotr Polesiuk, and Filip Sieczkowski. Handle with Care: Relational Interpretation of Algebraic Effects and Handlers. POPL, 2018 _._
  4. Yannick Forster, Ohad Kammar, Sam Lindley, Matija Pretnar. On the expressive power of user-defined effects: effect handlers, monadic reflection, delimited control. ICFP, 2017.
  5. Daniel Hillerström and Sam Lindley. Liberating effects with rows and handlers. TyDe@ICFP, 2016.
  6. Daniel Hillerström, Sam Lindley, Robert Atkey, and K. C. Sivaramakrishnan. Continuation passing style for effect handlers. FSCD, 2017.
  7. Ohad Kammar, Sam Lindley, and Nicolas Oury. Handlers in action. ICFP, 2013.
  8. Oleg Kiselyov and Kc Sivaramakrishnan. 2016. Eff directly in OCaml. Workshop on ML, 2016.
  9. Daan Leijen. Type directed compilation of row-typed algebraic effects. POPL, 2017.
  10. Sam Lindley, Conor McBride, and Craig McLaughlin. Do be do be do. POPL, 2017.
  11. Matija Pretnar. An introduction to algebraic effects and handlers. Invited tutorial paper. MFPS, 2015.
  12. Amr Hany Saleh, Georgios Karachalias, Matija Pretnar, Tom Schrijvers. Explicit Effect Subtyping. ESOP, 2018."
Course: Graph databases,3,,,False,False,"**The course will be held in the first half of the semester.**

The main topic of the course is the graph database engine Neo4j and its query
language CYPHER. During the labs we are going to query various interesting
graph data collections available (e.g., Paradise papers, Russian trolls).

Addtionaly, we can spend some time on RDF & SPARQL (see [Wikidata Query
Service](https://query.wikidata.org/)), Apache TinkerPop & Gremlin, Spark and
GraphX/GraphFrames.

**Links:**

<https://query.wikidata.org/>

<https://neo4j.com/developer/cypher-query-language/>

<https://jena.apache.org/tutorials/sparql.html>

<https://tinkerpop.apache.org/>

<https://spark.apache.org/docs/latest/quick-start.html>

<http://spark.apache.org/docs/latest/graphx-programming-guide.html>

**Requirements:** the general engineering culture."
53m1n4r1um dl4 h4k3r0w,3,,,False,False,"Seminarium jest przeznaczone przede wszystkim dla studentów, którzy biorą lub
zamierzają brać udział w zawodach informatycznych dotyczących bezpieczeństwa
komputerowego, takich jak [Capture the Flag](https://ctftime.org/). Na
zajęciach zostaną przedstawione popularne podatności oraz różne techniki ich
wykorzystywania do przełamywania zabezpieczeń, np.:

  * SQL Injection,
  * XSS Injection,
  * Buffer overflow,
  * Heap overflow i inne.

W referatach będą też omówione m.in.:

  * _Data Forensics_ , w tym wydobywanie ukrytych danych i metadanych z plików,
  * proste techniki _antydebug_ i ich omijanie,
  * mniej znane protokoły i ich podatności,
  * obsługa narzędzi do analizy kodu i _reverse engineering_ , takich jak Radare2, IDA, pgd-peda/pwndbg itp.,
  * ataki na protokoły kryptograficzne ( _hash length extension_ , _oracle padding_ , kryptoanaliza RSA z krótkim kluczem lub z ukrytą podatnością itp.).

W trakcie zajęć będzie także czas na wymianę praktycznych doświadczeń z
uczestnictwa w zawodach CTF, omówienie technik radzenia sobie z zadaniami i
pokazy rozwiązywania zadań na żywo.

Nie sposób przewidzieć, jakie nowe wielkie podatności wstrząsną światem
cyberbezpieczeństwa w najbliższym półroczu, ale na zajęciach na pewno będziemy
też analizować najważniejsze bieżące wydarzenia.

Wybrane seminaria będą miały formę warsztatów, podczas których słuchacze będą
mogli samodzielnie sprawdzać na komputerach techniki omawiane przez
prelegenta. Dlatego zaleca się uczestnikom seminarium, aby przynosili na
zajęcia własne laptopy.

Pomysłodawcą przedmiotu i autorem powyższego opisu jest instytutowa drużyna
CTF.

"
Seminar: Category theory and programming languages,3,,,False,False,
Seminarium: Silnik Unity i wirtualna rzeczywistość,3,,,False,False,"Seminarium będzie obejmować zaawansowane aspekty programowania w silniku
Unity.

Każdy ze studentów przygotuje godzinny wykład na jeden z tematów np:

\- oświetlenia

\- modelowania, teksturowania i importu assetów

\- animacji

\- materiałów (w tym Physically Based Shading materials)

\- shaderów

\- testowania (w tym testów automatycznych)

\- skryptów c#, i łączenia z głównym silnikiem

\- system kontroli wersji

\- multiplayer

\- AI agents

\- rodzajów renderingu (forward, deffered) i efektów post process (np. bloom)

\- Screen space ambient occlusion, Screen space reflections

\- Shader graph

\- Visual Effect Graph

Seminarium jest połączone z przedmiotem:

""Projekt zespołowy: silnik Unity3D i wirtualna rzeczywistość LATO"" i

zakończy się jednym dużym projektem gry na platformę HTC VIVE, która być może
umieścimy na platformie Steam.

Drugą godzinę seminarium poświęcimy na scrum'owe spotkanie w celu omawiania
postępów w grze.

Gra z poprzedniego roku:

[Egg teacher VR trailer (HTC Vive)](https://youtu.be/0twMMDEfiL8)

i poprzednia:

[CorveeVR - The First Million](https://youtu.be/kEafTtTls6I)

Sugerowane przygotowanie:

\- programowanie w c#

\- podstawowa znajomość Visual Studio

\- podstawowa znajomość Blendera, SketchUp'a (lub innego programu do
modelowania 3d)

\- podstawy grafiki komputerowej

\- język angielski umożliwiający zrozumienie materiałów i tutoriali"
Projekt zespołowy: silnik Unity3D i wirtualna rzeczywistość LATO,4,"* projekt programistyczny
* pracownia programistyczna
* prezentacja
* dyskusja
* konsultowanie pomysłów na rozwiązywanie zadań programistycznych
* samodzielna praca przy komputerze
* grupowy projekt programistyczny",,False,False,"Kontynuacja kursu programowania gier w silniku Unity3D, tym razem jako projekt
zespołowy.

Dla osób znających Unity3D poprzedni przedmiot nie jest wymagany.

Studenci tworzą 4-7 osobowe grupy które pracują nad własną grą. Przynajmniej
jedna z gier jest pisana pod system wirtualnej rzeczywistości HTC VIVE.

Na części seminaryjnej studenci przedstawiają godzinny wykład na temat
zaawansowanych aspektów Unity, druga godzina przeznaczona jest na spotkanie
Scrumowe na którym analizowany jest aktualny postęp prac nad grą oraz
przydzielane są nowe zadania.

Na pracowni piszemy grę oraz testujemy ją na HTC VIVE.

Gra z poprzedniego roku (wydana na Stream):

[Egg teacher VR trailer (HTC Vive)](https://youtu.be/0twMMDEfiL8)

i poprzednia:

[CorveeVR - The First Million](https://youtu.be/kEafTtTls6I)"
Program interaction: bisimulation and coinduction,3,"student presentation, discussion, problem solving",,False,False,"This seminar is an introduction to bisimulation and coinduction - techniques for reasoning about, possibly infinite, computing processes that interact with other processes and/or the environment in which they are run. The goal of the seminar is to familiarize the students with the mathematical foundations of bisimulation and coinduction, and to present their applications in various areas, including the semantics of infinite data structures (e.g., streams) and the theory of program equivalence in sequential languages (e.g., the Lambda-Calculus) as well as the theory of concurrent (mobile) communicating processes (e.g., CCS, the Pi-Calculus)."
Project: Digital Experience & Internet of Things,4,,,False,False,"Celem przedmiotu jest utworzenie kompletnego rozwiązania wspierającego pewne dobrze określone oczekiwanie biznesowe. Rozwiązanie powinno być oparte o wybrane technologie związane z Internetem rzeczy oraz o dodatkowe technologie jak EDGE computing, machine learning czy analiza danych i raportowanie. Dokładny zakres wybranych technologii, jak i scenariusz biznesowy będzie zależał od doświadczeń i umiejętności zapisanych studentów.

Same zajęcia będą przebiegały zgodnie z następującymi zasadami:
- Studenci będą pracować w grupach 3-5 osobowych wg. uzgodnionej metodyki zwinnej (preferowany będzie SCRUM)
- W każdej grupie zostaną przypisane odpowiednie role zgodne z wybraną metodyką
- Do pracy w grupie będą wykorzystane odpowiednie narzędzia w chmurze (np. Azure DevOps), dające oczekiwaną elastyczność i transparentność
- Podział prac w zespole powinien być w miarę równomierny i jedna z ról w zespole będzie za to odpowiedzialna
- Niektóre wybrane zajęcia będą miały charakter seminaryjny, na których wybrane osoby przedstawią zagadnienie oraz Proof of Concept (PoC) fragmentu niezbędnego do realizacji całości
- W określonym harmonogramie zespół będzie miał za zadanie zaprezentować bieżący postęp prac w postaci działającego fragmentu rozwiązania (demo). Szczegóły będą uzgodnione na pierwszych zajęciach.

Wybrane projekt(y) będą mogłyby być zarówno charakter bardziej inżynieryjny prowadzący do jasno określonego lub też bardziej badawczy mający na celu weryfikację kilku wariantów i przedstawienia dobrze umotywowanej rekomendacji. Istnieje potencjalna możliwość zdefiniowania oczekiwania biznesowego związanego z realnymi potrzebami z sektora automotive.

W ramach zajęć planowana jest współpraca z firmą NOKIA i potencjalne wykorzystanie platformy NOKIA Impact, chociaż nie będzie to obligatoryjne.

**Wymagania:**
Ogólne obycie z technologiami wykorzystanych do tworzenia rozwiązań WWW, bardzo pomocna, choć nie jest wymagana, będzie znajomość co najmniej jednej z: Internet of Things, Cloud Computing, EDGE Computing, Machine Learning, Data Analytics, Domain Driven Design, Software Architecture."
Artificial intelligence. Seminar,3,,,False,False,"Seminarium będzie rozwinięciem pewnych wątków przedmiotu Sztuczna inteligencja, w szczególności zagadnienia uczenia ze wzmocnieniem, dowodzenia twierdzeń, sieci Bayesowskich, rozwiązywania więzów. Niektóre tematy wystąpień będą prezentacją klasycznych wyników, ale pojawią się rówwnież tematy nawiązyjące do obecnych badań naukowych z tej dziedziny.
W przypadku, gdy na seminarium zapisze się osoba nie mówiąca po polsku, wówczas zajęcia będą prowadzone w języku angielskim."
Information and Coding Theory,3,"Wykład, prezentacja, rozwiązywanie zadań z prezentowaniem, dyskusja.",,False,False,"Teoria informacji bada zagadnienia takie jak: mierzenie ilości informacji w ciągu danych, ograniczenia na przetwarzanie danych czy ograniczenia komunikacji. Teoria informacji powstała by odpowiedź na pytania takie jak: jaki jest optymalny kompresor dla danego typu danych, albo jak szybko możemy przesyłać informacje przez kanał komunikacji.

Przedmiot zaczniemy od przedstawienia klasycznych zagadnień teorii informacji. Następnie skupimy się na zastosowaniu tych zagadnień: pokażemy dolne i górne granice dla kompresji danych, co więcej pokażemy, że wiele współcześnie stosowanych metod kompresji, pomimo faktu, że wydają się tylko heurystykami, ma teoretyczne podstawy (omówimy zarówno bezstratne jak i stratne algorytmy).
Oprócz klasycznych wyników pokażemy też te bardziej współczesne, np. jak teoria informacji pomaga uzyskać dolne granice dla uczenia maszynowego.

Wykład prowadzony będzie przez pierwszą połowę semestru.

Przedmiot jest niezależny (i rozłączny) od przedmiotu Kompresja Danych i można zaliczać oba przedmioty jednocześnie. W porównaniu do Kompresji Danych ten przedmiot jest nastawiony w o wiele większym stopniu na aspekty teoretyczne, np. gdy Kompresja Danych przedstawia szereg algorytmów kompresji i daje intuicje dlaczego działają, my pokażemy twierdzenia mówiące o skuteczności niektórych z nich.

###### Zagadnienia:
- Miary informacji: entropia, dywergencja, informacja wspólna, łańcuchy Markova, nierówność przetwarzania danych
- Kompresja bezstratna: kody o zmiennej długości, źródła ergodyczne, kodowanie uniwersalne
- Kompresja stratna: kompresja dźwięku i obrazu, transformata Karhunen–Loève, dyskretna transformata kosinusowa (DCT)
- Przepustowość kanałów komunikacji: twierdzenie Shannona–Hartley'a
- Inne zastosowania teorii informacji: uczenie maszynowe, generatory pseudolosowe

###### Wymagania wstępne:
Rachunek prawdopodobieństwa, Algebra

###### Literatura:
Thomas M. Cover, Joy A. Thomas, Elements of Information Theory. Wiley Series in Telecommunications, 1991.

Gareth A. Jones, Mary J. Jones, Information and Coding Theory. Springer, 2000.

David Salomon, Data Compression: The Complete Reference, Springer, 1998

Przedmiot będzie realizował część materiału z kursów innych uczelni, np.:
[Stanford](https://web.stanford.edu/class/ee376a/outline.html)
[MIT](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-441-information-theory-spring-2016/lecture-notes/index.htm)
[UChicago](https://ttic.uchicago.edu/~madhurt/courses/infotheory2017/index.html)"
Half-semester course: Quantum algorithms,3,"Wykład, ćwiczenia",,False,False,"**Przedmiot prowadzony w drugiej połowie semestru wiosennego**

Algorytmy kwantowe, takie jak Algorytm Shora funkcjonują wśród informatyków raczej jako hasło, niż konkretna wiedza. Na tym przedmiocie spróbujemy wyjaśnić, co się&nbsp;za tym hasłem kryje i jak informatycy do tego doszli.

Przedmiot nie wymaga rozumienia fizyki, prowadzący również jej nie rozumie i wprowadzi tylko tyle, ile informatyka wymaga.

Przedmiot ten może być interesujący dla ambitnych studentów pierwszego roku, którzy chcieliby posmakować zaawansowanego kursu teoretycznego i uważali na pierwszej połowie kursu z Algebry."
Seminar: Selected topics in proof theory,3,"wykład, prezentacja",,False,False,"Celem przedmiotu jest omówienie wybranych zagadnień związanych z pojęciem dowodu jako obiektu matematycznego, który ma precyzyjnie określoną strukturę i którego własności możemy formalnie opisywać. Elementy teorii dowodu pojawiały się już przy innych okazjach, m. in. w związku z wnioskowaniem w logice konstruktywnej i izomorfizmem Curry'ego-Howarda.

Seminarium będzie obejmowało wykłady wprowadzające, prezentacje studentów oraz część praktyczną.

Najważniejsze zagadnienia:
1. Formalne systemy wnioskowania i ich własności. Dedukcja naturalna, rachunek sekwentów, system Hilberta dla logiki intuicjonistycznej.
2. Normalizacja dowodów.
3. Systemy wnioskowania dla logiki klasycznej i logik pośrednich.
4. Translacje pomiędzy systemami logicznymi.
5. Problem automatycznego znajdowania dowodów w systemach logicznych."
Scheduling Theory,6,"* lecture, including interactive lecture
* supervised and unsupervised problem solving, both individual and collective
* discussions",,False,False,"There is a plethora of job scheduling problems, whose common denominator is that there is a given set of jobs (with various parameters) and a number of machines that they have to be scheduled on so that a certain objective function is optimized.  The jobs have several parameters, such as processing times (or sizes), release times, weights that capture their importance, and, in some variants, deadlines.
 A few examples were studied in the Algorithms and Data Structures course, but these were relatively simple.  Most scheduling problems, particularly when more than one machine is available, are computationally hard, so we will typically consider approximation.

Sometimes we will restrict our attention to online algorithms, which seem particularly well suited to real life scheduling problems.  In particular, we might study nonclairvoyant scheduling, where on top of not knowing the jobs that will arrive later in time, the scheduler does not know the size (processing time) of each available job until it is processed till completion.  We may or may not touch upon stochastic scheduling, where the actual size of a job is a random variable whose distribution is known.

We will survey fundamental scheduling problems.  This means that we will consider:
* different objective functions, such as
 * maximum (weighted) completion time,
 * average/total (weighted) completion time,
 * maximum (weighted) flow time,
 * average/total (weighted) flow time,
 * maximum (weighted) tardiness,
 * average/total (weighted) tardiness, 
 * (weighted) throughput
 * maximum lateness / ""feasibility""
 * total energy consumption
* different machine setups:
 * single machine
 * identical machines (notice that their number may or may not be part of the input, which may affect computational complexity)
 * related machines (i.e., machines of different speeds)
 * unrelated machines (think different processor architectures, suitable to particular tasks: in general, each job specifies how much time it would take to complete it on each of the machines 
* different notions of preemption:
 * in non-preemptive scheduling, a job that is being processed has to be run until completion
 * in preemptive scheduling, the job can be stopped and resumed at any later time (there is also a variant ``with restarts'', only relevant in the online setting, where the renewed processing has to start from scratch); one may still distinguish between
   * non-migratory scheduling, where the job can be resumed only on the one machine it was assigned to before
   * migratory scheduling, where the job can be resumed at any of the available machines

The list goes on, and one might impose various constraints on job parameters, so clearly there is a huge number of problems.  To get a grip on them, we will also learn the basics of the four-field scheduling notation, and realize it is actually useful sometimes (see _scheduling zoo_ in the Literature)

**Some important points**

1. In case of interest, we might devote part of the curriculum to major open problems in the field.
2. This would be the very first edition of the course, so expect some glitches and possibly part-time seminar form, especially if there is interest in that.
3. The course can be taught in either English or Polish, though I have a preference for the former --- the literature is mostly available in English only; in particular, coming up with Polish terminology (even for aforementioned objective functions) might prove difficult.

### Prerequisites

You should be comfortable with designing algorithms for combinatorial optimization problems, proving their correctness, and analyzing complexity.  Some elementary knowledge of calculus, NP-hardness, approximation algorithms (incl. linear programming), online algorithms, and probability theory is required.

It is thus advised  --- but not necessary if you are motivated to learn the basics on your own --- that you have completed each of the following courses:

*  Discrete Mathematics
*  Algorithms and Data Structures
*  Formal Languages and Computational Complexity
*  Approximation Algorithms
*  Online Algorithms

### Literature

The core of our literature will be a number of seminal articles, which I will not list here.  I should point out though that:

1. http://schedulingzoo.lip6.fr/ is an excellent search engine to determine the status of a scheduling problem, at least its offline complexity.
2. Some of the standard topics are covered in the textbooks on _online algorithms_ by Borodin and El-Yaniv, on _approximation algorithms_ by Davidson and Schmoys, and, to a lesser extent, by Vazirani.
3. There is a number of handbooks of scheduling, which may or may not prove useful --- these are typically overwhelming at close to a thousand pages, and the topic selection seems arbitrary"
Workshop on Deep Learning,4,,,False,False,"Zajęcia będą miały formę praktycznych warsztatów prowadzonych przez doświadczonych pracowników firm: AlphaMoon, EY, MicroscopeIT, NeuroSys i Tooploox.

Tematy poruszane na warsztatach to, m.in.:
* wprowadzenie do ML/DL (ang. deep learning) (4 spotkania)
 * framework Tensorflow
 * sieci neronowe typu MLP i CNN
 * przetwarzanie obrazów, 
* DL w NLP
* Semantic i instance segmentation 2D, autonomiczne pojazdy
* U-Net 3D w obrazowaniu medycznym
* wprowadzenie do reinforcement learning (RL), Q-Learning
* Deep Q-Learning, przykłady w gym od OpenAI

Spotkania będą odbywały się co tydzień.
Planowane zajęcia będą zawierały zarówno część teoretyczną (w formie wykładu), jak i praktyczną (np. do rozwiązania/uzupełnienia kodu w notatniku Google Colab).

Warsztaty mają charakter otwarty. Można w nich uczestniczyć bez konieczności zapisywania się w systemie zapisy.ii.uni.wroc.pl.

Natomiast, osoby ""zapisane"" na ten przedmiot będą oceniane na podstawie realizacji dwóch projektów programistycznych.

Rozmiar grupy w systemie ""Zapisy"" zostanie ograniczony do max. 10 osób."
Seminar: Data Mining - Data Classification and Clustering,3,,,False,False,"_**UWAGA**: W przypadku takiej konieczności, w roku akademickim 2020/21 zajęcia mogą być prowadzone zdalnie przez Google Meet lub podobne narzędzie interaktywnej komunikacji._

Seminarium będzie poświęcone dwóm popularnym zagadnieniom eksploracji danych:
klasyfikacji i grupowaniu danych. Stanowią one podstawy wielu systemów
ekspertowych, systemów klasyfikacji i rozpoznawania obiektów czy systemów
wspomagania decyzji. Celem seminarium będzie omówienie podstawowych algorytmów
tej dziedziny, ich współczesnych zastosowań w praktyce oraz istniejących
narzędzi umożliwiających klasyfikację i grupowanie."
Programming Project: Online Judge System,4,,,False,False,"Projekt zakłada:

* interfejs webowy, backend w Python z użyciem frameworka Flask, komunikacją z bazą danych SQL z użyciem ORM SQLAlchemy, biblioteką Babel do obsługi wielu języków i paru innych bibliotek, frontend Javascript, Bootstrap etc.
* dość skomplikowany interfejs CLI ułatwiający przygotowywanie nowych zadań lub importowanie starych z różnych źródeł,
* sandbox napisany w C,
* moduły sprawdzania - kombinacja C++ i Python + serwer rozdzielający pracę pomiędzy kilka maszyn,
* kilka pomniejszych narzędzi pobocznych dla użytkowników,
* przygotowanie narzędzi pozwalających na zarządzanie kodem, deployment, zarządzanie sprawdzaniem etc.

Studenci w mniejszych zespołach (2-4 osoby) pracują nad małymi projektami (wybranym fragmentem systemu np. drzewo konkursów, uprawnienia użytkowników, ranking) i co tydzień prezentują progres w pracach. Projekty mają być krótsze niż cały semestr, więc każdy powinien być częścią kilku zespołów i wykonać kilka projektów.

Na pierwszych zajęciach zaprezentujemy planowaną architekturę systemu, listę projektów oraz architekturę bieżącego systemu (Solve 3) i problemy z nim związane.

Zainteresowanym doradzam przejrzeć tutorial:
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world"
Data Mining,6,"wykład, prezentacja, dyskusja, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań, indywidualny/zespołowy projekt programistyczny, samodzielna praca przy komputerze",,False,False,"Systemy informatyczne stosowane są do przetwarzania coraz większej ilości
danych dostarczanych codziennie przez przemysł, handel, urzędy statystyczne
czy administrację państwową. W związku z tym coraz częściej dostrzegalna jest
różnica między daną a informacją - mimo dużej ilości dostępnych danych,
nierzadko pojawiają się problemy z uzyskaniem konkretnych informacji w nich
zawartych.

Eksploracja danych (ang. data mining) jest nowoczesną dziedziną informatyki,
rozwijaną dynamicznie w ostatnich latach w ośrodkach naukowych na całym
świecie, której celem jest dostarczanie algorytmów i technik przetwarzania
danych umożliwiających pozyskiwanie nietrywialnej wiedzy ze zgromadzonych
dużych ilości danych. Metody eksploracji danych opierają się głównie na
sztucznej inteligencji i statystyce obliczeniowej.

Wykład będzie dotyczyć popularnych algorytmów eksploracji danych, zarówno dla
klasycznych zagadnień, takich jak klasyfikacja przy użyciu drzew decyzyjnych
lub konstrukcja reguł asocjacyjnych, jak i nowoczesnych związanych z systemami
rekomendującymi czy systemami wspomagania decyzji.

### Program (program)

  * wprowadzenie do eksploracji danych
  * zagadnienia grupowania i klasyfikacji danych
  * podstawowe algorytmy grupowania danych numerycznych
  * klasyfikacja danych przy użyciu drzew decyzyjnych
  * klasyfikacja danych numerycznych
  * konstrukcja reguł asocjacyjnych
  * zagadnienie prognozowania szeregów czasowych
  * zagadnienia przetwarzania danych tekstowych
  * systemy rekomendujące
  * systemy wspomagania decyzji"
Java course,5,"Wykład, live coding, analiza programów dostarczonych przez wykładowcę, konsultowanie pomysłów na rozwiązania zadań, samodzielna praca programistyczna w domu oraz na zajęciach.",,False,False,"**Java** to potężny współczesny obiektowy język programowania, wyposażony w olbrzymią ilość dobrze udokumentowanych bibliotek i wiele technologi wspomagających sprawne i szybkie tworzenie aplikacji.
Prace nad tym językiem rozpoczęły się w 1991 roku 
w firmie Sun Microsystems pod kierownictwem Jamesa Goslinga. 
Pierwsza wersja tego języka wraz z kompilatorem i platformą uruchomieniową JVM została jednak wypuszczona na rynek dopiero w 1996 roku. 
Od momentu powstania Javy język ten przeżył bardzo dynamiczny rozwój a zainteresowanie nim bardzo duże. 
W roku 2010 Javę wraz z firmą Sun przejęła firma Oracle, która intensywnie inwestuje w rozwój języka i narzędzi, które go wykorzystują do tworzenia nowych aplikacji.

Język Java przyciągnął wiele milionów programistów. 
Znajduje zastosowanie w każdej ważniejszej gałęzi przemysłu IT i jest obecny w różnego rodzaju urządzeniach, komputerach i sieciach. 
Popularność Javy wynika przede wszystkim z przenośności programów i niezależności od konkretnej platformy sprzętowej, a co za tym idzie, ma zastosowanie w Internecie oraz ogólnie w aplikacjach sieciowych. 
Jego podstawowe koncepcje zostały przejęte z języka Smalltalk (maszyna wirtualna, odśmiecanie pamięci) oraz z języka C++ (znaczna część składni i słów kluczowych). 

Kurs Javy jest poświęcony nauce programowania obiektowego w Javie.
Jest to język prosty, precyzyjnie zdefiniowany, wyposażony w obszerny i dobrze udokumentowany zestaw bibliotek. 
Najważniejsze pakiety są omawiane na wykładzie; jest to jednak tylko przysłowiowy ""wierzchołek góry lodowej"". 
Ten nowoczesny język programowania znajduje
zastosowanie w różnych technologiach webowych, sieciowych, bazodanowych czy wreszcie w aplikacjach biznesowych, ale te zagadnienia są omawiane na następnych kursach poświęconych Javie."
Data Compression,6,"Wykład, prezentacja, rozwiązywanie zadań z komentowaniem, dyskusja, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze, indywidualne zadanie programistyczne",,False,False,"Celem przedmiotu jest zaprezentowanie podstawowych metod bezstratnej i stratnej kompresji danych. Prezentacji poszczególnych metod towarzyszyć będzie omówienie i porównanie ich efektywności, zastosowań, wykorzystujących je standardów. Przy analizie metod bezstratnych zaprezentowane zostaną niezbędne podstawy teorii informacji i ich konsekwencje dla oceny jakości poszczególnych metod. Omówione zostaną zagadnienia stratnej kompresji danych ""multimedialnych"".
    
Poruszane też będą kwestie efektywnej implementacji prezentowanych algorytmów.
    
W ramach przedmiotu omawiane będą następujące zagadnienia:
      
1. Modelowanie danych, podstawowe pojęcia teorii informacji i kodowania, kody Shannona-Fano.
2. Kody Huffmana, dynamiczne kody Huffmana.

3. Kodowanie arytmetyczne, standard JBIG.

4. Metody słownikowe (LZ77, LZ78) i ich niektóre zastosowania (GIF, TIFF, dane przesylane faksem).

5. Kompresja gramatykowa (Sequitur, Sequential, aproksymacja gramatyki optymalnej).

6. Kodowanie predykcyjne (ppm, kodowanie Burrowsa-Wheelera, JPEG-LS)
    
7. Kwantyzacja skalarna i wektorowa.
    
8. Stratne metody kompresji i ich zastosowanie w kompresji obrazów i dźwięku: kodowanie różnicowe (DPCM), kodowanie transformujące (np. JPEG), kodowanie podpasmowe (kodowanie dźwięku MPEG), kompresja falkowa (JPEG2000).

9. Kompresja wideo."
History of Philosophy (w),3,,,False,False,"_W przypadku konieczności prowadzenia zajęć zdalnie, ten przedmiot będzie prowadzony przez MS Teams._


Tematy, problematyka i materiały na zajęcia z informatyki, w rok. akadem.
2018-2019, sem. letni.

Zakładane efekty kształcenia: student wykazuje się znajomością podstawowych
problemów z filozofii w proponowanym zakresie; relacji między filozofią a
nauką oraz między różnymi typami wiedzy naukowej, w stopniu umożliwiającym
interdyscyplinarny ogląd nauki. Zna i prawidłowo stosuje podstawową
terminologię filozoficzną (metodologiczną, logiczną itp.). Potrafi przedstawić
podstawowe zagadnienia z zakresu logiki i filozofii języka, szczególnie w
kontekście wiedzy naukowej; rozumie znaczenie i wpływ języka na procesy i
efekty poznawcze oraz mechanizmy budowania wiedzy naukowej. Zna i rozumie
historyczny kontekst, historyczne uwarunkowania dla omawianej problematyki.

Wykłady

30 godz., 15 spotkań

Dr Zbigniew Pietrzak – Instytut Filozofii WNS.

  1. Wprowadzenie: filozofia – dziedziny filozofii i przedmiot filozofii, min. pytanie o _arche_ – filozofia Jońska, Pitagorejczycy (liczba); głównie zagadnienia współczesne.
  2. Filozofia i historia nauki. Problem demarkacji nauki – nauka, pseudonauka, protonauka. Metodologiczne typy nauk: nomotetyczne, idiograficzne, formalne.
  3. Struktura nauki – prawa, teorie, związki między nimi.
  4. Filozofia i historia nauk przyrodniczych – filozofia naturalna, historia naturalna/historia natury, współczesne przyrodoznawstwo.
  5. Filozofia i historia nauk formalnych.
  6. Kryzys w nauce, kryzys w filozofii: źródła i konsekwencje (metodologiczne, heurystyczne, pojęciowe, strukturalne, społeczne itp.). Sprzeczności jako źródło kryzysu.
  7. Nabywanie języka – pogląd naturalistyczny i analityczny/metafizyczny.
  8. Język i poznanie - struktura i gramatyka w językach naturalnych.
  9. Język i poznanie - język a rzeczywistość.
  10. Język w nauce – kształtowanie pojęć, redefinicje. Od języka potocznego do języka sformalizowanego. Język jakościowy – język ilościowy.
  11. Język a rzeczywistość w nauce: realność i konwencjonalność pojęć. Realizm i antyrealizm w nauce; psychologizm i antypsychologizm.
  12. Problemy ontologiczne w informatyce – ontologia symbolu itp.
  13. Ewolucja umysłu – ewolucja wiedzy.
  14. Sztuczna inteligencja – perspektywy: biologii ewolucyjnej, filozofii umysłu (teorie umysłu), lingwistyczna (język), neuronauk.
  15. Podsumowanie.

Egzamin.

Literatura – szczegółowy wykaz tytułów zostanie przedstawiony na zajęciach.
(Szczegółowy plan tematów może jeszcze ulec modyfikacjom).

Ćwiczenia

30 godz., 15 spotkań

Dr Marcin Łazarz – Katedra Logiki i Metodologii Nauki WNS.

1-2. Liczba jako _arche_. Arytmetyzacja nauk (Platon, Pitagorejczycy).
Pitagorejska teoria liczb, punktualizm i odkrycie niewymierności. Liczby
naturalne, wymierne, rzeczywiste. Historia pojęcia ciągłości a jego pierwsza
poprawna definicja. Paradoksy Zenona z Elei i zagadnienie nieskończonych sum
liczbowych (szeregów).

3-4. Indukcjonizm i hipotetyzm. Poglądy Bacona i Kartezjusza w kwestii co jest
wartościową wiedzą i jak ją zdobywać. Metody naukowe.

  5. Prawda. Klasyczna definicja prawdy (Arystoteles, Platon) i nieklasyczne definicje prawdy: kartezjańska i koherencyjna definicja prawdy.
  6. Kryzys podstaw matematyki. Ufundowanie matematyki. Paradoksy teorii mnogości. Formalizm logicyzm i konstruktywizm. Logika intuicjonistyczna. Niekonstruktywne prawa logiki klasycznej. Konstruktywne dowody.
  7. Język nauk formalnych. Język pierwszego rzędu. Metoda aksjomatyczno-dedukcyjna (Platon, Euklides). Teorie aksjomatyczne.

8-9. Definicja prawdy Tarskiego. Znaczenie i model. Środki syntaktyczne i
środki semantyczne. Twierdzenie o pełności dla logiki predykatów. Modele
zamierzone.

10-11.Niesprzeczność i rozstrzygalność. Program Hilberta. Teorie niesprzeczne
i zupełne. Niezupełność. Hipoteza continuum. Twierdzenie Gödla o niezupełności
arytmetyki Peano.

  12. Umysł – teorie umysłu.

13-14. Sztuczna inteligencja.

  15. Zaliczenia.

Zaliczenie na ocenę.

Literatura – szczegółowy wykaz tytułów zostanie przedstawiony na zajęciach.
(Szczegółowy plan tematów może jeszcze ulec modyfikacjom).

Przygotował

Zbigniew Pietrzak

Instytut Filozofii WNS"
Data Science@Nokia,3,,,False,False,
Logic for Computer Science,8,"* Ćwiczenia audytoryjne
* Wykład",,False,True,"**Program:**

  1. Zasada indukcji.
  2. Składnia i semantyka rachunku zdań i rachunku predykatów. Pojęcie spełniania i prawdziwości formuł. Niesprzeczność zbioru formuł.
  3. Podstawowe pojęcia teoriomnogościowe i operacje na zbiorach: suma, iloczyn, iloczyn kartezjański, zbiór potęgowy, relacje, funkcje, relacje równoważności, klasy abstrakcji, zbiór ilorazowy.
  4. Moce zbiorów. Zbiory skończone i nieskończone. Zbiory przeliczalne i zbiory mocy continuum. Twierdzenia Cantora i Cantora-Bernsteina.
  5. Porządki częściowe i liniowe. Dobre porządki. Indukcja noetherowska.
  6. Unifikacja termów. Informacja o metodzie rezolucji.
  7. Dowodzenie twierdzeń. Informacja o systemie naturalnej dedukcji.

**Wymagania:** Matematyka w zakresie szkoły średniej"
Seminar on Systems,3,,,False,False,"Rozejrzyj się wokół siebie okiem informatyka. Stajemy się stopniowo
,,włączkami'' do Systemu. (Niektórzy już się stali). I nie są tylko to moje przewidywania i straszenie
sprzed lat. To zjawisko potwierdzają obecnie inni, fachowi
obserwatorzy. Z drugiej strony spróbujmy [dziś] żyć bez systemów!... Te dwa
spostrzeżenia wyznaczają ramy referatów, które studenci mogą przygotowywać na
seminarium z systemów — ramy praktycznie bez granic. Liczy się sposób prezentacji,
własny wkład studenta w temat, twórcze spojrzenie na wybrany system i zdolność
wnioskowania o skutkach jego rozwoju lub zaniechania.

W szczególności referaty studentów mogą dotyczyć sześciu ,,przestrzeni
informatycznych'' odpowiadających sześciu niedawno przetłumaczonym książkom
przez proponującego to seminarium. Ujmując swobodnie:

Algorytmy na sposób inżynierski

Git, czyli jeszcze jeden system rozproszony

Wielkie dane — z czym to się je

Co ma algebra abstrakcyjna do biblioteki STL C++

Jak działa oprogramowanie: czy na pewno wiemy? A jeśli nawet, to jak to
wyjaśnić profanom?

Internet rzeczy — konsekwencja i konieczność rozwoju czy techniczno-
ekonomiczna fanaberia?

Bezpieczeństwo systemów informatycznych, czyli jak żyć, dopóki wystarcza prądu

Systemy operacyjne — kopalnia tematów bez dna 

**Wymagania:** otwarta głowa, ciekawość świata. A dokładniej: szerokie
horyzonty myślowe, nieograniczanie się w projekcji zastosowań informatyki do
tych najpopularniejszych. Myślenie kategoriami globalnymi: jakie zmiany
powoduje burzliwy wzrost zastosowań komputerów i sieci? Czego można się
spodziewać za 5 lub 10 lat w związku z tym? Jak Sieć i informatyka oddziałuje
na cywilizację? Czy ludzie stają się dzięki zastosowaniom komputerów
mądrzejsi? Lepsi? Czy...

Osoby stawiające sobie takie i podobne pytania dobrze kandydują do udziału w
,,Seminarium z systemów'' (S2).

**Cele.** Wzbudzanie refleksji dotyczących wpływu postępu technologicznego, a
informatyzacji w szczególności, na ludzkość, losy cywilizacji i świata. W
dobie samochodów-sieci i samochodów w Sieci, Internetu rzeczy, silosów
informacji gromadzonej wszędzie, oprogramowania, nad którego działaniem informatycy zastanawiają się niczym neurolodzy nad tajnikami mózgu — o wszystkim i o wszystkich warto dyskutować na temat
ewentualnych konsekwencji, pozytywów i negatywów rozwoju (a może o potrzebie pewnej stagnacji?). Seminarium nie ma
kształtować postaw ani sądów zdecydowanych i ostatecznych. Ma pobudzić do
myślenia o nas, o ludziach i ich krzemowym dziele. Jeśli przy okazji referenci
wydobędą z Sieci oryginalne, nowe zastosowania informatyki — tym lepiej.
Technologia zmienia się szybko, człowiek znacznie wolniej. Co z tego wynika?
Co wyniknie?

**Możliwa literatura.** Książki tłumaczone przez proponującego seminarium
(por. strona w Wikipedii), nowiny i nowości informatyczne odnajdywane w Sieci,
zarówno stricte techniczne i użytkowe, jak i o charakterze oddziaływania
społecznego i (lub) kulturowego.

**Forma zaliczenia.** Dobrze przygotowany, dobrze wygłoszony i dobrze
udokumentowany, pobudzający do dyskusji referat plus aktywne uczestnictwo w
odbiorze i ocenie innych referatów rokuje dobre zaliczenie.

W trakcie semestru studenci mają wgląd w materiały do wykładów wygłoszonych na
S2 w poprzednich latach, udostępniane na odpowiedniej stronie witryny SKOS.

**Uwaga dotycząca sposobu prowadzenia zajęć.** Praktycznie w każdym przypadku zdalne prowadzenie zajęć stępia i ogranicza proces dydaktyczny, usztywnia dyskusję, niemniej doświadczenie z poprowadzenia tych zajęć w semestrze letnim roku akademickiego 2019-2020  w trybie zdalnym (z konieczności) dowodzi, że mimo tych strat można je poprowadzić zdalnie. Oczywiście to nie to samo, co bezpośrednia wymiana myśli z młodzieżą akademicką w salach Instytutu.  

20-05-04, 20-05-25 zpl..IIUWr"
Designing ASP.NET Web Applications,5,"* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",,False,False,"Podsystem ASP.NET to jedna z bardziej rozbudowanych technologii w ramach .NET
Framework, zasługująca na całosemestralny wykład, dający możliwość poznania
studentom nie tylko technologii ale również patrzenia na nią w kontekście
typowych wzorców aplikacyjnych, występujących czy to w samym ASP.NET czy też
na styku z warstwą dostępu do danych.

Z uwagi na możliwość programowania aplikacji ASP.NET na platformie .NET Core,
technologia ma zastosowanie w dowolnym środowisku serwerowym (w tym na
systemach Linuxowych).

Na pracowni studenci zapoznają się z typowymi problemami występującymi podczas
budowania aplikacji w technologii ASP.NET i uczą się z nimi sobie radzić.

**Program:**

  * architektura serwerów aplikacji
  * protokół HTTP
  * standard HTML5
  * ASP.NET Web.Forms
  * ASP.NET MVC
  * SOAP - ASP.NET WCF
  * REST - ASP.NET WebAPI
  * ASP.NET Core"
Simulation-based Artificial Intelligence,6,"- lecture
- programming assignments with comments
- theoretical+programming team project",,False,False,"Two factors: growing computational power of computers and the rising interest on the problems too complicated to construct a heuristic evaluation function, decided about the recent popularity of simulation-based techniques in Artificial Intelligence.

Although initially they were used as brute-force approaches, with simple algorithms like Flat MC or epsilon-greedy MC, after the introduction of Monte Carlo Tree Search they gained theoretical background and depth enough to handle complicated tasks. With time, more sophisticated usages of simulation-based techniques had been discovered, including heuristic-knowledge variants, specific problem-related variants, and more common usage of simulations as a part of other methods like evolution, reinforcement learning, or deep neural networks.

During this course, we will cover recent advancements in simulation-based AI methods, their successful applications, and their limitations. The course program is based on a selection of publications from the leading AI conferences (AAAI, IJCAI, GECCO) and smaller venues closely related to this topic (MCS IJCAI Workshop, COG).

The participants will have the opportunity to try the theory in practice implementing various simulation-based agents aimed to solve small-to-medium-sized problems. Finally, in groups, their task will be to reproduce and verify the results of a given research paper."
"Algorithmic fairness, or politically correct computer science",3,seminarium,,False,False,"Dane to ty. Algorytm pobiera cię jako wejście a potem mówi że nie dostaniesz kredytu bo mieszkasz w czarnej dzielnicy. Czy jakoś tak. 

No i coś z tym trzeba zrobić. A co zrobić mówią nam uczeni zajmujący się *Algorithmic Fairness*. Napisali o tym, w ostatnich 10 latach, kupę prac. I chciałbym w ramach tego seminarium część z tych prac, oczami uczestników seminarium, przeczytać. Żeby takim całkiem ciemnym nie być.

To się wszystko wiąże z machine learningiem. Ale wstępna lektura prac pokazuje że głębsza kompetencja dotycząca machine learningu nie jest konieczna żeby je czytać (ja w każdym razie nie mam takiej kompetencji)."
Compiler construction,6,"* Projekt programistyczny
* Ćwiczenia audytoryjne
* Wykład",,False,False,"Wykład prowadzony wspólnie przez dwuosobowy zespół: W.Charatonik i P. Polesiuk.

Przekrojowy, ale niezbyt szczegółowy wykład wprowadzający w tematykę kompilacji.

Program:

  * Wstęp [1 wykład]
  * Leksowanie i parsowanie [3 wykłady]
  * Analiza semantyczna [1 wykład]
  * Generowanie kodu [3 wykłady]
  * Analiza programów i optymalizacja kodu [3 wykłady]
  * Wsparcie dla języków wysokopoziomowych [4 wykłady]

W czasie semestru przewidujemy około sześciu niewielkich zadań na pracownię
polegających na doimplementowaniu do przygotowanego szablonu poszczególnych
funkcjonalności kompilatora -- tak, aby pod koniec semestru każdy student
napisał własny kompilator prostego języka imperatywnego. Pracownia będzie
prowadzona w języku OCaml.

Wymagania:

  * Metody programowania (struktura języków programowania, składnia abstrakcyjna i konkretna)
  * Architektury systemów komputerowych (kod trójadresowy, graf kontroli przepływu, tłumaczenie C do kodu maszynowego, ramki stosu, konwencja wywołania procedur, asembler, konsolidacja, relokacja, biblioteki współdzielone, MIPS ISA)

Literatura:

  * Modern Compiler Implementation in ML, Appel
  * Compilers: Principles, Techniques, and Tools, Aho & Ullman
  * Engineering: A Compiler, Cooper & Torczon
  * Advanced Compiler Design and Implementation, Muchnick
  * The Garbage Collection Handbook, Jones"
Seminar: Tricks in C++,3,"* Ćwiczenia audytoryjne
* Projekt eksperymentalno-badawczy",,False,False,"Omówimy różne techniki i sztuczki w C/C++, głównie niestandardowe i związane z wydajnością, a także tematy na czasie związane z używaniem C++.
W programie znajdą się takie rzeczy jak: wydajne (technicznie) i niestandardowe sposoby implementacji kontenerów, podstawowych struktur danych i algorytmów; alternatywy dla używania std; narzędzia i biblioteki (np. gdb, valgrind, kompilatory, boost); C++20/23; różne tematy kontrowersyjne.
Większość tematów będzie bazować na systemie Linux i kompilatorze g++.

Niezbędna jest przynajmniej dobra znajomość C++. Tematy będą rozłączne ze wszystkimi kursami języka i będą one nowe lub odpowiednio rozszerzone w stosunku do edycji seminarium z 2017/2018, dlatego seminarium można zaliczyć ponownie.

Zaliczenie seminarium polega na opracowaniu tematu, co w większości przypadków wymaga napisania implementacji i wykonania eksperymentów, oraz zwyczajowego wygłoszenia prezentacji.

*W przypadku konieczności przeprowadzenia zajęć zdalnie prezentowanie zrobimy online.*"
Natural Language Processing,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",,False,False,"Przetwarzanie języka naturalnego jest dziedziną, w której staramy się zrozumieć, czym jest język naturalny (taki jak polski czy angielski), jak go najlepiej modelować narzędziami matematycznymi bądź informatycznymi oraz tym, jakie praktyczne korzyści można wyciągnąć z tej wiedzy -- czyli jakie zadania związane z językiem da się skutecznie rozwiązywać za pomocą odpowiednich algorytmów.

Język naturalny otacza nas zewsząd. Jest coraz więcej dostępnych tekstów, które badać i pozyskiwać z nich wiedzę o języku, rosną też ciągle oczekiwania rozumienia języka, jakie stawiamy algorytmom. I rzeczywiście w wielu aspektach obserwujemy ciągły wzrost skuteczności działania tych algorytmów (w wielu zadanich algorytmy osiągają sprawność lepszą niż ludzie.

Z drugiej strony wiele zadań z przetwarzania języka uważa się za AI-zupełne (to znaczy, że w pełni satysfakcjonujące ich rozwiązanie wymaga stworzenia pełnej sztucznej inteligencji. Wymienić tu można choćby rozmowę na dowolny temat.
 
Na wykładzie będziemy zajmować się zarówno ""łatwymi"", jak i ""trudnymi"" aspektami języka. Omówimy sposoby modelowania języka (traktowanego jako sekwencje elementów): bazujące na łańcucha Markowa oraz różnych architekturach sieci neuronowych. Poznamy elementy wiedzy lingwistycznej, poznamy sposoby analizy składniowej zdań. 
Dużo uwagi będzie poświęcone sposobami generacji tekstów, spełniających określone warunki. 

Będziemy zajmować się głównie metodami zawierającymi elementy uczenia maszynowego (czyli pozyskiwania wiedzy z danych, którymi są w tej dziedzinie zbiory tekstów, czasem z dodatkowymi anotacjami). Na pracowni będziemy wykonywać takie zadania jak: automatyczne poprawianie tekstu (np. rekonstrukcja polskich znaków diakrytycznych lub wielkich liter), znajdywaniem w tekstach fraz określonego typu (na przykład nazw organizacji, osób, dat, etc), generowaniem tekstów na zadany temat, automatycznym wykrywaniem ""mowy nienawiści"", analizą składniową i korektą błędów gramatycznych.

W przypadku konieczności organizowania zajęć w formie zdalnej, studenci otrzymają nagrane wykłady, ćwiczenia będą w przeprowadzone z deklaracjami i wspólną pracą nad Raportem z ćwiczeń, zadania na pracownie będą konsultowane i odbierane przy użyciu systemu telekonferencyjnego."
Introduction to Programming in Python,5,"Wykład, live coding, samodzielna praca programistyczna w domu oraz na zajęciach, analiza i modyfikacja programów dostarczonych przez prowadzącego",,False,True,"**Wstęp, czyli jak się ma ""Wstęp do programowania w języku Python"" do ""Wstępu
do programowania w języku C""**

Studenci 1-go roku studiow 1-go stopnia mogą rozpocząć naukę programowania i
podstaw informatyki w jednym z dwoch językow: **Python albo C** -- (można
wybrać tylko jeden z tych kursow!). Każdy z tych językow pozwala opanować
podstawy informatyki i programowania, a w dalszych semestrach doskonalić się w
programowaniu w innych (lub tych samych) językach. W szczegolności zaczynając
od ""Kursu: Wstęp do programowania w języku Python"", nie skazujecie się na
zawsze na ten język (i nieznajomość C) oraz _vice versa_. W drugim semestrze
studi ow (i kolejnych) pojawiają się kursy językow programowania (C++, Java,
Ruby, Python), ktore pozwalają opanować rożne języki, przy założeniu, że
studenci mają ogolne pojęcie o programowaniu, ktore zdobywają na każdym z
przedmiotow ""Kurs: Wstęp do programowania w języku C/Python"".

**O samym kursie ""Wstęp do programowania w języku Python""**  
  

Niniejszy kurs jest wstępnym kursem programowania, bazującym na języku Python,
nie zakładającym   **żadnej wstępnej znajomości programowania (** aczkolwiek
jego ukończenie wymaga pewnego zaangażowania). Uczestnicy tego kursu będą
mieli okazję poznać nie tylko sam język, ale rownież szereg idei, ktore są
istotne przy pisaniu programow we wszystkich językach imperatywnych (i w
pewnym stopniu rownież funkcyjnych i obiektowych)."
Software foundations in Coq,6,wykład · samodzielna praca przy komputerze · samodzielne wykonywanie zadań zawodowych · indywidualny/zespołowy projekt programistyczny,,False,False,"Niezawodność oprogramowania należy do najbardziej istotnych wyzwań
współczesnej informatyki. Systemy wspomagające dowodzenie twierdzeń, takie jak
[Coq](https://coq.inria.fr/), zyskują w ostatnich latach ogromną popularność
jako platformy wspierające konstruowanie poprawnego i bezpiecznego
oprogramowania, łącząc w sobie język programowania oraz system logiczny. Coq
pozwala nie tylko na formalne specyfikowanie oraz weryfikowanie poprawności
programów komputerowych (tzw. certyfikowanie kodu), ale także na precyzyjne
definiowanie i analizę całych języków programowania.

Przedmiot stanowi wprowadzenie do formalnych podstaw niezawodnego
oprogramowania przy użyciu systemu Coq. Poruszana tematyka dotyczy wybranych
elementów logiki, teorii języków programowania oraz samego systemu Coq, a
całość przedmiotu realizowana jest w oparciu o podręcznik [Software
Foundations](https://softwarefoundations.cis.upenn.edu).

Omawiane zagadnienia:

  1. Programowanie funkcyjne w systemie Coq
  2. Wnioskowanie w systemie Coq (definicje indukcyjne, dedukcja naturalna, język taktyk, automatyzacja wnioskowania)
  3. Dowody jako programy (izomorfizm Curry'ego-Howarda, typy zależne, ekstrakcja programów z dowodów)
  4. Semantyka operacyjna języków imperatywnych (strukturalna semantyka operacyjna małych i dużych kroków, maszyny abstrakcyjne, transformacje programów)
  5. Specyfikacja i weryfikacja programów imperatywnych (logika Hoare'a)
  6. Rachunek lambda z typami prostymi (semantyka operacyjna, sprawdzanie typu, normalizacja)
  7. Rozszerzenia systemu typów prostych (rekordy i podtypowanie, modyfikowalny stan)
  8. Losowe testowanie programów i specyfikacji (QuickChick)

Literatura:

  1. Benjamin C. Pierce: [Software Foundations](https://softwarefoundations.cis.upenn.edu).
  2. Benjamin C. Pierce: [Programming Languages and Types](https://www.cis.upenn.edu/~bcpierce/tapl/). The MIT Press, 2002

Wykładowcy: Małgorzata Biernacka i Dariusz Biernacki"
Seminar: Lambda calculus: evaluation and normalization,3,"prezentacja studencka, rozwiązywanie ćwiczeń programistycznych",,False,False,"Rachunek lambda stanowi jądro wszystkich języków funkcyjnych, a także wielu systemów wspierających dowodzenie twierdzeń. Kluczowym zagadnieniem w tym kontekście staje się poprawna i efektywna implementacja β-redukcji, mechanizmu modelującego aplikację funkcji, a także operacji wyszukiwania kolejnego β-redeksu zgodnie z wybraną strategią redukcji. O ile w przypadku typowych języków funkcyjnych redukcja przyjmuje postać ewaluacji termu do słabej postaci normalnej, dowolnej λ-abstrakcji, w przypadku zamkniętych termów czystego rachunku lambda, to w przypadku porównywania typów zależnych przez systemy wspomagające dowodzenie twierdzeń wymagana jest pełna normalizacja termów, w tym termów otwartych, w ciele λ-abstrakcji.  

Tematem seminarium jest przegląd wybranych zagadnień związanych z procedurami redukującymi λ-termy. Wśród omawianych zagadnień znajdą się m. in. syntaktyczne ewaluatory i normalizatory bezpośrednio implementujące określoną strategię redukcji (semantyka redukcyjna, maszyny abstrakcyjne), autointerpretery (ang. self-interpreters), a także ewaluatory w kluczowy sposób wykorzystujące mechanizm redukcji w meta-języku (ewaluatory i normalizatory wyższego rzędu, w tym te realizujące model NbE - normalizacji przez ewaluację). W szczególności, sporo miejsca poświęcimy konstrukcji, poprawności i analizie maszyn abstrakcyjnych.

**Literatura (wybrane prace):**

1. Mads Sig Ager, Dariusz Biernacki, Olivier Danvy, Jan Midtgaard: A functional correspondence between evaluators and abstract machines. PPDP 2003: 8-19

2. Małgorzata Biernacka, Olivier Danvy:
A concrete framework for environment machines. ACM Trans. Comput. Log. 9(1): 6 (2007)

3. Ulrich Berger, Helmut Schwichtenberg:
An Inverse of the Evaluation Functional for Typed Lambda-Calculus. LICS 1991: 203-211

4. Klaus Aehlig, Felix Joachimski:
Operational aspects of untyped Normalisation by Evaluation. Math. Struct. Comput. Sci. 14(4): 587-611 (2004)

5. Torben Æ. Mogensen:
Efficient Self-Interpretations in Lambda Calculus. J. Funct. Program. 2(3): 345-363 (1992)

6. Pierre Crégut:
Strongly reducing variants of the Krivine abstract machine. High. Order Symb. Comput. 20(3): 209-230 (2007)

7. Benjamin Grégoire, Xavier Leroy:
A compiled implementation of strong reduction. ICFP 2002: 235-246

8. Beniamino Accattoli, Pablo Barenbaum, Damiano Mazza:
Distilling abstract machines. ICFP 2014: 363-376

9. Beniamino Accattoli, Giulio Guerrieri:
Abstract machines for Open Call-by-Value. Sci. Comput. Program. 184 (2019)

10. Martín Abadi, Luca Cardelli, Pierre-Louis Curien, Jean-Jacques Lévy:
Explicit Substitutions. J. Funct. Program. 1(4): 375-416 (1991)"
Clone: History of Moral Reflection,3,,,False,True,"Prowadzący: dr Marcin Drofiszyn 
Katedra Logiki i Metodologii Nauk UWr
marcin.drofiszyn@uni.wroc.pl

W trakcie wykładów zostaną omówione najważniejsze szkoły i koncepcje etyki filozoficznej. Prezentacja będzie się odbywać w porządku historycznym. Każda koncepcja zostanie omówiona w trzech krokach. Pierwszy krok, to wyjaśnienie pytania na które jest ona odpowiedzią. (Do czego dążyć? Jak dobrze żyć i dobrze się mieć? Co powinienem?) W drugim kroku zostanie przedstawiona główna teza oraz argumenty, które za nią przemawiają. (Poznaj siebie! Spełniaj obowiązki! Maksymalizuj przyjemność!) W ostatnim kroku przedstawione argumenty zostaną skonfrontowane z krytycznymi głosami komentatorów.
Ćwiczenia będą polegały na wspólnym czytaniu i dyskutowaniu źródłowych tekstów dla koncepcji omawianych na wykładach."
Research seminar: Formal logic and databases,3,wykład – wykład interaktywny – prezentacja - dyskusja – analiza tekstu - rozwiązywanie zadań z komentowaniem,,False,False,"**Opis:**

Seminarium dotyczy formalnych sposobów reprezentacji wiedzy. W naszym przypadku baza wiedzy składać się będzie z bazy danych (czyli zbioru atomów) oraz pewnej teorii logicznej, zadanej najczęściej za pomocą reguł egzystencjalnych bądź
logik opisowych. Zajmować będziemy się klasycznymi problemami jak np. złożoność problemu odpowiadania na zapytania (koniunkcyjne, regularne), transfer danych czy spójności baz wiedzy.

**Plan seminarium**

Ramowy plan seminarium jest następujący. Podczas pierwszego spotkania prowadzący zaprezentują kilka problemów otwartych, luźno powiązanych z reprezentacją wiedzy, bazami danych i logiką. Następnie uczestnicy wybierają jeden z tematów, którego dotyczyć będzie dalsza część seminarium. Po wybraniu tematu seminarium, prowadzący przydzielają uczestnikom do przeczytania prace naukowe, które są następnie referowane. Po dogłębnym zrozumieniu tematu będziemy podejmować próby wspólnego rozwiązania problemu. 

**Co daje udział w seminarium?**

Seminarium daje możliwość spojrzenia na to jak wygląda praca naukowca. W przypadku sukcesu i zaangażowania studentów, uczestnictwo w seminarium zakończyć może się wspólną publikacją. Prowadzący z chęcią nadzorować będą również prace licencjackie/inżynierskie/magisterskie odpowiadające tematyce seminarium.

**Wymagania:**

Od słuchaczy oczekuje się znajomości logiki pierwszego rzędu na poziomie
wykładu ""logika dla informatyków"" Materiał z przedmiotu ""języki formalne i
złożoność obliczeniowa"" (podstawy teorii automatów, dowody
nierozstrzygalności, redukcje wielomianowe, klasy złożoności obliczeniowej NP,
PSpace, ExpTime, NExpTime, itd.), ale da się go dość szybko nadrobić.

**Termin seminarium:**

Termin seminarium zostanie ustalony podczas pierwszego  spotkania. Seminarium odbywać się będzie zarówno w semestrze zimowym jak i letnim."
Algorithms and Data Structures,9,,,False,False,"**Program:**

  1. Przegląd metod projektowania efektywnych algorytmow: dziel i zwyciężaj, programowanie dynamiczne, metoda zachłanna. (4 godz.)
  2. Złożoność obliczeniowa algorytmu (pesymistyczna, oczekiwana, zamortyzowana). Przykłady analizy kosztu. (2 godz.)
  3. Sortowanie: Heapsort i Quicksort. Model drzew decyzyjnych i dolne ograniczenie na problem sortowania. Sortowanie w czasie liniowym: Countsort, Radixsort, Bucketsort. (6 godz.)
  4. Selekcja: algorytmy Hoarea i magicznych piątek. (2 godz.)
  5. Kolejki priorytetowe: kopce binarne, dwumianowe i Fibonacciego. Zastosowania w problemie najkrotszych ścieżek i minimalnego drzewa rozpinającego. (4 godz.)
  6. Scalanie. Drzewa turniejowe. Sortowanie zewnętrzne. (2 godz.)
  7. Wyszukiwanie i problem słownika. Drzewa wyszukiwań binarnych, zrownoważone drzewa wyszukiwań binarnych (AVL, 2-3-4-drzewa, drzewa czerwono-czarne). Optymalne drzewa wyszukiwań binarnych. Haszowanie. Wyszukiwanie pozycyjne. (8 godz.)
  8. Wyszukiwanie zewnętrzne - B-drzewa. (2 godz.)
  9. Problem sumowania zbiorow rozłącznych i jego zastosowania. (4 godz.)
  10. Algorytmy grafowe: przepływy w sieciach, skojarzenia. (4 godz.)
  11. Algorytmy na tekstach. Wyszukiwanie wzorca. Drzewa sufiksowe. (4 godz.)
  12. Geometria obliczeniowa. Lokalizacja punktu. Otoczka wypukła. Technika zamiatania. (4 godz.)
  13. Algorytmy algebraiczne i teorioliczbowe. FFT. Szybkie mnożenie liczb i wielomianow. (4 godz.)
  14. NP-zupełność. Algorytmy aproksymacyjne dla problemow obliczeniowo trudnych. Heurystyki dla problemow trudnych (algorytmy genetyczne, simulated annealing). (4 godz.)
  15. Modele obliczeń rownoległych: PRAM, tablica procesorow, hiperkostka. Algorytmy rownoległe. Klasa NC i problemy P-zupełne. (2 godz.)
  16. Specjalne modele obliczeń: sieci komparatorow, obwody logiczne. (2 godz.)
  17. Algorytmy randomizacyjne. Przykłady w dziedzinach: struktury danych, geometria obliczeniowa, algorytmy grafowe, algorytmy rownoległe. (2 godz.)

**Wymagania:** Programowanie i Matematyka dyskretna"
Seminar: Communication complexity,3,,,False,False,"We will study the amount of communication required to solve a problem when the input is distributed between two or more parties. As a prime example, consider the following game played by Alice and Bob: each player holds a string of length n, and the goal is to determine if the strings are equal by exchanging as little information as possible. For deterministic protocols, it is not hard to see that the players need to exchange n bits for information. However, allowing randomisation decreases this to only O(logn). As a more challenging example, each player holds a set, and the goal is to determine if the sets are disjoint.

While interesting in its own right as a clean and mathematically elegant model, communication complexity is important due to its applications in other areas. In this lecture, we will see how to use it to deduce lower bounds for data structures and streaming algorithms.

Basic knowledge of algorithms and data structure is necessary. Having already taken the Randomised algorithms course is advised but not required."
cross-cultural psychology,3,,,False,False,"#### Prowadzący: 
Dr hab. Maciej Bachryj-Krzywaźnia, Katedra Studiów Europejskich

#### Typ:
Przedmiot nieinformatyczny, wariant bez ćwiczeń (3 ECTS)

#### Zagadnienia:
1. Specyfika i zakres psychologii międzykulturowej
2. Kulturowe determinanty poznania społecznego
3. Enkulturacja, socjalizacja, znaczenie różnic kulturowych model ekokulturowych uwarunkowań psychiki
4. Kultura i multikulturalizm, kategoryzacja społeczne i jej konsekwencje
5. Szok kulturowy
6. Akulturacja
7. Doświadczenie i konsekwencje uchodźstwa 
8. Psychologiczne wymiary kultury
9. Komunikacja międzykulturowa
10. Kulturowe doświadczenie płci
11. Etnocentryzm, entorelatywizm
12. Stereotypy, uprzedzenia, dyskryminacja"
Fundamentals of Computer Graphics,6,"* Wykład
* Prezentacja
* Pracownia programistyczna
* Projekt programistyczny
* Samodzielna praca przy komputerze",,False,False,"Grafika komputerowa jest obecna w grach, filmach, reklamach czy interfejsach użytkownika. Dlatego warto zrozumieć jak powstaje i poznać kluczowe standardy i algorytmy. Umożliwi to nie tylko posługiwanie się ze zrozumieniem gotowymi silnikami graficznymi ale także sprawne pisanie własnych gier i aplikacji np. przy użyciu API OpenGL. Wykład jest także wprowadzeniem do zaawansowanych przedmiotów z grafiki komputerowej i jest przeznaczony dla studentów od drugiego roku.

Na wykładzie wprowadzone jest teoria i podstawowe metody, które umożliwiają efektywne programowanie grafiki z użyciem kart graficznych. Na pracowni uczymy się praktyki programowania w nowym OpenGL (wersja 3.3 lub nowsza). Wykład nie jest jednak kursem tylko biblioteki OpenGL ale skupia się nad zrozumieniem
podstaw takich jak np. efektywne metody przekształcania układów współrzędnych i algorytmy renderingu.

Omawiane zagadnienia:

  * Przekształcenia w jednorodnym układzie współrzędnych
  * Efektywne reprezentacje rotacji w tym kwaterniony
  * Modelowanie wirtualnej kamery i obiektów 3D
  * Widoczność: algorytm z-bufora, śledzenie promieni i inne
  * Modelowanie i obliczanie oświetlenia
  * Rasteryzacja i antialiasing
  * Światło i kolor w grafice, modele koloru
  * Teksturowanie 2D/3D, tekstury proceduralne

**Wymagania:** algebra, podstawy algorytmów i struktury danych, analiza numeryczna, umiejętność programowania w C/++

**Literatura:** P. Shirley, ""Fundamentals of Computer Graphics"", A.K.Peters, Natick Massachusetts 2002."
cross-cultural psychology,5,,,False,False,"#### Prowadzący: 
Dr hab. Maciej Bachryj-Krzywaźnia, Katedra Studiów Europejskich

#### Typ:
Przedmiot nieinformatyczny (5 ECTS)


#### Zagadnienia:
1. Specyfika i zakres psychologii międzykulturowej
2. Kulturowe determinanty poznania społecznego
3. Enkulturacja, socjalizacja, znaczenie różnic kulturowych model ekokulturowych uwarunkowań psychiki
4. Kultura i multikulturalizm, kategoryzacja społeczne i jej konsekwencje
5. Szok kulturowy
6. Akulturacja
7. Doświadczenie i konsekwencje uchodźstwa 
8. Psychologiczne wymiary kultury
9. Komunikacja międzykulturowa
10. Kulturowe doświadczenie płci
11. Etnocentryzm, entorelatywizm
12. Stereotypy, uprzedzenia, dyskryminacja"
Tools and methods in big data processing,5,"* interactive lectures, 
* individual/collective problem solving, 
* discussion, 
* implementation of programming assignments and a programming project",,False,False,"*The first edition of this course is an experimental one, the number of places is limited up to 12 persons and the preference is given to data science students.*

The course presents the tools and methods used in big data processing. The goal of the course is to enable the students to acquire skills required to process large amounts of data in a distributed environment, both in a batch and streaming variant."
Project: Scheduler,4,"* Projekt programistyczny
    * Pracownia programistyczna",,False,False,"W ramach projektu grupa studentów rozwija istniejący system Scheduler służący do układania planu zajęć w Instytucie Informatyki: ulepsza istniejące funkcjonalności i wprowadza nowe.

Podstawowe wymagania: średnio-zaawansowany angielski, znajomość html i css, umiejętność programowania w dowolnym języku programowania, podstawowa znajomość javascriptu, podstawy git, bash i linuksa.

Mile widziane: Kurs WWW, Kurs Podstawowy Warsztat Informatyka.

Projekt Scheduler używa takich narzędzi jak: Javascript, AngularJs, Underscore.js, Python, Django, Scala, Finagle, Thrift, Docker, docker-compose, kubernetes, git, AWS, Google Cloud.

Przedmiot zalicza wymaganie projektu zespołowego. Można uczestniczyć w nim wielokrotnie."
Seminar On Advanced Algorithmics,3,,,False,False,"Cele seminarium są dwojakie:

  * wprowadzenie studentów do własnych badań
  * uzupełnienie wiedzy z zakresu klasyki AiSD.

Dla realizacji pierwszego celu zaproponujemy studentom referowanie prac
zawierających wyniki, które według naszej wiedzy są poprawialne i, według
naszego wyczucia, są w zasięgu studentów. Oczywiście będą one dotyczyć
problemów, które uznajemy za interesujące.

Ubocznym, acz dość ważnym dla studentów, efektem może być uzyskanie wyników,
które legną u podstaw publikacji naukowej/pracy magisterskiej/….."
Algorithmic game theory,6,"* Wykład
* Ćwiczenia audytoryjne
* Przygotowanie i prezentacja wybranych zagadnień przez studentów",,False,False,"This course is devoted to computational aspects of decision making in the context of data being provided by strategic agents.

The main topics that will be covered:
* Noncooperative games:
  1. strategies
  2. Nash equilibria
  3. computational complexity (class PPAD)

 
* Cooperative games:
  1. coalition forming
  2. solution concepts


* Decision mechanisms:
  1. with money (e.g. auctions)
  2. without money (e.g. elections)
  3. fair division


* Cost sharing mechanism
* ""price of anarchy"" in the context of transportation networks

The course contains elements of computational complexity, probability theory, and convex optimization. Some prior experience with these fields would be of help, but is not formally required.

A large part of the course will follow the book:

Nisan, Routhgardan, Tardos, Vazirani. Algorithmic game theory.

http://www.cambridge.org/journals/nisan/downloads/Nisan_Non-printable.pdf"
Neural Networks and Deep Learning,6,"* Programming project
* Programming laboratories
* Research project
* Lecture

In case of further University lockdown the course will be offered remotely:
* Lectures will be delivered over a videconference system and recorded
* Assignments will be graded using a combination of automatic grading tools and presentations over conferencing systems
* The project will feature presentations given to other students
* The final exam may be held remotely in the form of quizzes and oral evaluations during 1-on-1 calls",,False,False,"**Information for enrolled/prospective students**: all information is on SKOS (please self-enroll into Deep Learning 2021), materials are on GitHub, lectures will be streamed and recorded in Teams. **Enrollment code** is in SKOS.

Neural Networks and other Deep Learning techniques allow creation of programs
that are learned rather than written. This means that instead of implementing
a concrete algorithm, the program applies patterns that are automatically
found in the data. In example, a translation system such as the Google
Translate can be created by applying a deep neural network to a large corpus
of translated documents. 

The lecture is a continuation of the Machine Learning course, focusing on Deep Learning techniques. We will speak about the current state of the art techqniques for image recognition and language processing such as convolutional and recurrent neural networks with the attention mechanism. We will also speak about data generation techniques, such as autoencoders and generative adversarial networks and we wil see a bit of deep reinforcement learning.

The lecture will be accompanied by computer exercises:

  * Key topics will be illustrated by small exercises.
  * We wil introduce the PyTorch deep learning framework.
  * A larger project will give you the opportunity to tackle a real world machine learning problem."
Seminar: algorithmics in networks,3,,,False,False,"##### Seminarium prowadzone wspólnie przez Tomasza Jurdzińskiego i Przemysława Uznańskiego.

##### Opis:
Jednym z głównych nurtów algorytmiki są algorytmy rozproszone, gdzie wiele
niezależnych urządzeń kooperuje w celu wspólnego rozwiązania problemu.
Dynamiczny rozwój technologii sieciowych powoduje, że algorytmy rozproszone
pojawiają się w różnorodnych sytuacjach i zastosowaniach. Co więcej, nowe
technologie i zastosowania wymagają dopasowania istniejących lub wprowadzenia
nowych modeli. To z kolei stwarza nowe problemy algorytmiczne i nowe miary
jakości takich algorytmów. W ramach seminarium prezentowane bądą klasyczne i
najnowsze wyniki dotyczące algorytmów rozproszonych i algorytmów sieciowych.
Kluczowe wyniki w tej dziedzinie prezentowane są na konferencjach PODC i DISC
oraz na konferencjach algorytmicznych ICALP, ESA, SODA, STOC, i in. Do
referowania będzie można wybrać prace prezentujące nowe wyniki, jak i
rezultaty bardziej klasyczne. Wiele wyników do prezentacji dotyczyć będzie
rozproszonego rozwiązywania problemów grafowych, planowania przepływu danych
(ruting) itp. Rozważane będą klasyczne modele obliczeń rozproszonych (local,
congest, pamięć dzielona) jak i nowsze (congested clique, radio/wireless
networks, map-reduce).

###### Przewidywana forma zajęć w przypadku konieczności prowadzenia zajęć zdalnie:

- zajęcia będą prowadzone w formie wideokonferencji."
Seminar: Theory of automata,3,,,False,False,"Celem seminarium jest zaznajomienie słuchaczy z klasycznymi modelami
automatów, ich własnościami oraz zastosowaniami. W trakcie seminarium zostaną zaproponowane tematy prac magisterskich.

Seminarium może odbywać się zdalnie poprzez Google Meet lub MS Teams, jeśli zajęcia w semestrze zimowym będą odbywały się zdalnie.

**Program:**

1. **Automaty na słowach nieskończonych.**  
a) Automaty Buchiego oraz inne warunki akceptacji.  
b) Zamkniętość język ow omega-regularnych ze względu na sumę, przekrój,
dopełnienie. c) Zastosowania automatów na słowach nieskończonych.

2. **Automaty na drzewach oraz drzewach nieskończonych.**  
a) Podstawowe definicje i własności.  
b) Związki automatów na drzewach z grami na grafach.

3. **Automaty z wagami.**  
a) Podstawowe definicje.  
b) Zastosowania w rozpoznawaniu mowy i weryfikacji.

4. **Gry na grafach.**  
a) Podstawowe definicje.  
b) Strategie: bezpamięciowe, ze skończoną pamięcią oraz z nieskończoną pamięcią.  
c) Gry ilościowe.

5. **Modele probabilistyczne.**  
a) Łańcuchy Markova.  
a) Procesy decyzyjne Markova.  
a) Automaty probabilistyczne."
Seminar: Non-classical Logics: Theory and Applications,3,,,False,False,"W ramach seminarium dokonamy przeglądu wybranych systemów logicznych
wychodzących poza logikę klasyczną, które znajdują zastosowania w informatyce.
Aby lepiej rozumieć zasady rządzące systemami logicznymi, będziemy omawiać m.
in. semantykę i elementy teorii dowodu rozważanych systemów.

Proponowane tematy zajęć:

  * Logika klasyczna vs. logika intuicjonistyczna, izomorfizm Curry'ego-Howarda.
  * Elementy teorii dowodu - systemy Hilberta, naturalna dedukcja, rachunek sekwentów.
  * Logiki substrukturalne, logika liniowa.
  * Logiki wielowartościowe, logika rozmyta.
  * Logiki modalne.
  * Zastosowania w AI - wnioskowanie niemonotoniczne, wnioskowanie w warunkach niepewności, logika epistemiczna.
  * Zastosowania w weryfikacji - logika temporalna, logika dynamiczna.

Każdy student powinien zaprezentować wybrany temat, a także przygotować
slajdy/ notatki (które będą udostępniane pozostałym uczestnikom seminarium)
oraz kilka prostych zadań utrwalających wiedzę.

W przypadku przejścia na tryb zdalny zajęcia będą się odbywać poprzez komunikator (Google Meet lub MS Teams), a każdy student powinien przygotować slajdy do prezentacji swojego tematu.

Wymagania: Logika dla informatyków."
Verification and synthesis of multi-agent systems,3,"czytanie prac naukowych, prezentowanie prac naukowych, dyskusja",,False,False,"Celem przedmiotu jest poznanie zagadnień związanych z weryfikacją i syntezą systemów wieloagentowych - czyli takich, które opisują interakcję między wieloma systemami lub maszynami. Seminarium nie zakłada wiedzy słuchaczy z zakresu weryfikacji, dlatego kilka początkowych zajęć poświęcimy podstawowym tematom, na bazie książki Handbook of Model Checking (Clarke, E.M., Henzinger, Th.A., Veith, H., Bloem, R., 2018). Później przejdziemy do tematów związanych typowo z systemami wieloagentowymi, w tym weryfikacji własności opartych o strategie agentów.

Przedmiot będzie prowadzony zdalnie, niezależnie od warunków epidemiologicznych. Studenci dostaną do przeczytania i zreferowania pracę lub rozdział książki. Następnie będą mieli za zadanie przygotować 45-60 minutową prezentację. Po akceptacji prowadzącego, prezentacja zostanie przedstawiona pozostałym studentom. Następnie, w ustalonych terminach, będzie przeprowadzona dyskusja na temat prezentacji. Ocena będzie zależeć w 80% od jakości prezentacji (włącznie z udziałem w dyskusji poświęconej tej prezentacji) i w 20% od aktywności w dyskusjach nad pozostałymi prezentacjami. 

Orientacyjny plan:
1. Podstawowe zagadnienia weryfikacji i syntezy systemów (ok. 5 zajęć).
2. Podstawy systemów wieloagentowych (ok. 1 zajęcia).
3. Bieżące badania naukowe poświęcone tematyce seminarium (ok. 9 zajęć)."
Half-course: Data Recovery,3,"* Wykład
* Pracownia komputerowa, w tym:
   * Samodzielna praca przy komputerze
   * Grupowe rozwiązywanie zadań przy komputerze
   * Prezentacja rozwiązań przy komputerze",,False,False,"Kurs omawia metody przechowywania danych na nośnikach elektronicznych,
protokoły warstwy fizycznej (dyski mechaniczne i SSD, zapis optyczny),
urządzeń blokowych i systemów plików (szczególnie strukturę statyczną,
tj. _on-disk format_) oraz ich implementację w Linuksie. Aspekty
praktyczne kursu skupiają się na sposobach i narzędziach do odzyskiwania
danych z nośników, które zostały skasowane lub uszkodzone. Techniki
odzyskiwania danych z urządzeń pamięci masowych są częścią tzw.
informatyki śledczej. Mimo iż nazwa brzmi intrygująco, to ten dział
informatyki jest wyjątkowo nudny i wymaga dużej pracowitości i
cierpliwości. Nie tylko trzeba znać i umieć efektywnie wykorzystać
dostępne narzędzia, ale potrzeba też bardzo szczegółowej wiedzy na temat
analizowanych formatów danych i systemów plików.

Na zajęcia powinny się zapisać tylko osoby, które poważnie interesują
się teorią i praktyką przechowywania danych w urządzeniach pamięci
masowej i chciałyby rozwinąć umiejętności ich badania. Osobom, które
straciły swoje dane i pragną je odzyskać polecamy zamiast tego kurs
„Metody tworzenia kopii zapasowych i archiwizacji danych”.

##### Orientacyjny program zajęć:

  1. Warstwa fizyczna i warstwa urządzeń blokowych. Urządzenia pamięci masowej: dyski magnetyczne, pamięci flash, SSD, płyty CD i DVD. Firmware urządzeń blokowych. Protokół S.M.A.R.T. Magistrale i ich protokoły: SCSI, SATA, NVMe, USB. Partycje: MBR, GPT. Obsługa urządzeń pamięci masowej w systemie operacyjnym.
  2. Warstwa systemu plików. System plików Microsoft FAT.
  3. Systemy plików uniksowych: UFS, ext2.
  4. Systemy plików na nośnikach optycznych: ISO 9660, Rock Ridge i Joliet, UDF.
  5. Spójność systemu plików. Fsck. Transakcje atomowe. Systemy plików z księgowaniem: ext3, ext4, ReiserFS, NTFS.
  6. Systemy plików COW: ZFS i Btrfs. Inne systemy plików.
  7. Warstwa aplikacji. Typowe formaty plików: JPEG, PNG, PDF, MP3 i in.
  8. Techniki odzyskiwania danych z urządzeń pamięci masowych.

##### Literatura:

  1. Brian Carrier, *File System Forensic Analysis*, Addison Wesley 2005."
Internet technologies,5,"* Wykład
* Pracownia programistyczna",,False,False,"Celem wykładu jest zapoznanie słuchaczy ze światem Internetu z punktu widzenia
twórcy dostępnej tam treści. Przedstawione zostaną bardzo różne zagadnienia od
podstaw technologii występujących u klienta i na serwerze, poprzez systemy
CMS, optymalizację, bezpieczeństwo czy konfigurację serwerów, aż do usług czy
produktów od Google i Facebook-a. Wykład ma charakter przeglądowy i w związku
z tym _**nacisk położony jest na pobieżne poznanie prezentowanych zagadnień**_
niż ich dokładne omawianie. Kurs ten ma też w swoim zamierzeniu ułatwić wybór
zagadnień czy kursów do dalszego studiowania.

**Program:**

  1. Podstawy komunikacji sieciowej w tym 
     - DNS, HTTP, FTP, SMTP
     - Formaty danych JSON i XML
     - Asynchronous JavaScript and XML (AJAX)
     - Narzędzia do przechwytywanie ruchu
  2. Przegląd architektur aplikacji WWW, uruchomienie rozwiązania w chmurze
  3. Język formatowania HTML/XHTML, nowości w HTML5.
  4. Prezentacja danych za pomocą CSS, w tym także
     - nowości CSS3
     - podstawy ""usability""
     - RWD i Bootstrap, zasady tworzenia stron na różne rodzaje urządzeń, w tym mobilne
  5. Tworzenie dynamicznych treści
     - ECMAScript/JavaScript, TypeScript
     - jQuery, jQuery UI
     - podstawowe wzorce tworzenia kodu
  6. Podstawy tworzenia aplikacji po stronie serwera
  7. Wzorzec MVC
  8. Usługi sieciowe: XML Web Services i RESTful services
  9. Aplikacje typu SPA, wprowadzenie do AngularJS
  10. Podstawy projektowania rozwiązań w chmurze
  11. Uwierzytelnianie i autoryzacja, protokoły OAuth2 i OpenID Connect, federacja tożsamości
  12. SSL/TLS, certyfikaty i centra certyfikacji, zastosowania
  13. Podstawy Internetu Rzeczy
  14. Usługi firm trzecich: SMS, systemy płatności, Google, Facebook, mapy, pogoda
  15. Analiza ruchu na przykładzie Google Analytics
  16. DXP, WEM, CMS, przegląd systemu WordPress
  17. Bezpieczeństwo aplikacji w Internecie
      - Przegląd obszarów bezpieczeństwa
      - Typowe ataki na serwisy WWW i metody obrony
      - Podstawy testowania bezpieczeństwa
  18. Optymalizacja wydajności"
Seminar on approximation algorithms and combinatorial optimization,3,"prezentacja, samodzielna lektura prac naukowych",,False,False,"Mieszanka tematów, starych i nowych, dotyczących algorytmów aproksymacyjnych,
optymalizacji kombinatorycznej, grafów, kombinatoryki i matematyki dyskretnej.

W szczególności na wykładach z AA i OK wielu rzeczy nie zdąży się opowiedzieć
i seminarium to może być (m.in.) uzupełnieniem tych wykładów.

Będzie można usłyszeć o problemach otwartych.

W seminarium można uczestniczyć wielokrotnie.

**Program:** **Wymagania:**

Mile widziana znajomość Algorytmów Aproksymacyjnych lub Optymalizacji
Kombinatorycznej, ale niekonieczna. **  
**"
Course: Rust language,5,"Wykład – wykład interaktywny, rozwiązywanie zadań z komentowaniem, samodzielna praca przy komputerze - indywidualne programowanie",,False,False,"Rust (kompilowalny język programowania ogólnego przeznaczenia rozwijany obecnie przez Mozilla Foundation) jest jednym z najciekawszych języków programowania, jakie pojawiły się w ostatnich latach.

Stworzony z myślą o tym, aby był „szybki, bezpieczny, współbieżny i praktyczny”.
Rust jest wieloparadygmatowy (obiektowy, imperatywny, funkcyjny, strukturalny i współbieżny).

W ostatnich latach bardzo szybko zyskuje na popularności, niektórzy twierdzą, że jest następcą C++ na kolejne 30 lat...

Kursu będzie podzielony na dwie części. Wykład będzie prowadzony na podstawie oficjalnej książki napisanej przez autorów języka (Steve Klabnik and Carol Nichols: The Rust Programming Language). Na pracowni będziemy rozwiązywać praktyczne problemy w formie zadań z testami w duchu TDD (Test-Driven Development), korzystając z portalu:
https://www.codewars.com

Przedmiot jest wymagający.
Sumarycznie do zrobienia będzie 35 zadań na CW, 2 mini projekty, projekt z WebAssembly oraz projekt finalny."
Lua course,5,"* Wykład
* Pracownia programistyczna
* Projekt programistyczny",,False,False,"Lua jest językiem skryptowym charakteryzującym się minimalizmem, szybkością
działania oraz prostotą osadzenia w języku C. Dzięki tym cechom jest to od
wielu już lat najpopularniejszy język skryptowy w przemyśle gier komputerowych
([wiki list](https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games)).

Lua daje programiście szerokie możliwości ale niewiele narzuca: można w niej
programować zarówno imperatywnie, funkcjonalnie jak i obiektowo, a elastyczna
składnia pozwala na dostosowanie języka do własnych potrzeb.

Wykład w części będzie poświęcony samemu językowi Lua, a w części technikom
jego osadzania w C i wykorzystywania jako język skryptowy i na odwrót -
rozszerzaniem skryptów Lua o moduły będące skompilowanymi bibliotekami C.

**Program:**

  1. podstawy - typy, wyrażenia, struktury kontrolne i funkcje
  2. iteratory, generyczne ""for"", koprocedury, domknięcia
  3. struktury danych, metatabele, metametody i środowisko
  4. ""słabe"" tabele, programowanie OO i tworzenie modułów oraz biblioteka standardowa
  5. API w C - stos lua, obsługa błędów, wywoływanie kodu C z Lua i Lua z C, techniki pisania funkcji
  6. typy użytkownika i zaawansowane tematy wiązania

**Wymagania:** znajomość języka C, C++ lub innego języka ""niskiego"" poziomu w
którym można osadzać Lua


W przypadku konieczności przeprowadzanie zajęć zdalnie, wykłady będę przeprowadzone w formie interaktywnej korzystając z Discord/Google Hangouts i najprawdopodobniej nagrywane. Oddawanie pracowni oraz projektów odbywać się będzie również za pomocą ww. narzędzi, przy czym student jest zobowiązany do zaprezentowania działania programu / wyników ""osobiście"", za pomocą funkcji udostępniania ekranu. Ogólne zasady przedmiotu nie ulegają zmianie."
Error Correction Codes,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"**Description**.

In general, error correcting codes aims to ensure that errors occurring during the writing, reading or transmission of information can be removed, or at least detected.
At one end of the spectrum of employed methods are simple codes that add a parity bit (which only allows validation, whether an error has occurred),
at the other end there are the Reed-Solomon codes, which allow the recovery of the original information even when a constant fraction of the codewords is corrupted.
As errors in transmissions are ever-present, correction codes are widely used, from file storage systems through barcodes, video data recording and cellular network transmission.


In this talk, classical (and sometimes a little&nbsp;more modern) results on correction codes will be presented:
- Upper and Lower bounds: combinatorial results that impose bounds on the possible parameters of the codes, and unconstructive methods that allow getting arbitrarily close to these bounds.
- Reed-Solomon codes, arguably the best known and most widely used error correction codes, which allow correction of a fixed fraction of errors. Their decoding algorithms are highly non-trivial (Berlekamp-Welch algorithm, Berlekamp-Massey and derivatives).
- Reed-Muller codes and their decoding (binary and general case).
- BCH codes: depending on the viewpoint: generalisation or special case of Reed-Solomon codes.
- Concatenated codes: which allow combining constructive and unconstructive methods in a single code. The decoding algorithm is one of the first non-trivial results concerning derandomisation in computer science.
- List decoding: a generalisation of classical decoding, in which instead of a single word we get a list of possible words. A tool widely used today in computational complexity.
- Local correction codes: a weakened version of correction codes in which all decisions are made based on a fixed number of message bits.

** Lecture plan. **
1. Theory of error correction.
2. Linear codes.
3. Lower and upper bounds.
4. Reed-Solomon codes and their decoding.
5. Reed-Muller codes and their decoding.
6. BCH codes.
7. Concatenated codes.
8. List decoding: bounds and algorithms.
9. Locally correctable codes.
10. Error correction codes for erasures.


** Audience**.
The course is mainly aimed at a wider audience of final year undergraduate or postgraduate students.

**Requirements**.
Students are expected to have previously passed *Algebra* and *Algorithms and Data Structures*.



**Opis**

W ogólnym zarysie, kodowanie korekcyjne ma zagwarantować możliwość usunięcia, a przynajmniej wykrycia, błędów powstałych w czasie zapisu, odczytu czy przesyłania informacji.
Na jednym końcu skali stosowanych metod znajdują się proste kody dodające bit parzystości (które umożliwiają jedynie sprawdzenie poprawności),
na drugim są kody Reeda-Solomona, umożliwiające odzyskanie oryginalnej informacji nawet w przypadku przekłamań stałej frakcji słów kodowych.
Jako że przekłamania transmisji są normą, kody korekcyjne są powszechnie stosowane, od
systemów przechowywania plików przechodząc przez kody kreskowe, zapis danych wideo a kończąc na transmisji sieci komórkowych.


W czasie wykładu w przedstawione zostaną klasyczne (i czasami trochę&nbsp;nowsze) wyniki dotyczące kodów korekcyjnych:
- Ograniczenie górne i dolne: wyniki kombinatoryczne, które nakładają ograniczenia na możliwe parametry kodów oraz niekonstrukcyjne metody pozwalające dowolnie blisko zbliżyć się do tych granic.
- Kody Reeda-Solomona, przypuszczalnie najbardziej znane i najczęściej stosowane kody korekcyjne, pozwalające na korekcję stałej frakcji błędów. Ich algorytmy dekodowanie są wysoce nietrywialne (algorytm Berlekamp–Welch, Berlekamp-Massey i pochodne).
- Kody Reeda-Mullera i ich dekodowanie (przypadek binarny i ogólny).
- Kody BCH: w zależności od punktu widzenia: uogólnienie lub przypadek szczególny kodów Reeda-Solomona.
- Kody skonkatenowane: które pozwalają na połączenie wyników konstrukcyjnych i niekonstrukcyjnych w jednym kodzie. Algorytm dekodujący jest jednym z pierwszych nietrywialnych wyników dotyczących derandomizacji w informatyce.
- Dekodowanie do list: uogólnienie klasycznego dekodowania, w którym zamiast jednego słowa otrzymujemy listę możliwych słów. Narzędzie powszechnie wykorzystywane obecnie w złożoności obliczeniowej.
- Lokalne kody korekcyjne: osłabiona wersja kodów korekcyjnych, w których wszelkie decyzje podejmowane są na podstawie stałej liczby bitów wiadomości.

**Plan wykładu.**
1. Kodowanie i korekcja błędów: teoria.
2. Kody liniowe.
3. Granice dolne i górne kodowania.
4. Kody Reeda-Solomona i ich dekodowanie.
5. Kody Reeda-Mullera i ich dekodowanie.
5. Kody BCH.
6. Kody skonkatenowane.
7. Dekodowanie do list: ograniczenia i algorytmy.
8. Lokalne kody korekcyjne.
9. Kody korekcyjne z utratą bitów.


**Słuchacze**
Przedmiot kierowany jest głównie do szerszego grona słuchaczy ostatniego roku studiów I stopnia lub studiów II stopnia.

**Wymagania**
Od słuchaczy oczekuję wcześniejszego zaliczenia *Algebry* oraz *Algorytmów i struktur danych*."
Algorithms on strings,6,"* Projekt programistyczny
* Projekt badawczy
* Wykład",,False,False,"Tematem wykładu będą algorytmy i struktury danych służące do przetwarzania i
przeszukiwania danych tekstowych. W programie znajdą się zarówno klasyczne
rozwiązania opracowane już w latach osiemdziesiątych, jak i takie, które są
znane dopiero od kilku lat. Wiele z nich będzie, mimo prostoty koncepcyjnej,
bardzo pomysłowych. Część wykładu poświęcimy na przedstawienie ogólnych
struktur danych, które mogą znaleźć zastosowanie także w problemach
niezwiązanych z tekstami.

**Program:**

  1. Analiza i zastosowania algorytmów wyszukiwania wzorca: dokładnego, z niezgodnościami, z błędami.
  2. Problemy podobieństwa tekstów (wspólne podciągi, nadciągi, odległość edycyjna, dopasowanie).
  3. Struktury danych dla tekstów: drzewa i tablice sufiksowe.
  4. Zwięzłe struktury danych i ich zastosowanie w strukturach danych dla tekstów.
  5. Problemy kompresji i wyszukiwania wzorca w skompresowanych tekstach.
  6. Conditional lower bounds dla problemów na tekstach.

**Wymagania:** zalecane zaliczone Algorytmy i struktury danych lub doświadczenie zdobyte w startach w olimpiadzie informatycznej (i podobnych imprezach)."
Randomized Algorithms,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Celem przedmiotu jest zapoznanie studentów z podstawowymi techniki
probabilistycznymi używanymi w projektowaniu i analizie zrandomizowanych
algorytmów i struktur danych ioraz przedstawia ich zastosowanie do
rozwiązywania klasycznych zagadnień algorytmicznych. W przypadku prowadzenia zajęć w formie zdalnej, wykłady będą w formie wideokonferencji, a na ćwiczeniach będą rozwiązywane listy zadań. Deklaracje, zgłaszanie rozwiązań wybranego przeze mnie zadania i punktowe oceny będą realizowane w SKOS-ie.

**Program:**

  1. Podstawowe pojęcia probabilistyki, klasy obliczeń i problemów losowych.
  2. Zrandomizowane struktury danych,
  3. Metoda probabilistyczna.
  4. Łańcuchy Markowa i błądzenie losowe.
  5. Zastosowanie losowości w algorytmach grafowych, programowaniu liniowym, geometrii obliczeniowej, algorytmach teorio-liczbowych, itp.

**Wymagania:** Algorytmy i struktury danych, Matematyka dyskretna Rachunek
prawdopodobieństwa

**Literatura:**

  1. R. Motvani, P. Raghavan, Randomized Algorithms,Cambridge University Press, 1995.
  2. Minzermacher Michael, Upfal Eli, Probability and Computing: Randomized Algorithms and Probabilistic Analysis, Cambridge University Press 2005 _lub polskie wydanie_ Metody probabilistyczne i obliczenia. Algorytmy randomizowane i analiza probabilistyczna, WNT 2009."
What you need to know for your first job,2,wykład,,False,False,"_Przedmiot za 2 ECTS, prowadzony w 1. połowie semestru przez pracowników firmy Intive, absolwentów Instytutu._

Przedmiot przeznaczony głównie dla osób planujących niebawem pójście do pierwszej pracy w IT. Skupimy się na zagadnieniach, o których niewiele mówi się na przedmiotach teoretycznych, a jednak niezbędnych by świadomie móc wybrać co i gdzie chce się robić.

Przeanalizujemy zagadnienia, pojawiające się podczas rekrutacji, zastanowimy się, jak się do nich przygotować. 

1. Tematy, które warto rozumieć podczas rekrutacji 1: przegląd popularnych wzorców projektowych, metodologii pracy takie jak SCRUM, Waterfall, itp. (Grzegorz Byrka)
2. Tematy, które warto rozumieć podczas rekrutacji 2: narzędzia wspierające dewelopera, rozwiązywanie zadań rekrutacyjnych (Grzegorz Byrka)
3. Omówienie aktualnych regulacji prawnych dotyczących form współpracy. Umowa o pracę, o dzieło, zlecenie, własna działalność. Jakie korzyści i zagrożenia dla nas niosą i jak nie wpakować się na minę (Grzegorz Byrka)
4. Kim jest profesjonalny programista, tester, devops i dlaczego umiejętność programowania nie wystarczy? (Jakub Werłos)
5. Jak efektywnie zbierać i definiować wymagania klientów? 
6. Czym jest dobra historyjka użytkownika i jak z niej korzystać na co dzień? (Jakub Werłos)
7. Mój wymarzony zespół i projekt, czyli dlaczego 1+1 > 2. (Jakub Werłos)
8. Rekrutacja oczami rekrutera. Jak kandydata widzi HR (HR Manager z Intive)"
Theory of linear and integer programming,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Układy nierówności liniowych można rozwiązywać wielomianowo. Na tych zajęciach
spokojnie i dość szczegółowo omówimy takie zagadnienia zwiazane z programami
liniowymi jak: * LP duality * complementarity slackness * Farkas lemma *
algorytm simplex * metodę elipsoid * separation oracle * rozwiazywanie dużych
(niewielomianowych) instancji * Hirsh conjecture.

Nastepnie omówimy pewne aspekty programowania całkowitoliczbowego: * algorytm
branch and bound * alg. branch and cut * algorytmy wielomianowe dla przypadku
stałej liczby wymiarów * metody oparte o algebraiczne manipulacje na kracie
punktów calkowitoliczbowych * algorytm LLL do redukcji bazy takiej kraty *
problemy shortest latice vector i closest latice vector.

Dodatkowo omówimy zastosowanie programowania liniowego do konstrukcji
algorytmów aproksymacyjnych na przykladzie problemow Facility Location i min
cost Steiner tree.

W czesci kursu poslużymy sie notatkami:
http://homepages.cwi.nl/~lex/files/dict.pdf Bedziemy rownież korzystać z
książki: ""Theory of Linear and Integer Programmin"", Alexander Shrijver.
Zajęcia będą zakończone egzaminem na ocenę."
Project: Programming Programming Games,4,"- grupowy projekt programistyczny
- prezentacja
- dyskusja, konsultowanie pomysłów",,False,False,"Gry programistyczne są doskonałym narzędziem dydaktycznym na każdym etapie edukacji. Wprowadzając w życie ideę nauki poprzez zabawę, pozwalają na trenowanie umiejętnosci programistycznych w interesującym (zarówno tematycznie jak i wizualnie) środowisku oraz łączą aspekty współpracy i rywalizacji.

Odpowiednio projektując taką grę, możemy nakierować jej uczestników na zapoznanie się z konkretnym zagadnieniem dotyczącym w zasadzie dowolnego aspektu informatyki. Poczynając od podstaw jak wykorzystanie wejścia/wyjścia, pętli, obsługi napisów etc, poprzez wykorzystanie odpowiednich algorytmów i struktur danych, konieczność optymalizacji numerycznej, wykorzystania wzorów geometrycznych, aż do zagadnień typowych dla sztucznej inteligencji.

W ramach tego przedmiotu, kilkuosobowe zespoły będą tworzyły gry programistyczne w oparciu o narzędzia udostępnione przez serwis [CodinGame](https://www.codingame.com/) (opcjonalnie także [Google DeepMind OpenSpiel](https://github.com/deepmind/open_spiel/tree/master/open_spiel), [Facebook Polygames](https://github.com/facebookincubator/Polygames), lub inny), nakierowane na konkretne aspekty dydaktyczne.

Poszczególne zespoły nie będą działały w odosobnieniu, lecz na regularnych spotkaniach z pozostałymi uczestnikami przedmiotu będą prezentować postępy prac, dzielić się wątpliwościami i słuchać ich opinii jako ""potencjalnych graczy"". Wszyscy uczestnicy przedmiotu będą również nawzajem testować swoje projekty. Na koniec projektu, oprócz przedstawienia gotowej gry, każda z grup przygotuje też krótki raport z historii jej toworzenia, dokumentujący jak zmieniały się koncepcje, zasady oraz ewoluowała wizualizacja.

Planowane jest osadzenie finalnych projektów w serwisie CodinGame (OpenSpiel/Polygames) i udostępnienie szerokiej publiczności, a w przypadku projektów o bardzo dobrej jakości zorganizowanie bazujących na nich oficjalnych zawodów. Dobrej jakości projekty mogą również stanowić bazę do pracy dyplomowej.


W przypadku konieczności przeprowadzanie zajęć zdalnie, wszelkie omówienia projektów i dyskusje będą się odbywały za pomocą narzędzi pozwalających na zbiorowe rozmowy, udostępnianie ekranu etc. (Discord, Google Hangout). Ogólne zasady przedmiotu nie ulegają zmianie."
History of Moral Reflection,5,,,False,True,"Prowadzący: dr Marcin Drofiszyn 
Katedra Logiki i Metodologii Nauk UWr
marcin.drofiszyn@uni.wroc.pl

W trakcie wykładów zostaną omówione najważniejsze szkoły i koncepcje etyki filozoficznej. Prezentacja będzie się odbywać w porządku historycznym. Każda koncepcja zostanie omówiona w trzech krokach. Pierwszy krok, to wyjaśnienie pytania na które jest ona odpowiedzią. (Do czego dążyć? Jak dobrze żyć i dobrze się mieć? Co powinienem?) W drugim kroku zostanie przedstawiona główna teza oraz argumenty, które za nią przemawiają. (Poznaj siebie! Spełniaj obowiązki! Maksymalizuj przyjemność!) W ostatnim kroku przedstawione argumenty zostaną skonfrontowane z krytycznymi głosami komentatorów.
Ćwiczenia będą polegały na wspólnym czytaniu i dyskutowaniu źródłowych tekstów dla koncepcji omawianych na wykładach."
Team Management,3,,,False,False,"_Przedmiot proponowany przez dr Alicję Lisowską z Instytutu Politologii UWr._

* GRUPA JAKO ZESPÓŁ PROJEKTOWY
Grupa. Problemy współpracy i godzenie interesów: grupa – pojęcie, spójność, normy, problemy międzygrupowe, role w grupie. Mniejszości w grupie.
Kwestionariusz samooceny. 
* ZESPÓŁ PROJEKTOWY
Dynamika zespołu. Cechy dobrego zespołu. Proces decyzyjny w zespole. Wady i zalety pracy zespołowej.
* KIEROWNIK PROJEKTU – ROLE W ZESPOLE PROJEKTOWYM 
Kierownik projektu – zadania, wiedza i umiejętności. Kompetencje społeczne. Style kierowania. Idealny kierownik. Test. 
* MOTYWACJA, SATYSFAKCJA Z PRACY I ZAANGAŻOWANIE
Motywacja i składniki motywacji – teorie. Proces motywowania – teorie. Satysfakcja z pracy – pomiar i uwarunkowania indywidualne. Czynniki określające zaangażowanie w pracę. Wynagrodzenie. 
* PATOLOGIE W ZESPOLE PROJEKTOWYM
Rodzaje zachowań nieetycznych i patologicznych podczas wykonywania pracy. Zachowania nieetyczne w świetle badań empirycznych. Spotkanie z gościem - mobbing."
Machine Learning,6,"* Lecture
* Programming assignments
* Written assignments
* Programming project

In case of further University lockdown the course will be offered remotely:
* Lectures will be delivered over a videconference system and recorded
* Assignments will be graded using a combination of automatic grading tools and presentations over conferencing systems
* The project will feature presentations given to other students
* The final exam may be held remotely in the form of quizzes and oral evaluations during 1-on-1 calls",,False,False,"_Wyklucza się&nbsp;z przedmiotem Sieci Neuronowe i Deep Learning zaliczonym do 2018/19._

**Informations for enrolled/prospective students**: all information is on SKOS (please self-enroll into [Machine Learning 2020](https://skos.ii.uni.wroc.pl/enrol/index.php?id=331)), materials are on [GitHub](https://github.com/janchorowski/ml_uwr), lectures will in-class, streamed and recorded.

This course provides the fundamentals Machine Learning, i.e. of designing programs that implement a data-driven, rather than hand-implemented behavior. The course provides a gentle introduction of the topic, but strives to provide enough details and intuitions to explain state-of-the-art ML approaches: ensembles of Decision Trees (Boosted Trees, Random Forests) and Neural Networks. Starting with simple linear and Bayesian models, we proceed to learn the concepts of trainable models, selecting the best model based on data, practical and theoretical ways of estimating model performance on new data, and the difference between discriminative and generative training. The course introduces mainstream algorithms for classification and regression including linear models, Naive Bayes, trees, ensembles, and matrix factorizations for recommendation systems. Practical sessions provide a hands-on experience with the methods."
Logical Methods in Computer Science,6,"wykład, rozwiązywanie zadań z komentowaniem, rozwiązywanie zadań programistycznych",,False,True,"Proponowany przedmiot jest kontynuacją Logiki dla Informatyków przeznaczoną dla studentów zainteresowanych teorią informatyki. Naszym celem jest rozszerzenie podstaw wiedzy z zakresu logiki matematycznej i dziedzin pokrewnych o narzędzia potrzebne do zaawansowanych studiów w obszarach związanych z logiką i weryfikacją czy teorią języków programowania. W tym celu chcemy skoncentrować się na podstawowych zagadnieniach trzech aspektów logiki matematycznej: algebry uniwersalnej, teorii dowodu i teorii modeli, z naciskiem na perspektywę i użyteczność w informatyce (w odróżnieniu od perspektyw matematycznej czy filozoficznej).

Przedmiot polecamy dla studentów pierwszego roku którzy _dobrze_ zdali LdI i zainteresowanych studentów wyższych lat studiów I stopnia; w wybranych przypadkach może też być właściwy dla studentów II stopnia pragnących wyrównać pewne braki materiału (tu konkretne zasady do ustalenia — FS).

W edycji 2021 przedmiot ma charakter ściśle eksperymentalny."
I/O-efficient Algorithms and Data Structures,6,"lectures, supervised problem solving, individual/collective problem solving, individual project",,False,False,"Traditional algorithms courses teach us that data is stored linearly, with each access costing constant time, regardless of its position and previous memory accesses. This is a major simplification of modern processors, where in fact memory consists of several levels where data might reside and with different access times for each one: fast but small caches, to RAM, to slow disks, where even modern caching consists of multiple levels.

In this course we will learn how to design algorithms and data structures taking advantage of this hierarchical structure. We will learn approaches such as: External Memory/Cache Oblivious/Write Optimized algorithms and data structures.
Additionally, the course will have an applied element in the form of C++ library for external memory algorithms: STXXL.
Students will be required to implement a selected algorithms, in the form of a project."
Seminar on Internet of Things,3,,,False,False,Celem seminarium jest zgłębienie tematyki Internet of Things.
Seminar: Combinatorial theory of finite automata,3,"Prezentacja, czytanie pracy naukowej, dyskusja.",,False,False,"Jest to seminarium badawcze, na którym będziemy omawiać (głównie) najnowsze prace dotyczące automatów skończonych (takich jak DFA i NFA) i ich własności matematycznych. Będą to przede wszystkim zagadnienia związane z problemami otwartymi.

Zapraszam przy tym chętnych do wspólnego rozwiązywania problemów. Będę proponować włączenie się do badań, co może zaowocować dobrą pracą magisterską/licencjacką/cokolwiek.
Będzie też miejsce na przeprowadzenie paru eksperymentów obliczeniowych.

Tematyka obejmuje automaty, języki regularne, algorytmy, złożoność obliczeniową problemów, metody matematyczne aplikowane do automatów (algebra, kombinatoryka, teoria grafów, teoria grup, teoria macierzy).
Seminarium powinno być interesujące między innymi dla osób którym podobała się pierwsza część wykładu z języków formalnych.
Poziom trudności będzie bardzo zróżnicowany, tak żeby każdy mógł znaleźć coś dla siebie. Konkretne propozycje będą pochodzić ode mnie, ale można zaproponować własny temat.

Nie trzeba posiadać głębokiej wiedzy z tych tematów, przede wszystkim jednak trzeba radzić sobie z czytaniem i rozumieniem prac naukowych."
Seminar: front-end programming frameworks,3,"* prezentacja seminaryjna
* dyskusja w trakcie prezentacji",,False,False,"Celem seminarium jest danie uczestnikom możliwości wglądu w burzliwie
rozwijający się obszar technologii wytwarzania interfejsów użytkownika
aplikacji przemysłowych, z naciskiem na technologie przeglądarkowe i mobilne.
Ostatnie lata to nie tylko bardzo szybki rozwój standardów przemysłowych
(HTML5, CSS3) i platform technologicznych (Android, iOS) ale również - języków
programowania tychże (Swift, Kotlin, Typescript, Dart).

Prezentacja przygotowana przez studenta powinna obejmować przygotowanie
makiety technologicznej w wybranej technologii. Prezentacja makiety będzie
podstawą do szerszego przedstawienia konkretnego rozwiązania, jego zalet i
perspektyw jak również potencjalnych ograniczeń.

Oczekuje się od studentów samodzielności technologicznej i dojrzałości
warsztatowej wystarczającej do udźwignięcia wyzwania polegającego na
samodzielnym rozpoznaniu wybranej przez siebie technologii.

**Propozycje obszarów:**

  * aplikacje mobilne  

    * aplikacje natywne - Swift/iOS, Java + Android SDK, Kotlin
    * aplikacje hybrydowe - Xamarin, Phonegap/Cordova, Flutter/Dart
    * technologie zastępcze dla natywnych - Nativescript, React native, Ionic
    * inne - UWP, PWA
  * aplikcje przeglądarkowe 
    * frameworki m.in. Angular, React, Vue
    * języki Javascript, Typescript

Mile widziana jest aktywność polegająca na samodzielnym zgłaszaniu propozycji
tematów spoza wskazanej listy."
Seminar on Blockchain and its applications,3,"Prezentacja, czytanie prac naukowych, dyskusja",,False,False,Celem seminarium jest zgłębienie technologii Blockchain i obszarów jej zastosowania w znacznie szerszym kontekście niż tylko w kryptowalutach.
Innovative Projects by Nokia,4,zespołowy projekt programistyczny,,False,False,"Projekty zespołowe zaproponowane przez pracowników Nokia i prowadzone przez
nich. Spotkania będą się odbywać w siedzibie firmy. Za zaliczenie projektu
student może otrzymać punkty ECTS (co najmniej 4) oraz zaliczenie wymogu
projektu zespołowego z programu studiów."
Deductive Verification,3,"lecture, individual programming tasks, blackboard problem solving",,False,False,"_This is a half-semester course offered in the second half of the spring
semester._

The course is an introduction to deductive verification building on the
foundational principles of Hoare logic and extending them to modern
applications of separation logic (state of the art is Facebook's Infer
verifier). Apart from theoretical exercises, we will spend some time working
with Why3 - a tool for deductive program verification.

Topics covered:

  * Hoare logic: foundations, formulation for an ML-like language, application to practical (automated) verification of programs

  * separation logic: motivation and foundations, possible approaches to automatization, other applications (e.g., in concurrency)"
Project: Mimiker operating system,6,"analiza kodu źródłowego, prezentacja, projekt programistyczny",,False,False,"Na zajęciach będziemy kontynuować rozwój uniksopodobnego systemu operacyjnego [Mimiker](https://github.com/cahirwpz/mimiker) dla platformy [Raspberry Pi](https://en.wikipedia.org/wiki/Raspberry_Pi). 
Postępy prac będą dokumentowane i publicznie udostępniane z pomocą rzutnika w holu koło sali 119 i na stronie internetowej [mimiker.ii.uni.wroc.pl](https://mimiker.ii.uni.wroc.pl/).

Ogólnie celem zajęć jest dodanie do jądra funkcji, które pozwolą na uruchomienie szerszego zestawu oprogramowania o otwartych źródłach, np. popularnych bibliotek, interpreterów języków programowania, gier. Będziemy się zajmować różnymi aspektami systemu w tym:

  * komunikacją międzyprocesową,
  * zarządzaniem procesami,
  * planowaniem procesów,
  * zarządzaniem pamięcią wirtualną,
  * wirtualnym systemem plików,
  * stosem sieciowym TCP/IP,
  * sterownikami urządzeń,
  * systemami plików.

Celem na najbliższy semestr jest wprowadzenie do Mimikera:

  * plików wykonywalnych konsolidowanych dynamicznie,
  * warstw buforujących dla wirtualnego systemu plików,
  * trwałych systemów plików z dziennikowaniem,
  * lepszej infrastruktury do testowania jądra,
  * warstwy uruchomieniowej dla platformy RISC-V.

Zadania będą dobierane indywidualnie, w zależności od stopnia wdrożenia studenta w projekt. Po przydziale zadania studenci mają się zapoznać z kodem i dokumentacją jądra systemu NetBSD i pochodnych. Po rozpoznaniu i zreferowaniu problemu należy przystąpić do projektowania rozwiązania. W trakcie implementacji studenci muszą przeprowadzić inspekcję kodu (ang. _code review_). Kluczowym kryterium oceny wprowadzanych zmian jest poprawność i czytelność kodu.

**Dla nowych członków:** Szacowana liczba godzin pracy własnej studenta na tydzień wynosi około 8h. Spodziewam się umiejętności samodzielnego rozwiązywania problemów i dobrej komunikacji. Ocena będzie wypadkową: nakładu pracy, osiągniętych efektów oraz uczestnictwa w _code review_ lub pisaniu dokumentacji. W poniedziałki robimy podsumowanie zeszłego tygodnia i piszemy krótkie sprawozdania. Przydzielenie tematu pracy dyplomowej następuje po wdrożeniu w projekt, które trwa jeden semestr."
Algorithmic seminar,3,"prezentacja, samodzielna lektura prac naukowych",,False,False,"**Przedmiot nie będzie się odbywać w trybie zdalnym**

Seminarium poswięcone będzie bieżącym osiągnięciom algorytmicznym. W jego ramach omawiane będą wybrane wyniki zaprezentowane w ostatnich latach na wiodących konferencjach algorytmicznych. W celu umożliwienia w miarę szerokiego wyboru tematów, zajęcia te mają dwóch prowadzących: Marcina Bieńkowskiego i Jarosława Byrkę.

**UWAGA:** Seminarium odbywa się corocznie i można w nim brać udział wielokrotnie. 

Przedmiot dostępny również dla doktorantów.

**Wymagania wstępne**

Zrealizowane przedmioty:

* Algorytmy i struktury danych

Niezbędne kompetencje:

* Umiejętność konstrukcji i analizy algorytmów.
* Mile widziana znajomość jednego z działów zaawansowanej algorytmiki, np. algorytmów probabilistycznych, aproksymacyjnych, online,  grafowych, tekstowych lub rozproszonych.

Lista prezentacji z poprzednich edycji znajduje się pod adresem https://sites.google.com/cs.uni.wroc.pl/marcinbienkowski/algorithmic_seminar"
Word Equations,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Consider equations over words over an alphabet Σ. This problem was initially studied due to its connection with Hilbert's 10th problem and connections with
group theory. Contrary to early intuitions, it was shown to be decidable
by Makanin in his seminal result.
Modern approach to this problem are based on  compression which leads to much simpler solution and in particular does not depend on word combinatorics.

Over the years, several generalisations of the problem were considered, those include description of all solutions, equations with (regular) constraints, equations with inversion, equations in free group, generalisation to term equations (context unification), etc.
In most cases the known algorithms generalise to those setting, sometimes trivially and sometimes in an involved way.

On the other hand, simplified variants were also investigated, those include equations with one or two variables (for which polynomial-time algorithms are known) or quadratic word equations (which have a very simple linear-space algorithm).

Lastly, combinatorial properties of solutions of word equations were also investigated, mostly in the case of equations without constants. Several characterizations of various equations classes were obtained.

During this lecture I would like to present a couple of classical and new
results for word equations and their generalisations: decidability of
satisfiability, generation of all solutions, algorithms for restricted variants
(quadratic, one variable, two variables), combinatorial properties of solutions sets (mostly in case of constant-free equations).


The lecture can be in English, depending on the audience.

Requirements:

  * basic knowledge of algebra (groups);
  * basic knowledge of computational complexity classes, in particular non-deterministic ones and space classes;
  * knowledge in string algorithms and combinatorics is helpful and welcomed, but not assumed;
  * general knowledge and skills in discrete mathematics.

Literature:

  1. M. Lothaire, Algebraic combinatorics on words, Encyclopedia of Mathematics and its Applications 90, Cambridge University Press, ISBN 978-0-521-81220-7

  2. Some contemporary research papers.




W problemie równań słów rozważamy równania nad słowami z ustalonego alfabetu
Σ. Problem ten był intensywnie badany ze względu na swoje związki z 10.
problemem Hilberta oraz teorią grup. Wbrew oczekiwaniom, okazał się
rozstrzygalny (słynny algorytm Makanina).
Współczesne podejście do tego problemu opiera się na kompresji, która prowadzi do znacznie prostszego rozwiązania i mniej opiera się na kombinatoryce słów.

Na przestrzeni lat rozważano kilka uogólnień tego problemu, w tym opis wszystkich rozwiązań, równania z (regularnymi) ograniczeniami, równania z inwersją, równania w grupach wolnych, uogólnienie na równania terminowe (unifikacja kontekstowa), itd.
W większości przypadków znane algorytmy uogólniają się do tych ustawień, czasem trywialnie, a czasem w sposób skomplikowany.

Z drugiej strony, badane są również warianty uproszczone, takie jak równania z jedną lub dwiema zmiennymi (dla których znane są algorytmy wielomianowe) lub równania kwadratowe słownikowe (dla których istnieje bardzo prosty algorytm liniowo-przestrzenny).

Wreszcie, badane są również własności kombinatoryczne rozwiązań równań słownych, głównie w przypadku równań bez stałych. Uzyskano kilka charakterystyk różnych klas równań.

W czasie wykładu chciałbym przedstaw kilka (klasycznych oraz nowych) wyników
dotyczących równań słów i ich uogólnień: rozstrzygalność, generacja rozwiązań,
ograniczone przypadki (równania kwadratowe, równania z jedną&nbsp;zmienną, równania z dwoma zmiennymi),
własności kombinatoryczne zbiorów rozwiązań (głównie w przypadku równań bezstałych).

Wykład może być prowadzony po angielsku (w zależności od preferencji
słuchaczy).

Wymagania:

  * podstawowa znajomość algebry (grupy);
  * podstawowa znajomość klas złożoności obliczeniowej, w tym klas niedeterministycznych oraz klas pamięciowych;
  * znajomość algorytmów tekstowych i kombinatoryki słów będzie chwilami pomocna, ale nieobowiązkowa;
  * ogólne obycie z matematyki dyskretnej.

Literatura:

  1. M. Lothaire, Algebraic combinatorics on words, Encyclopedia of Mathematics and its Applications 90, Cambridge University Press, ISBN 978-0-521-81220-7

  2. Kilka współczesnych prac naukowych."
Practical aspects of computer networks,5,,,False,False,"Kurs jest uzupełnieniem wiedzy zdobytej na przedmiocie Sieci Komputerowe i/lub CCNA o wiedzę praktyczną z zastosowań wybranych technologii sieciowych z dużym naciskiem na bezpieczeństwo omawianych technologii. Większość omawianych zagadnień będzie do zaimplementowania na specjalnie do tego celu przygotowanych maszynach wirtualnych oraz zajęciowych urządzeniach, żeby jak najlepiej pokazać ich praktyczne zastosowania w firmach i instytucjach.
Podczas kursu omawiane będą (między innymi) zagadnienia budowania i administracji sieciami i systemami takie jak:  
  
\- Bezpieczeństwo sieci  
\-- zagadnienia takie jak: SIEM, IEEE 802.1x, Radius, VLANy, port-security, MACsec, xyz-snooping, IDS, IPS, itp.)
  
\- Sieci bezprzewodowe  
\-- WiFi 6 (802.11ax), WPA3, PMF, punkty dostępu, zarządzanie, zabezpieczenia, problemy, standardy, bezpieczeństwo  
  
\- Wirtualne sieci prywatne  
\-- VPN (IPsec, pptp, OpenVpn, WireGuard, IKEv2, ...)  
  
\- Sieci pamięci masowej  
\-- DAS, NAS, SAN, iSCSI, FibreChannel, InfiniBand, vSAN, CEPH, ZFS, wirtualizacja pamięci masowych, bezpieczeństwo w sieciach pamięci masowych
  
\- Routing i stos TCP/IP w linuksie, Cisco, Juniper, Ubnt, Mikrotik, itp.  
  
\- Protokoły i problemy współczesnych sieci (IPv4 -> IPv6, BGP, MPLS, TCP BBR, SD-LAN, SD-WAN itp.)

\- IPv6 oraz zagadnienia związanie z wdrażaniem i integracją z istniejącymi sieciami oraz związane z tym zagadnienia dotyczące bezpieczeństwa sieci  
  
\- Firewall/ACL (iptables, pf, policy routing, ZBF)  

\- Zagadnienia związane z wysoką wydajnością oraz rozkładaniem obciążeń  
\-- proxy, reverse proxy, loadbalancing, link aggregation, ha, clustering (linux i inne)  
  
\- Wirtualizacja oraz tzw. Cloud Computing  
\-- np. VMware, KVM, qemu, XEN, OpenStack, Proxmox  
  
\- Konteneryzacja oraz sieci dla kontenerów  
\-- na przykładzie Docker, LXC, Kubernetes  
  
\- Bezpieczeństwo wirtualizacji/cloud computingu/kontenerów  
  
\- Problemy maszyn wirtualnych i kontenerów (i/o, RTC, thin-provisioning, starvation, overbooking, sieci wewnętrzne, ...)  
  
\- Wirtualizacja sieci  
\-- wirtualne switche, routery, karty sieciowe, adresy...  

Tematyka zajęć jest otwarta, więc w zależności od zainteresowań uczestników związanych z tematyką wykładu (oczywiście w zakresie kompetencji prowadzącego) program może ulec zmianie. Jeżeli będzie istniała taka możliwość na zajęciach odbędą się prezentacje/praktyczne pokazy wybranych technologii współczesnych sieci i systemów, np. prezentacje dostawców.

Warunkiem uczestnictwa w zajęciach jest ukończenie przedmiotu ""Sieci Komputerowe"", szkolenia Cisco CCNA lub podobnego w zakresie szkolenia z zakresu sieci, i/lub deklaracja znajomości zagadnień z zakresu materiału w/w kursów. Wykład może być prowadzony w języku polskim lub angielskim."
Computational learning theory,6,"Lecture, blackboard problem-solving, homeworks.",,False,False,"The lecture presents theory behind machine learning. We will cover the following topics:

Introduction to PAC:
1. Introduction to PAC. Learnability of particular classes of concepts (DNF formulas, automata)
2. Occam's razor in the PAC context. PAC-reducibility.

Which concepts are lernable:

3. Growth functions and the VC-dimension. 
4. Rademacher's complexity and the margin theory.

Leraning methods:

5. Support Vector Machines. Kernels.
6. Boosting. 

Other learning frameworks:

7. Online learning.
8. Reinforcement learning.
9. Combination methods.

The lecture can be given in English or Polish; we will decide after the first lecture. 

The lecture and classes will be held remotely in case of lockdown in the autumn 2021."
Text mining,6,"Wykład, prezentacja, rozwiązywanie zadań z komentowaniem, dyskusja, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze, indywidualny projekt programistyczny",,False,False,"Eksploracja tekstów jest dziedziną, w której badamy sposoby i możliwości efektywnej analizy (dużych) zbiorów danych tekstowych. Znajduje się ona na przecięciu wyszukiwania informacji, eksploracji danych oraz przetwarzania języka naturalnego (takiego jak polski czy angielski).
Z racji tego, że coraz więcej danych jest dostępnych w postaci kolekcji dokumentów, eksploracja tekstów ma coraz większe znaczenie.  

Na wykładzie będziemy zajmować się wszystkimi etapami eksploracji tekstów i wyszukiwania informacji, kładąc nacisk na przedstawienie praktycznych i efektywnych rozwiązań, sczególnie w sytuacji, w której analizowany zbiór dokumentów ma rozmiar rzędu kilku gigabajtów tekstu (na przykład cała Wikipedia).

Omówimy wstępne przetwarzanie tekstów, sposoby wyszukiwania pełnotekstowego, budowę efektywnego silnika, tworzącego dla zapytań rankingi (relewantnych) dokumentów. Omówimy sposoby zadawania zapytań, z dużym naciskiem na automatyczną korektę błędów (spelling correction).

Zajmiemy się również zadaniem klasyfikacji. Na wykładzie zostaną też omówione pewne współczesne mechanizmy związane ze znajdywaniem reprezentacji wektorowej słów wywodzące się z sieci neuronowych (m.in. word2vec oraz GloVe) i praktyczne konsekwencje użycia tych reprezentacji w różnych zadaniach eksploracji tekstów. Będą również omówione metody wizualizacji tekstów i słów.


W przypadku konieczności organizowania zajęć w formie zdalnej, studenci otrzymają nagrane wykłady, ćwiczenia będą w przeprowadzone z deklaracjami i wspólną pracą nad Raportem z ćwiczeń, zadania na pracownie będą konsultowane i odbierane przy użyciu systemu telekonferencyjnego."
Discrete Mathematics,6,"Wykład, prezentacja, dyskusja, rozwiązywanie zadań z komentowaniem.",,False,False,"**Cel zajęć** : zapoznanie z podstawowymi pojęciami i technikami matematyki dyskretnej.

**Program:**
1. Asymptotyka funkcji liczbowych w zastosowaniu do szacowania złożoności algorytmów.
2. Elementy kombinatoryki: permutacje, podziały, wariacje z powtórzeniami i bez powtórzeń, współczynniki dwumianowe, liczby Catalana.
3. Metody zliczania, w tym zasada włączeń-wyłączeń oraz zasada Dirichleta.
4. Rekurencje i rozwiązywanie równań rekurencyjnych. Metoda anihilatorów.
5. Elementarna teoria liczb: podzielność, liczby pierwsze, rozkład na czynniki pierwsze, NWD i algorytm Euklidesa.
6. Arytmetyka modularna: małe twierdzenie Fermata i twierdzenie Eulera, chińskie twierdzenie o resztach.
7. Funkcje tworzące.
8. Teoria grafów: grafy dwudzielne, grafy skierowane, ścieżki i spójność, drzewa, obliczanie drzewa rozpinającego o minimalnej wadze, metody przeszukiwania grafów, skojarzenia, twierdzenie Halla, cykle Eulera i Hamiltona, planarność, kolorowalność wierzchołkowa grafu, znajdowanie najkrótszych ścieżek, przepływy w sieciach.
  
**Wymagania:**
1. Podstawy logiki i teorii mnogości.
2. Podstawy algebry.
3. Podstawy analizy matematycznej."
Seminar: Information Safety and Security,3,"- samodzielny wybór i lektura materiałów
- przygotowanie i wygłoszenie prezentacji
- uczestnictwo w dyskusji",,False,False,"Seminarium dotyczy praktycznych metod wykrywania niepowołanego dostępu do informacji i zabezpieczania się przed
utratą informacji.

**Program:**

Co najmniej 14 referatów poświęconych następującym zagadnieniom:

- przestępstwa "" komputerowe"",

- sposoby wykrywania włamań i gromadzenie dowodów przestępstw,

- metody zabezpieczania informacji,

- ekspertyzy sądowe z zakresu informatyki,

- zgodne z RODO i innymi standardami wytwarzanie oprogramowania,

- zgodna z RODO i innymi standardami eksploatacja oprogramowania,

- obowiązki Security Officer."
Digital Archeology,3,Prezentacja,,False,False,"_Nanos gigantum humeris insidentes_ — Bernard z Chartres

Proseminarium jest poświęcone omówieniu technologii informatycznych
(w tym systemów, języków programowania, architektur komputerów itp.)
oraz teorii, które odegrały ważną rolę w rozwoju informatyki, ale
odeszły już w niepamięć lub mają obecnie tylko niszowe znaczenie.
Każde poruszane zagadnienie powinno być starsze niż przedstawiający je
prelegent. Wybór tematów zależy od preferencji słuchaczy. Mogą to być
krótkie kursy klasycznych języków programowania (np. Algol 60, Cobol,
Fortran, PL/1), omówienie architektury słynnych systemów komputerowych
(np. CDC Cyber, IBM/360, IBM PC/XT) i systemów operacyjnych (np. OS/360,
RSX-11, CP/M, MS DOS, BeOS) lub ważne prace teoretyczne (np. _On
Computable Numbers, With an Application to the Entscheidungsproblem_
Alana Turinga, 1937 lub _Go To Statement Considered Harmful_ Edsgera
Dijkstry, 1968)."
Seminar: Artificial Intelligence for Games,3,"Prezentacja, czytanie prac naukowych, dyskusja.",,False,False,"Seminarium jest w pewnym sensie kontynuacją wykładu ""Artificial Intelligence for Games"".

Po pierwsze, chciałbym abyśmy przedstawiali na nim tematy zaawansowane, które z różnych względów nie zmieściły się na wykładzie. Po drugie, seminarium ma umożliwić bycie na bieżąco z najważniejszymi osiągnięciami w dziedzinie - będziemy więc na nim referować najciekawsze prace publikowane na konferencjach i w czasopismach związanych z tematyką (GECCO, CEC, COG, IJCAI, ACG, EvoSTAR, AIIDE, Transactions on Games, GAme AI Pro) oraz omawiać wyniki i prezentować algorytmy z zawodów AI odbywających się w ramach tych konferencji.

W szczególności, w tegorocznej edycji chciałbym poświęcić trochę miejsca na Procedural Content Generation oraz wykorzystanie AI w grach komercyjnych (no chyba, że znów nam ""zejdzie"" na MCTS i spółkę ;]).

Zainteresowani będą mieli okazję włączenia się do badań, co może stanowić podstawę do pracy magisterskiej lub licencjackiej/inżynierskiej."
Information Systems Security,6,"* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Wykład",,False,False,"Celem zajeć jest przegląd różnych aspektów bezpieczeństwa systemów
informatycznych głównie od strony ich tworzenia i rozwoju, ale również z
punktu widzenia ich utrzymania. Wszystkie prezentowane zagadnienia będą
podparte stroną praktyczną, czyli przeglądem produktów dostępnych na rynku
wraz, jeśli będzie to uzasadnione, przykładowymi aplikacjami.

##### **Program**

  1. Bezpieczeństwo informacji
    * wprowadzenie do zagadnienia
    * podstawy kryptografii
  2. Certyfikaty, podpisy elektroniczne, znaczniki czasu
    * podstawy teoretyczne, PKI, zastosowania certyfikatów
    * certyfikaty dostępne na rynku, rola Narodowego Centrum Certyfikacji, usługi kwalifikowane
    * strona praktyczna, przegląd rozwiązań, tworzenie własnych centrów certyfikacji
  3. Uwierzytelnianie i autoryzacja
    * komponenty składowe rozwiązania i ich rola
    * znaczenie w różnych warstwach sieciowych
    * przegląd protokołów i rozwiązań dostępnych na rynku, w tym NTLM i Kerberos
    * mechanizmy kontroli dostępu, w tym RBAC & ABAC
    * procesy związane zarządzaniem tożsamościami i dostępem
  4. Federacja tożsamości i delegacja autoryzacji
    * protokoły OAuth2, OpenID Connect i XACML
    * bezpieczeństwo w różnych typach architektury
    * integracja z usługami firm trzecich: SMS, systemy płatności, Auth0, Google, Facebook
  5. Bezpieczeństwo baz danych
    * przykład rozwiązań proponowanych przez Microsoft SQL Server
  6. Bezpieczeństwo sieci i infrastruktury
    * bezpieczeństwo z punktu widzenia wartsw sieci, sieci bezprzewodowe
    * przegląd komponentów jak firewalle, proxy, IDS/IPS, WAF
    * znaczenie monitoringu, rola SIEM
    * scenariusze użycia TPM, HSM, TEE, SGX
  7. Bezpieczeństwo rozwiązań chmurowych i IoT
  8. Architektura zabezpieczeń
    * znaczenie dobrych wymagań
    * rodzaje kontrolek i ich zastosowanie
    * przegląd i znaczenie podstawowych zasad bezpieczeństwa (ang. security principles)
    * przegląd warstw architektury i ich rola
    * koncepcja tzw. security domains
  9. Testowanie bezpieczeństwa 
    * testy penetracyjne i skany podatności, rodzaje, metodyki
    * przegląd narzędzi do przeprowadzania testów
    * wprowadzenie do hakowania
  10. End-to-end protection i modelowanie zagrożeń
    * metodyka STRIDE, zastosowanie narzędzi wspierających
    * baza CVE/CWE, kalkulator CVSS
    * zagrożenia w świecie aplikacji WWW i mobilnych (rankingi OWASP) 
    * przepływy informacji i ich zabezpieczenie
    * kompletność bezpieczeństwa rozwiązania
  11. Bezpieczeństwo w procesie wytwarzania oprogramowania
    * omówienie procesu, przegląd głównych etapów
    * przegląd ważniejszych aktywności, m.in. zbieranie wymagań, analiza ryzyka, modelowanie zagrożeń.
  12. Zapewnienie ciągłości działania 
    * określenie celów i obszarów krytycznych
    * utworzenie planów i scenariuszy na różnych poziomach
    * testowanie, utrzymywanie i audyt
  13. Znaczenie wprowadzenia i utrzymywania polityki bezpieczeństwa
  14. Przegląd nowości z obszaru bezpieczeństwa"
Fine-grained complexity,6,"Wykład, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów, indywidualny/zespołowy projekt programistyczny",,False,False,"Przedmiot będzie prowadzony przez dwie osoby: Bartłomieja Dudka i Pawła Gawrychowskiego.

Złożoność drobnoziarnista (fine-grained complexity) jest aktualnie jednym z najbardziej dynamicznie rozwijających się kierunków algorytmiki. Prace poświęcone tej tematyce regularnie pojawiają się na topowych konferencjach typu STOC/FOCS/SODA/ICALP, a poświęcone jej wykłady są prowadzone na najlepszych uczelniach zarówno w Europie (ETH, Saarbruecken), jak i w USA (MIT, Stanford, Harvard). Celem tych zajęć będzie wprowadzenie i przedstawienie najciekawszych (w naszej ocenie) wyników w tej dziedzinie.

Celem fine-grained complexity jest klasyfikacja problemów rozwiązywalnych w czasie wielomianowym. Przykładowo, w problemie APSP chcemy znaleźć odległość między każdą parą wierzchołków w danym ważonym grafie skierowanym. Nie jest trudno rozwiązać ten problem w czasie O(n^3), co być może zaskakujące nie znamy istotnie szybszego algorytmu. Ale jednocześnie nie potrafimy udowodnić, że takiego nie ma! Naturalne jest więc rozważanie całej klasy problemów, które są równoważne APSP (w odpowiednio zdefiniowanym sensie): rozwiązanie dowolnego z nich w czasie O(n^{3-eps}) sprawi, że uzyskamy istotnie szybsze rozwiązanie dla wszystkich innych.

Wśród technik przedstawianych na wykładzie znajdzie się sporo takich, które powinny być przystępne już dla studentów, którzy zaliczyli zajęcia z Matematyki Dyskretnej (a z całą pewnością dla tych, którzy zaliczyli Algorytmy i Struktury Danych). Pojawią się jednak także (szczególnie na ćwiczeniach) pomysły nieco trudniejsze, których zrozumienie może być dobrym wstępem do ambitnej pracy magisterskiej."
Seminar: Reinforcement learning for games,3,"Prezentacja, czytanie pracy naukowej, dyskusja.",,False,False,"Jest to seminarium badawcze, na którym będziemy omawiać najnowsze prace dotyczące uczenia ze wzmocnieniem (w szczególności Deep Q Learning) do tworzenia agentów dla gier.
Będziemy zajmować się głównie grami klasycznymi, ale mogą pojawić się też współczesne gry czasu rzeczywistego. Oprócz zastosowania do konkretnych gier, pojawią się też takie tematy jak Mu Zero, Deep Learning w General Game Playing i obecnie rozwijane frameworki."
Programming languages,7,"wykład, dyskusja, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań, indywidualny/zespołowy projekt programistyczny",,False,False,"Język programowania stanowi podstawowe narzędzie informatyka. Teoria  języków programowania dostarcza środków umożliwiających obiektywną ocenę i porównanie istniejących języków programowania oraz poszczególnych konstrukcji w nich występujących, a także projektowanie i implementację nowych języków z zapewnieniem pewnych własności, które są kluczowe z punktu widzenia poprawności implementacji oraz pragmatyki programistycznej. Wspiera ona także wnioskowanie o samych programach, pozwalając na ich mniej lub bardziej sformalizowaną weryfikację i optymalizację.

Przedmiot ten jest wprowadzeniem do fundamentalnych zagadnień związanych z projektowaniem, semantyką i implementacją języków programowania, prezentowanych w systematyczny i rygorystyczny sposób przy użyciu wybranego formalizmu matematycznego. Przedmiot skupia się na opisie semantyki operacyjnej oraz systemów typów najważniejszych konstrukcji językowych występujących w popularnych językach programowania, jednocześnie wprowadzając niezbędny zestaw narzędzi pozwalający na formalne wnioskowanie o językach programowania (i samych programach), konstruowanie nowych języków z zapewnieniem semantycznej poprawności ich definicji, a także implementację języków programowania opartą na ich matematycznej definicji."
Discrete Mathematics,9,"wykład, wykład interaktywny, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów",,False,False,"Celem przedmiotu jest przedstawienie elementów matematyki, które są szczególnie użyteczne dla informatyków i nie są częścią standardowego wykładu algebry, analizy czy rachunku prawdopodobieństwa. W szczególności są to przydatne informatykowi elementy teorii liczb, kombinatoryki i teorii grafów. Wiedza w tym zakresie jest przydatna w konstruowaniu i analizie algorytmów, w tym weryfikacji poprawności i szacowaniu złożoności obliczeniowej."
UNIX kernel design,6,"Wykład, rozwiązywanie zadań z komentowaniem, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, indywidualna analiza kodu źródłowego, samodzielna praca przy komputerze, indywidualny projekt programistyczny.",,False,False,"Celem wykładu jest przedstawienie organizacji wewnętrznej jądra systemu operacyjnego [FreeBSD](https://www.freebsd.org), który wyrósł ze źródeł oryginalnego systemu Unix z początku lat '80. FreeBSD znajduje zastosowanie np. w konsolach _Sony Playstation_ i chmurze _Netflix_. W trakcie naszej przygody będziemy zaglądać do pozostałych jąder z rodziny BSD, tj: [OpenBSD](https://www.openbsd.org/), [NetBSD](https://www.netbsd.org/), [DragonFlyBSD](https://www.dragonflybsd.org/). Nauka programowania sterowników dla systemu _FreeBSD_ nie jest częścią tych zajęć.

Na ćwiczeniach będziemy omawiać wybrane podsystemy jądra oraz najciekawsze algorytmy i struktury danych bazując na [źródłach FreeBSD](http://bxr.su/FreeBSD/sys/kern/). 

Celem pracowni programistycznej jest otrzymanie małego systemu z prostą uniksową powłoką, kilkoma użytecznymi programami (`grep`, `cat`, `kill`, ...) i edytorem pełnoekranowym. Będziecie uzupełniać wybrane podsystemy istniejącego szkoleniowego systemu operacyjnego:

 * sterownik terminala,
 * zarządzanie procesami,
 * wywołania systemowe,
 * system plików,
 * komunikacja z użyciem potoków,
 * obsługa sygnałów.

**UWAGA!** Zaliczenie tych zajęć jest mocno wskazane do uczestnictwa w projekcie Mimiker.

##### Tematy wykładów

1. Model prostej maszyny:
   * model programowy: rejestry i stos,
   * tryby pracy procesora,
   * rejestry i zasoby uprzywilejowane,
   * przerwania: wektor, priorytety, EOI,
   * komunikacja z peryferiami i transfery DMA,
   * podstawowe peryferia: czasomierz i port szeregowy,
   * pułapki i dane o błędach.
2. Organizacja dyspozytora:
   * górna i dolna połówka,
   * kolejki zadań aktywnych,
   * przechowywanie kontekstu zadania,
   * dobrowolna zmiana kontekstu,
   * blokowanie przerwań i _priority level_,
   * algorytm obsługi przerwań i łańcuchy procedur obsługi,
   * obsługa pułapek, `trapframe` i poprawianie kontekstu,
   * realizacja i blokowanie wywłaszczania.
3. Podstawowe usługi jądra:
   * zarządzanie pamięcią,
   * struktura opisująca zadanie i jego kontekst,
   * globalne struktury planisty i dyspozytora,
   * zegara systemowy i mierzenie czasu,
   * realizacja sekcji krytycznych,
   * blokowanie, usypianie i wznawianie zadań,
   * rozruch planisty i zadanie jałowe,
   * wątki obsługi przerwań.
4. Obsługa zdarzeń:
   * rodzaje kontekstów i snu,
   * zegar systemowy `hardclock` i wywłaszczanie,
   * kolejki wątków aktywnych `runqueue` i priorytety wątków,
   * przełączanie zadań `mi_switch`,
   * kolejki wątków uśpionych `sleepqueue`,
   * obsługa terminów `callout`,
   * główna procedura obsługi przerwań i zdarzenia sprzetowe `intr_event`,
   * wątki obsług przerwań `ithread`,
   * realizacja wywłaszczania `ast` i `userret`,
   * blokowanie wątków `turnstile`,
   * tłumaczenie pułapek na sygnały i obsługa błędów,
   * implementacja wywołań systemowych `sysent`,
   * bezpieczne kopiowanie danych `copyin` i `copyout`.
5. Synchronizacja w systemach jedno i wieloprocesorowych:
   * instrukcje atomowe, bariery pamięciowe i blokady wirujące,
   * problem fałszywego współdzielenia i przeciążenia magistrali,
   * przerwania międzyprocesorowe,
   * wyłączanie przerwań i wywłaszczania,
   * hierarchia blokad i zabronione konfiguracje,
   * projektowanie oprogramowania z użyciem blokad – domeny blokowania,
   * usypianie `sleep` i wybudzanie wątków `wakeup`,
   * omówienie implementacji `sleepqueue`,
   * problem odwrócenia priorytetów i dziedziczenie priorytetów,
   * łańcuchowa propagacja priorytetów,
   * omówienie implementacji `turnstile`.
6. Środki synchronizacji:
   * interfejs blokad `lock`,
   * blokady wirujące `MTX_SPIN` i algorytm _back-off_,
   * blokady adaptacyjne `MTX_DEF`,
   * blokady współdzielone `rwlock` i zapobieganie głodzeniu,
   * zmienne warunkowe `cv`,
   * blokady wirtualnego systemu plików `lockmgr`,
   * strategie korzystania z blokad – zapobieganie zakleszczeniom i współzawodnictwu,
   * wykrywanie zakleszczeń z użyciem `witness`.
7. Obsługa terminów i planowanie zadań:
   * rejestrowanie i przetwarzanie terminów `callout`,
   * omówienie struktury kolejki kalendarzowej,
   * klasy szeregowania zadań i algorytm _multilevel feedback queue_,
   * klasyczny algorytm szeregowania `sched_4bsd`,
   * wyznaczanie średniego obciążenia systemu,
   * algorytm dla systemów wieloprocesorowych `sched_ule`,
   * problemy z szeregowaniem w systemach wieloprocesorowych,
   * topologia systemu i równoważenie obciążenia,
   * interfejs planisty `csf`.
8. Zarządzanie procesami:
   * zasoby procesu: wątki, przestrzeń adresowa, tablica deskryptorów, kredencjały,
   * stan procesu vs. stan wątków,
   * struktury przechowujące procesy i ich blokady,
   * leniwe kopiowanie przestrzeni adresowej,
   * wstrzymywanie wszystkich wątków w procesie,
   * ładowanie programów i aktywatory obrazów,
   * omówienie implementacji `fork`, `exit` i `execve`.
9. Sygnały, grupy procesów i sesje:
   * rejestracja procedur obsługi sygnałów,
   * domyślne akcje i właściwości sygnałów,
   * wysyłanie sygnałów `psignal` i `pgsignal`,
   * dostarczanie sygnałów `postsig` i `sendsig`,
   * przygotowanie kontekstu procesu do obsługi sygnału,
   * powrót z procedury obsługi sygnału `sigreturn`
   * oczekiwanie na zmianę stanu procesu `waitpid`,
   * wchodzenie i opuszczanie grupy procesów: `enterpgrp` i `leavepgrp`,
   * sesje, lider sesji, terminal sterujący.
10. Zarządzanie tablicą stron:
    * rozruch jądra w adresach wirtualnych,
    * reprezentacja ramek `vm_page`,
    * wprowadzanie `pmap_enter` i usuwanie `pmap_remove` odwzorowań,
    * zmiana uprawnień odwzorowań `pmap_protect`,
    * przełączanie przestrzeni adresowej `pmap_activate`,
    * interakcje z buforem translacji adresów TLB i zestrzeliwanie wpisów (_TLB shootdown_),
    * emulowanie bitów `referenced` i `modified`,
    * odwzorowania odwrotne `pv_entry`,
    * obsługa dużych stron `superpages`.
10. Zarządzanie pamięcią jądra:
    * przydział pamięci fizycznej `buddy`,
    * reprezentacja przestrzeni adresowej jądra `vm_map`,
    * przydział przestrzeni adresowej `vmem`,
    * alokator płytowy `slab`,
    * algorytm strefowy i zarządzanie `bucket` oraz `keg`,
    * omówienie ogólnego algorytmu przydziału pamięci `kmalloc`.
11. Zarządzanie przestrzenią adresową:
    * obiekty wspierające `vm_object` – anonimowe nazwane i przesłaniające,
    * obsługa błędu strony `vm_fault`,
    * odwzorowania prywatne i dzielone,
    * programy stronicujące `pager` dla obiektów nazwanych i pamięci anonimowej,
    * kompresja łańcuchów odwzorowań przesłaniającyh,
    * algorytm zastępowania stron,
    * usługa stronicowania `pageout daemon`.
13. Operacje na plikach:
    * tablica deskryptorów `filedesc` i reprezentacja plików `file`,
    * pliki strumieniowe i o swobodnym dostępie.
    * współdzielenie otwartych plików
    * interfejs operacji na plikach `fileops`
    * punkty wejścia do wirtualnego systemu plików – pliki zwykłe oraz katalogi,
    * komunikacja między procesowa – potoki,
    * nieblokujące operacje wejścia-wyjścia `select` i `kqueue`.
14. Wirtualny system plików:
    * węzły wirtualnego systemu plików `vnode` i `vnodeops`,
    * punkty montażowe `mount` i `vfsops`,
    * zarządzanie węzłami i buforami,
    * tłumaczenie ścieżek na węzły `iname`,
    * pamięć podręczna tłumaczenia ścieżek `namecache`,
    * buforowanie bloków `bread` i `bwrite`."
Embedded systems,6,"wykład, rozwiązywanie zadań z komentowaniem, samodzielna praca przy komputerze, prototypowanie układów elektronicznych",,False,False,"Wykład jest wprowadzeniem do programowania systemów wbudowanych. W ramach
wykładu student zapozna się z architekturą popularnych mikrokontrolerów,
nauczy się wykorzystywać ich peryferia do sterowania różnorodnymi urządzeniami
zewnętrznymi, a także pozna popularne magistrale używane w systemach
wbudowanych.

#### Wymagania

  * Znajomość języka ANSI C
  * Wskazana znajomość podstaw architektur systemów komputerowych

#### Program

  1. Podstawy systemów wbudowanych
  2. Architektura mikrokontrolerów serii AVR ATmega
  3. Programowanie w języku C na mikrokontrolerach
  4. Podstawy elektroniki
  5. Porty GPIO
  6. Modulacja PWM i PFM
  7. Przetworniki ADC i DAC
  8. Obsługa przerwań
  9. Zarządzanie energią
  10. Magistrale SPI, I2C, CAN
  11. Sterowanie silnikami
  12. Podstawy teorii sterowania
  13. Prototypowanie i produkcja układów elektronicznych
  14. Podstawy systemów operacyjnych czasu rzeczywistego (RTOS)

#### Literatura

  * Make: AVR programming; Elliot Williams; Maker Media, Inc.  
Wydanie polskie: Programowanie układów AVR dla praktyków; Elliot Williams;
Helion

  * Designing Embedded Hardware; John Catsoulis; O'Reilly
  * Lessons in Electric Circuits; Tony R. Kuphaldt"
EU economic policy,5,,,False,False,"**Przedmiot będzie prowadzony przez dra hab. Radosława Kupczyka z Katedry Studiów Europejskich WNS UWr.**

Celem zajęć jest zapoznanie studentów z problematyką prowadzenia polityki gospodarczej,  która pozwala zrozumieć decyzje podejmowane przez instytucje krajowe (rząd, bank centralny) w celu zarządzania gospodarką. Przedmiot tłumaczy również funkcjonowanie systemu gospodarczego Unii Europejskiej ze szczególnym uwzględnieniem roli wspólnej waluty funkcjonującej na poziomie strefy euro. Celem przedmiotu jest również zdobycie wiedzy i zrozumienie mechanizmów rządzących kształtowaniem głównych polityk makroekonomicznych: budżetowej i monetarnej. Studenci poznają również zasady funkcjonowania banków centralnych odpowiedzialnych za prowadzenie polityki pieniężnej, a także zrozumieją korelację pomiędzy polityką podatkową, polityką pieniężną i walutową. Dzięki temu będą potrafili przewidzieć skutki prowadzonej przez rząd i Unię Europejską polityki gospodarczej, co pomoże im zmniejszyć ryzyko podejmowania błędnych decyzji finansowych, szczególnie w zakresie prowadzenia własnej firmy."
Clone: EU economic policy,3,,,False,False,"**Przedmiot będzie prowadzony przez dra hab. Radosława Kupczyka z Katedry Studiów Europejskich WNS UWr.**

Celem zajęć jest zapoznanie studentów z problematyką prowadzenia polityki gospodarczej,  która pozwala zrozumieć decyzje podejmowane przez instytucje krajowe (rząd, bank centralny) w celu zarządzania gospodarką. Przedmiot tłumaczy również funkcjonowanie systemu gospodarczego Unii Europejskiej ze szczególnym uwzględnieniem roli wspólnej waluty funkcjonującej na poziomie strefy euro. Celem przedmiotu jest również zdobycie wiedzy i zrozumienie mechanizmów rządzących kształtowaniem głównych polityk makroekonomicznych: budżetowej i monetarnej. Studenci poznają również zasady funkcjonowania banków centralnych odpowiedzialnych za prowadzenie polityki pieniężnej, a także zrozumieją korelację pomiędzy polityką podatkową, polityką pieniężną i walutową. Dzięki temu będą potrafili przewidzieć skutki prowadzonej przez rząd i Unię Europejską polityki gospodarczej, co pomoże im zmniejszyć ryzyko podejmowania błędnych decyzji finansowych, szczególnie w zakresie prowadzenia własnej firmy."
Design and implementation of systems in the cloud,6,"- wykład, wykład interaktywny
- indywidualne rozwiązywanie zadań
- grupowe omawianie rozwiązań
- samodzielna praca przy komputerze
- grupowe warsztaty programistyczne
- grupowe dzielenie się problemami i rozwiązaniami",,False,False,"Minęły już czasy, kiedy do uruchomienia aplikacji sieciowych wynajmowało się
prosty serwer dedykowany. Dzięki szerokiej ofercie usług chmurowych każdy może
przygotować wysoce niezawodną, globalną infrastrukturę gotową przyjąć ogromny
ruch na setkach serwerów. Rola administratora serwerów traci na ważności, a
coraz bardziej potrzebni są programiści specjalizujący się w chmurach.  
  

Zajęcia objaśnią podstawy projektowania, wdrażania i utrzymywania aplikacji w
środowisku chmurowym - zarówno małych, jak i większych systemów. Duży nacisk
będzie położony na wysoką dostępność i skalowalność. Przedstawimy nowe
możliwości oraz usługi dostępne u wiodących dostawców usług chmurowych.
Przyjrzymy się także jak zaplanować architekturę aplikacji, by jak najbardziej
wykorzystać możliwości takiego środowiska. Dokonamy przeglądu narzędzi, które
wspomagają konfigurację chmury. Pokażemy też jak projektować aplikacje dla
milionów użytkowników oraz jak wykonywać obliczenia rozłożone po tysiącach
serwerów.

Przydatna będzie wiedza z przedmiotu _Sieci Komputerowe_ oraz podstawy _Baz
Danych_. Na zajęciach będziemy zakładali, że administracja Linuksem,
połączenie się ze zdalnym serwerem, przygotowanie banalnej aplikacji HTTP, nie
jest dla nikogo wyzwaniem. Ćwiczenia będą kombinacją zadań teoretycznych do
omówienia oraz pracowni wykorzystujących przedstawione narzędzia aby
skonfigurować proste aplikacje w chmurze.

  
Planujemy omówić technologie, produkty i zagadnienia: AWS, GCP, Docker,
Kubernetes, _configuration management_ (Ansible, Chef, Puppet), CDN,
_infrastructure as code_ (Terraform, CloudFormation), _reliability
engineering_, monitorowanie infrastruktury, _incident management_, bazy i
hurtownie danych, duże obliczenia, automatyzacja infrastruktury, skalowanie
baz danych.  
  
Prowadzący przedmiot reprezentują firmę Fibertide, gdzie projektują i wdrażają zaawansowane systemy chmurowe docierające do ogromnej liczby użytkowników."
Parallel Computing with CUDA (Q2),3,"wykład,
prezentacja,
dyskusja,
konsultowanie pomysłów rozwiązań zadań programistycznych,
samodzielna praca przy komputerze,
indywidualny projekt programistyczny",,False,False,"Półsemestralny kurs (15h wyklad + 15h pracowni) obejmuje naukę podstaw programowania równoległego kart graficznych w oparciu o bibliotekę CUDA firmy NVIDIA. Zajęcia będą w nietypowym półsemestralnym wymiarze i rozpoczną się w połowie semestru w listopadzie, o szczegółach zapisani zostaną powiadomieni mailowo na początku semestru.

Współczesne karty graficzne zawierają coraz większą moc obliczeniową w postaci wielu równoległych jednostek obliczeniowych i są wykorzystywane nie tylko do generowania grafiki. Biblioteka CUDA umożliwia programowanie kart graficznych przy pomocy rozszerzeń języka C. W ten sposób możemy wykonywać obliczenia często szybciej niż na CPU. Wymaga to jednak niskopoziomowego programowania w oparciu o bardziej skomplikowany model pamięci.

Głównym celem kursu jest nabycie umiejętności programowania równoległego w technologii CUDA zagadnień nie tylko związanych z grafiką komputerową. W tym celu konieczne jest poznanie architektury współczesnych kart graficznych i ograniczeń które wpływają na wybór algorytmu i sposób implementacji na karcie graficznej."
Term Logic,3,Wykład,,False,False,"** Przedmiot jest prowadzony przez dr.  Elżbietę Magner z Katedry Logiki i Metodologii Nauk UWr. **

#### Program:  

* co to jest nazwa, wybrane podziały nazw, stosunki zakresowe między nazwami; 

* język a metajęzyk; 

* nazwy a definicje; 

zdania kategoryczne; 

* kwadrat logiczny, negowanie zdań, konwersja, obwersja i kontrapozycja; 

* sylogizm, badanie poprawności sylogizmu; 

* błąd 4 terminów, ekwiwokacja, nazwozdania."
Project: Demoscene production,4,,,False,False,"Demoscena to międzynarodowa subkultura komputerowa – powstała w latach 80 ubiegłego wieku – zajmująca się tworzeniem dem, czyli programów komputerowych generujących w czasie rzeczywistym prezentacje audiowizualne. Celem dema jest zaprezentowanie umiejętności programistycznych, graficznych i muzycznych członków grupy demoscenowej. Produkcje demoscenowe wystawia się w konkursach na festiwalach zwanych _demoparty_, na których uczestnicy głosują na najlepsze produkcje w kilku kategoriach. Jeśli chcesz się dowiedzieć na ten temat więcej, to koniecznie obejrzyj polski film dokumentalny [_Sztuka przekraczania_](https://www.youtube.com/watch?v=NVEBWUM8lko).

Celem projektu jest przygotowanie dema na komputer [Amiga 500](https://pl.wikipedia.org/wiki/Amiga_500) pod szyldem grupy [Ghostown](http://www.pouet.net/groups.php?which=10931), która wielokrotnie zajmowała pierwsze miejsce na podium, np.: [Sushi Boyz](https://www.youtube.com/watch?v=ZQ3-nnoXGng) czy [Human Traffic](https://www.youtube.com/watch?v=mZTWdzJMiJA). Produkcję chcielibyśmy wystawić na [Revision](https://en.wikipedia.org/wiki/Revision_(demoparty)) – najbardziej prestiżowym i największym demoparty na świecie – odbywającym się co roku na przełomie marca i kwietnia. Grupa w swoich szeregach ma wysokiej klasy grafików [Slayer](http://artcity.bitfellas.org/index.php?a=artist&id=467)'a i [DKL](http://artcity.bitfellas.org/index.php?a=artist&id=894)'a oraz świetnego muzyka [Jazzcat](https://soundcloud.com/jazzcat-2/popular-tracks)'a. Lubimy eksperymenty i nowe wyzwania, dlatego chcielibyśmy zaprosić do współpracy programistów niezwiązanych z demosceną i zobaczyć dokąd nas to zaprowadzi. A nuż będzie to strzał w dziesiątkę?

W projekcie wykorzystujemy szereg nowoczesnych technologii do tworzenia narzędzi, grafiki 2D, modeli 3D, muzyki i efektów audiowizualnych:

 - język [Python](https://www.python.org/), [GoLang](https://golang.org/) i [TypeScript](https://www.typescriptlang.org/)
 - shadery GLSL [ShaderToy](https://www.shadertoy.com/)
 - środowisko [Processing](https://processing.org/)
 - [Photoshop](https://www.adobe.com/pl/products/photoshop.html)
 - [Modo3D](https://www.foundry.com/products/modo) i [Blender](https://www.blender.org/)
 - instrumenty i efekty [VST](https://en.wikipedia.org/wiki/Virtual_Studio_Technology)

Zadania programistyczne pokrywają szerokie spektrum tematów o zróżnicowanym poziomie trudności:

 - konwersja danych
 - przetwarzanie i synteza dźwięku
 - przetwarzanie obrazu
 - kompresja danych
 - narzędzia wspomagające debugowanie i profilowanie
 - narzędzia do parametryzowania i sekwencjonowania efektów
 - prototypowanie efektów graficznych
 - adaptacja efektów do ograniczeń komputera _Amiga 500_
 - rozwój infrastruktury do uruchamiania efektów
 
Idealnie każdy uczestnik projektu powinien utworzyć prototyp efektu i z pomocą prowadzącego zajęcia zaadaptować go do ograniczeń platformy docelowej. Efekt graficzny może być początkowo wysoko ponad możliwości sprzętu. Dzięki sprytnym obserwacjom część pracochłonnych obliczeń można wykonać jeszcze na komputerze PC. Adaptacja efektu polega na zidentyfikowaniu specjalnego przypadku (np. pozycji kamery w scenie trójwymiarowej), dla którego obliczenia i technika wyświetlania upraszczają się do tego stopnia, że docelowy sprzęt jest w stanie sobie z tym poradzić.

Środowisko programisty bazuje na [Visual Studio Code](https://code.visualstudio.com/) i emulatorze [fs-uae](https://fs-uae.net/), ale ze względu na szereg ograniczeń jest dedykowane dla użytkowników systemu _Linux_ lub _macOS_. Więcej na temat kodu i środowiska można dowiedzieć się przeglądając publicznie dostępne repozytorium [cahirwpz/demoscene](https://github.com/cahirwpz/demoscene).

Jeśli uda się Wam wprowadzić swój efekt do produkcji, to zostaniecie uwiecznieni (pod wybranym pseudonimem) w sekcji _credits_ i członkowie grupy Ghostown będą Was zachęcać do uczestnictwa w _demoparty_. Wrażeń z obejrzenia efektów swojej pracy na ekranie kinowym i aplauzu publiczności nie da się zapomnieć!"
Intelligence services in state security system and international relations,3,Wykład,,False,False,"** Przedmiot jest prowadzony przez dr. Jarosława Stróżyka z  Instytutu Studiów Międzynarodowych. **

Kurs dotyczy zagadnień związanych z funkcjonowaniem służb specjalnych w systemie bezpieczeństwa państwa oraz stosunkach międzynarodowych. Wywiad i kontrwywiad. Definicje i terminologia. Pojęcie procesu informacyjnego w wywiadzie, metody i techniki pozyskiwania informacji. Analiza wywiadowcza. Wywiad i rozpoznanie wojskowe.  
Celem przedmiotu jest nabycie przez studentów wiedzy na temat roli odgrywanej przez służby specjalne (wywiadowcze i kontrwywiadowcze) w systemie bezpieczeństwa państwa, zarówno w aspekcie bezpieczeństwa wewnętrznego jak i zewnętrznego, a także poznanie zadań i uprawnień polskich wojskowych oraz cywilnych służb specjalnych. Istotnym elementem będzie także opis wybranych elementów współpracy międzynarodowej służb specjalnych., w tym na forum NATO oraz UE."
Decision Problems in Logic,6,"* wykład
* indywidualne/grupowe rozwiązywanie zadań
* rozwiązywanie zadań z komentowaniem
* dyskusja",,False,False,"Prace Churcha, Turing i Goedla z początków XX w. pokazały, że problem spełnialności (czy dana formuła ma model?) dla logiki pierwszego rzędu jest nierozstrzygalny. Wyniki te zapoczątkowały duży program badawczy, którego celem było ustalenie, które naturalne fragmenty logiki pierwszego rzędu są rozstrzygalne. Nieco później dodatkowym bodźcem dla tego programu stały się potencjalne zastosowania w informatyce (bazy danych, reprezentacja wiedzy,
automatyczna weryfikacja programów i sprzętu, sztuczna inteligencja, itd.). Oczywiście, zwiększyły one też zainteresowanie badaczy dokładną złożonością obliczeniową problemu spełnialności w przypadku fragmentów rozstrzygalnych.

Na wykładzie przedstawię szereg wyników dotyczących rozstrzygalności/nierozstrzygalności i złożoności obliczeniowej logik motywowanych teorią informatyki.

W programie m.in.: logiki modalne,  temporalne i deskrypcyjne, logiki z dwiema zmiennymi, fragmenty strzeżone, logika z unarną negacją. Wykład będzie oparty głównie na pracach opublikowanych w
ciągu ostatnich dwudziestu kilku lat, choć opowiem oczywiście również o paru klasycznych wynikach, sięgając m.in. do prac Kurta Gödla.

**Wymagania:** Logika dla informatyków, Zalecane: Języki formalne i złożoność obliczeniowa


**W razie konieczności prowadzenia zajęć zdalnie**: wykłady 
i ćwiczenia będą odbywały się online przy użyciu wybranej
platformy (np. MS Teams)."
Software engineering,6,"* projekt programistyczny
* ćwiczenia audytoryjne
* wykład monograficzny",,False,False,"Przedmiot zapoznaje z podstawowymi: wiedzą i umiejętnościami dotyczącymi
wytwarzania oprogramowania. Obejmuje zwinny i i wodospadowego model
wytwarzania oprogramowania oraz związane z nimi procesy . Zmusza do wymaganej
przez pracodawców pracy zespołowej na wszystkich podstawowych etapach
produkcji oprogramowania.

Wykonywane praktyczne zadania uczą podejmować i uzasadniać decyzje projektowe
oraz prezentować opracowane rozwiązania.

Przedmiot pozwala zrozumieć pracę inżyniera oprogramowania oraz praktycznie
przygotowuje do pracy na tym stanowisku."
Probability Theory for Computer Scientists,6,"* Wykład
* Rozwiązywanie zadań z komentowaniem
* Indywidualne rozwiązywanie zadań",,False,False,"Serdecznie zapraszam na wykład z rachunku prawdopodobieństwa. Na wykładzie
zapoznamy się z podstawowymi pojęciami i technikami probabilistycznymi. Wiele
z nich posiada zastosowania w analizie i konstruowaniu wspołczesnych
algorytmow, co będzie ilustrowane licznymi przykładami zastosowania rachunku
prawdopodobieństwa do zagadnień typowo informatycznych. Wykład dedykowany jest
studentom informatyki, ktorzy chcieliby poznać arkana rachunku
prawdopodobieństwa, by stosować je w analizie i konstruowaniu algorytmow
grafowych, programowaniu liniowym, geometrii obliczeniowej, algorytmow teorio-
liczbowych.  

Program:

\- Pierwsza część wykładu poświęcona będzie klasycznemu pojęciu
prawdopodobieństwa oraz pojęciu i własnościom zmiennych losowych.

\- W drugiej części wykładu zajmiemy się nieco bardziej zaawansowanymi
zagadnieniami, jak twierdzenia graniczne, procesy Markowa.

\- Wprowadzone pojęcia ilustrowane będą przykładami zastosowania w
informatyce, na przykład w konstruowaniu efektywnych algorytmow sortowania,
problemow kolekcjonera, lematu Lovasza.

Wymagania: analiza matematyczna."
Course: modeling 3D and visualization in SketchUp,5,"Wykład, pracownia komputerowa",,False,False,"Kurs modelowania 3D w programie SketchUp i wizualizacji za pomocą pluginu brighter3d, z elementami pisania wtyczek w języku Ruby.

Wykład:

* modelowanie scen 3D
* modelowanie organiczne
* wizualizacja i animacja scen 3D
* podstawy języka Ruby
* pisanie własnych pluginów
* photo matching

Zaliczenie na podstawie punktów z pracowni (około 12).

[Prace z poprzedniego roku](https://youtu.be/UCztwkMlEYA)"
Introduction to computer science,6,"wykład, wykład interaktywny, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów, analiza algorytmu (poprawność, złożoność)",,False,True,"Celem przedmiotu jest przedstawienie struktury logicznej i zasad działania komputera, cyfrowej reprezentacji informacji oraz sposobu wykonywania programów przez komputer. Istotnym celem jest też umożliwienie studentom nabycia podstawowych umiejętności z zakresu konstruowania i analizy algorytmów, w tym weryfikacji poprawności i szacowania złożoności obliczeniowej. W ramach przedmiotu umożliwia się poznanie podstawowych struktur danych i ich implementacji, a także nabycie umiejętności stosowania takich struktur danych do rozwiązywanych problemów.

##### Program:

* Pojęcia: problem, specyfikacja, algorytm, program komputerowy. Budowa komputera – schemat logiczny.
* Elementy programowania w języku niskopoziomowym na przykładzie maszyny RAM
* Reprezentacja danych w pamięci komputera: binarna stałopozycyjna i zmiennopozycyjna reprezentacja liczb, arytmetyka binarna; reprezentacja tekstu, obrazu, dźwięku.
* Programowanie w wysokopoziomowym języku strukturalnym, zstępująca metoda programowania.
* Kompilacja, translacja, interpretacja programów. Zarządzanie pamięcią podczas uruchamiania programu.
* Podstawowe konstrukcje programistyczne: iteracja, zagnieżdżanie, licznik, sumator, rekurencja.
* Elementy analizy algorytmów: poprawność, własność stopu, złożoność czasowa i pamięciowa, miary złożoności; notacja asymptotyczna.
* Podstawowe struktury danych i ich zastosowania: tablica, lista wiązana, stos, kolejka; drzewo przeszukiwań binarnych. Abstrakcyjne typy danych.
* Sortowanie przy pomocy porównań.
* Podstawowe techniki algorytmiczne: metoda nawrotów, metoda dziel i zwyciężaj, programowanie dynamiczne, algorytmy zachłanne.
* Komputerowa reprezentacja grafów.
* Algorytmy grafowe: przeszukiwanie w głąb, wszerz; składowe spójności.
* Gramatyki bezkontekstowe jako narzędzie do opisu składni języków programowania. Notacja BNF i EBNF.
* Pojęcie rozstrzygalności problemów, przykłady problemów nierozstrzygalnych.

###### Wymagania wstępne:
elementarna znajomość języka C lub Python (począwszy od wykładu 5)


###### Przewidywana formie zajęć w przypadku konieczności prowadzenia zajęć zdalnie:

Wykłady będą prowadzone w formie wideokonferencji

Ćwiczenia:
- zajęcia w formie wideokonferencji,
- utrzymany zostanie system deklaracji zadań,
- wskazane jest rekomendowanie studentom zakupu prostych tabletów graficznych w celu wygodnego dostępu do wirtualnej tablicy (np. MS Whiteboard) w trakcie cwiczen,
- wskazane jest przydzielenie nauczycielom prowadzącym ćwiczenia 3h zajęć: 2h na standardowe ćwiczenia, 1h na dedykowane konsultacje, w trakcie których prowadzący sprawdzają i omawiają indywidualnie ze studentami ich rozwiązania wybranych zadań."
C minicourse,2,samodzielna praca przy komputerze - indywidualne programowanie,,False,True,"**Wstęp, czyli jak się ma ""Wstęp do programowania w języku C"" do ""Wstępu do
programowania w języku Python""**

Studenci 1-go roku studiów 1-go stopnia mogą rozpocząć naukę programowania i
podstaw informatyki w jednym z dwóch języków: **C albo Python** (można wybrać
tylko jeden z tych dwóch kursów!). Każdy z tych kursów pozwala opanować
podstawy informatyki i programowania a w dalszych semestrach doskonalić się w
programowaniu w innych (lub tych samych) językach. W szczególności zaczynając
od ""Kursu: Wstęp do programowania w języku C"", nie skazujecie się na zawsze na
ten język (i nieznajomość Pythona) oraz _vice versa_. W drugim semestrze
studiów (i kolejnych) pojawiają się kursy języków programowania (C++, Java,
Ruby, Python), które pozwalają opanować różne języki, przy założeniu, że
studenci mają ogólne pojęcie o programowaniu, które zdobywają na obu
przedmiotach ""Kurs: Wstęp do programowania w języku C/Python"".

**O samym kursie ""Minikurs języka C""**  

Celem tego kursu jest nauczenie i rozwinięcie podstawowych umiejętności programowania w jednym z najbardziej rozpowszechnionych języków imperatywnych - języku C. Kurs jest krótki ale intensywny i przeznaczony dla studentów I roku, którzy uczyli się Pythona w semestrze zimowym.

**Wymagane przygotowanie:** Wstęp do programowania w języku Python.

**Program:**

  * Podstawowe konstrukcje języka C: instrukcje i deklaracje.
  * Standardowe typy danych i wyrażenia.
  * Standardowe wejście/wyjście, filtry.
  * Funkcje, moduły i struktura programu.
  * Metody agregacji danych: tablice, struktury i unie.
  * Wskaźniki.

**Literatura:**

* Kernighan B.W., Ritchie D.M.: Język ANSI C. Seria ""Klasyka Informatyki"". Warszawa, Wydawnictwa Naukowo-Techniczne 2003. Podręcznik podstawowy.
* King K.N.: Język C, Nowoczesne programowanie, Wydanie II, Helion 2011 (uwzględnia standard C99).
* Banahan M., Brady D., Doran M., The C Book, http://publications.gbdirect.co.uk/c_book/ (dostępny za darmo jako pdf i na WWW).
* Schildt B., C: The Complete Reference: covers C++ and ANSI C, Osborne McGraw-Hill, 
* ISO/IEC 2011 - Programming languages - C (aktualny standard ISO 2011), http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1570.pdf (wstępna wersja opisu standardu)."
Logic for Computer Science (advanced),8,"Wykład, ćwiczenia tablicowe.",,False,True,"Przedmiot jest adresowany do słuchaczy, co do których nie ma wątpliwości, że dobrze rozumieją co to jest rozumowanie matematyczne, i którzy zetknęli się wcześniej z wieloma pojęciami objętymi programem przedmiotu ,,Logika dla
informatyków"". Dlatego program nie tylko obejmuje wszystkie elementy programu przedmiotu ,,Logika dla informatyków"", ale znacznie poza niego wychodzi ku kwestiom bardziej zaawansowanym."
Computational Complexity in Practice,6,"Wykład, rozwiązywanie zadań w grupie, zadania domowe",,False,False,"Celem przedmiotu jest zaznajomienie słuchaczy z podstawowymi zagadnieniami teorii obliczeń oraz omówienie praktycznych zastosowań tej teorii, ze szczególnym uwzględnieniem implementowania algorytmów korzystających z narzędzi takich, jak SAT solvery, SMT solvery czy QBF solvery.

Program przedmiotu obejmuje: modele obliczeń (automaty i maszyny), praktyczne klasy złożoności obliczeniowej (LogSpace, P, NP, PSpace), dyskusję o problemach nienależących do tych klas oraz omówienie narzędzi i technik wykorzystywanych do radzenia sobie z problemami o dużej złożoności.

Przedmiot ten nie będzie trudny: powinien być przystępny dla studentów trzeciego semestru. Zajęcia pomocnicze będą składały się z list zadań rozwiązywanych w trakcie zajęć oraz z zadań domowych (implementacyjnych oraz teoretycznych)."
Photorealistic Computer Graphics,6,"* lecture
* programming lab  
* programming project
* tutorial
* individual computer work",,False,False,"The goal of the subject is to get inside knowledge of the range of problems connected with generating photorealistic images by simulation of light transport. Some people say that everyone should implement a ray tracer and although a simple one can be done in one afternoon we will devote the whole subject to do it nicely and to have more satisfaction and deeper understanding.  

The lecture will present theoretical background and during the lab we will implement the ray tracer starting from simple one, than adding accelerations structures and up to the physically correct one with Monte Carlo methods to solve light transport equations. 

**Program:**

  * Ray tracing methods from visibility to simple light transport simulation
  * Acceleration structures to make it fast
  * Physical foundations of light transport 
  * Monte Carlo methods
  * Ray tracing Monte Carlo methods: path tracing, photon maps, bidirectional path tracing, Metropolis, ... 
  * Radiosity method
  * High Dynamic Range Imaging and Tone Mapping 

**Requirements:** 
  * Computer Graphics / Podstawy grafiki komputerowej
  * Probability / Rachunek prawdopodobieństwa
  * Calculus / Analiza matematyczna"
Artificial Intelligence for Games,6,"- lecture
- programming assignments with comments
- programming project",,False,False,"This lecture aims to present game-related Artificial Intelligence from three perspectives: solving games, procedural content generation, and in-game AIs. I would like to show how many diverse roles AI can play when applied to the games domain, both from research and industry perspective. 

Also, this will be a perfect opportunity to clash theory with practice and see how many unpredicted situations happen when you program an entity to behave ""intelligently"". The lab exercises will mainly require implementing various agents aimed to solve small-to-medium-sized problems. Finally, group projects will be an opportunity to develop something bigger.

The course will be split between presenting recent developments in AI research branch, and methods that are more commonly used in video games, including more advanced versions of standard AI techniques like A* or minmax. 
We will cover recent advancements in Computation Intelligence methods, their successful applications, and their limitations. This part of the program is based on a selection of publications from the leading AI conferences (AAAI, IJCAI, GECCO) and smaller venues closely related to this topic (MCS IJCAI Workshop, COG).
On the other hand, we will talk about some basic techniques omitted during the AI course, which, due to their simplicity and reliability, are the core of nearly every video game AI.

#### Example project topics:
- implementing AI agent for one of the competitions hosted by AI conferences, e.g. [COG](http://ieee-cog.org/2020/competitions_conference), [CEC](https://wcci2020.org/competitions/)
- developing PCG system that will produce interesting (presumably game-related) objects, e.g., maps, levels, items, sprites etc.
- performing an extensive study of a chosen AI method on a number of different testbeds, e.g., using problems available at [CodinGame](https://www.codingame.com/) platform
- trying to reproduce results of chosen game AI-related publication
- or other proposed by the students

Projects are expected to be done in 2-3 person groups by default. High-quality projects can be a basis for a bachelor/engineer or master thesis.

In case of remote teaching, lectures will be carried out using platforms such as Discord/Google Hangouts in an interactive form( and probably also recorded). Presenting tasks during the laboratory will require student to ""personally"" show his working solution via the screen share mechanism. The form of the final exam depends on many factors and will be determined later. General rules of the course remain unchanged."
Algorithms for Big Data,6,"lectures, supervised problem solving, individual/collective problem solving",,False,False,"The course presents the mathematical and algorithmical ways of dealing with very large data sets. The need to process such large datasets is ubiquitous now, and arises in Internet search, machine learning, network traffic monitoring, scientific computing, signal processing, and other areas.
In such datasets, even linear complexity is simply not feasible. This invalidates many classical approaches to algorithm and data structure design, and creates the need to represent the data in a fashion that preserves some selected structural properties, but otherwise is highly compressed, and the need for new algorithmmic approaches.

__Example 1:__
High-dimensional bit-vectors (think of: for each user of a social network, we store which items they liked/disliked). Surprisingly, instead of storing each bit-vector explicitly (which would take gigabytes _per user_), we can design relevant sketches. Each sketch takes logarithmic space, and we can query bit-vectors for similarity in logarithmic time!

__Example 2:__
Approximate matrix multiplication: we can multiply matrices much faster, if we are fine with output being a close approximation (in some sense) of the actual product.


__Note:__
This will be a rather *math heavy* course. However, the mathematical tools used will be rather basic (basic probability and linear algebra).

This course should be interesting enough for PhD students.

Materials from 2019 are available here (keep in mind those will be heavily changed): https://github.com/izulin/uwrbigdata"
Seminar: Numerical and Computer Graphics Algorithms,3,"* projekt programistyczny
* projekt badawczy",,False,False,"Seminarium jest rozszerzeniem wykładu z analizy numerycznej. Jego celem jest zapoznanie uczestników z nowymi oraz z klasycznymi, ale nieomawianymi na wykładzie z analizy numerycznej, metodami i algorytmami numerycznymi rozwiązywania różnego rodzaju zadań matematyki obliczeniowej i grafiki komputerowej. Do zaliczenia zajęć konieczne będzie wygłoszenie referatu na temat ustalonej z prowadzącym seminarium metody numerycznej, w tym również jej zaimplementowanie oraz przetestowanie. Pomysłów na referaty można szukać m.in. przeglądając w miarę *świeże* podręczniki czy artykuły opublikowane w czasopismach związanych z tematyką seminarium, np.:

* [Numerical Algorithms](https://www.springer.com/journal/11075),
* [Numerische Mathematik](https://www.springer.com/journal/211),
* [BIT Numerical Mathematics](https://www.springer.com/journal/10543),
* [Applied Numerical Mathematics](https://www.journals.elsevier.com/applied-numerical-mathematics),
* [Applied Mathematics and Computation](https://www.journals.elsevier.com/applied-mathematics-and-computation),
* [SIAM Journal on Numerical Analysis](https://www.siam.org/publications/journals/siam-journal-on-numerical-analysis-sinum),
* [Journal of Computational and Applied Mathematics](https://www.journals.elsevier.com/journal-of-computational-and-applied-mathematics),
* [Journal of Approximation Theory](https://www.journals.elsevier.com/journal-of-approximation-theory),
* [International Journal for Numerical Methods in Engineering](https://onlinelibrary.wiley.com/journal/10970207),
* [Computer-Aided Design](https://www.journals.elsevier.com/computer-aided-design),
* [Computer Aided Geometric Design](https://www.journals.elsevier.com/computer-aided-geometric-design),
* [Pattern Recognition](https://www.journals.elsevier.com/pattern-recognition),
* [ACM Transactions on Graphics](https://dl.acm.org/journal/tog),
* [Foundations and Trends in Computer Graphics and Vision](https://www.nowpublishers.com/CGV),
* [IEEE Transactions On Visualization And Computer Graphics](https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=2945).

**Wymagania**

  * analiza numeryczna (L lub M),
  * umiejętność programowania.

**Ważna uwaga**

Zapisując się na seminarium powinno mieć się wstępny pomysł na wystąpienie -- takie referaty będą najwyżej oceniane. W ostateczności temat zasugeruje prowadzący zajęcia."
Distributed Algorithms,6,wykład – wykład interaktywny - ćwiczenia audytoryjne,,False,False,"Wykład ma na celu zaznajomienie studentów z podstawowymi algorytmami i
protokołami występującymi w obliczeniach rozproszonych. Rozważane są modele
synchroniczne i asynchroniczne bez wspólnej pamięci. Główny model komunikacji,
to wymiana komunikatów.

**Program:**

  1. Synchroniczne i asynchroniczne modele obliczeń rozproszonych.
  2. Rozproszone algorytmy wykrywania zakleszczenia, wyboru lidera i uzgadniania wspólnej decyzji.
  3. Podstawowe algorytmy grafowe w protokołach rozproszonych: algorytmy wyznaczania drzewa rozpinającego i przeszukiwania grafu.
  4. Odporność protokołów rozproszonych na uszkodzenia elementów sieci.
  5. Przydział zasobów w sieciach."
Olympic algorithms,5,"* wykład
* prezentacja
* dyskusja
* indywidualne rozwiązywanie zadań
* indywidualny projekt programistyczny",,False,False,"Niektórzy studenci mają doświadczenie w startach w zawodach Olimpiady Informatycznej lub nawet zawodach ACM ICPC. Niewielu jednak wie, jak wygląda proces przygotowania takiego konkursu przez organizatorów. Czasami, a może
nawet często, przygotowanie zadania jest trudniejsze od jego rozwiązania. Celem tego kursu jest pokazanie świata zawodów algorytmicznych od strony ""kuchni"", co być może będzie też pomocne w przygotowaniach do startów. Zainteresowane osoby uzyskają też informacje o tym jak wziąć udział w pracach nad konkursami organizowanymi na naszej uczelni i poza nią.

Drugą częścią przedmiotu jest przygotowanie studentów do dydaktyki informatyki, szczególnie w szkołach podstawowych i liceach. Studenci poznają metody nauczania uczniów, a na ćwiczeniach będą prezentowali również własne pomysły i adaptacje metod z wykładu. Zainteresowane osoby uzyskają też informacje o tym jak włączyć się w działania edukacyjne w szkołach koordynowane przez naszą uczelnię.
  
Program wykładu 
===============  
Pierwsza część kursu obejmować będzie przegląd zagadnień związanych z
przygotowaniem zadania konkursowego: właściwe przygotowanie treści, dobór
limitów na rozmiar danych wejściowych, dobór ograniczeń czasu i pamięci,
przygotowanie danych testowych, przygotowanie programów pomocniczych, dobór
punktacji za rozwiązania częściowe, wymyślanie własnych zadań, omówienie potencjalnych błędów podczas przygotowania zadania.  

Drugą część stanowią podstawowe elementy dydaktyki
algorytmiki konkursowej: jak umiejętnie dzielić się swoją wiedzą z innymi studentami i młodszymi uczniami oraz jak przygotować dobrej jakości materiały
edukacyjne z tej dziedziny.
  
Ostatnie dwa wykłady stanowić będą przegląd wybranych bardziej zaawansowanych zagadnień dotyczących treści zaprezentowanych wcześniej, na zasadzie mini-referatów przygotowanych przez studentów.

Przykłady tematów:  
* ocena jakości losowych testów w zadaniach grafowych (np. dla problemu spójności grafu czy najkrótszych ścieżek),  
* testowanie rozwiązań zrandomizowanych,  
* przygotowanie złośliwych danych dla obliczeń zmiennoprzecinkowych w zadaniach geometrycznych,  
* zastosowania machine learning do przygotowania danych testowych w zadaniach (na przykład: złośliwe czasowo testy w zadaniach przepływowych),  
* automatyczne wykrywanie niesamodzielnych rozwiązań,  
* bezpieczeństwo automatycznego procesu oceny.  

Lista tematów do wyboru jest o wiele szersza. Możliwe jest proponowanie własnych tematów.  
  

  
  
Program ćwiczeń/pracowni  
========================  
Na ćwiczeniach/pracowni w pierwszej części semestru skupimy się na dokładnej
analizie kolejnych etapów przygotowania zadania zgodnie z programem wykładu.
Zadania na listach będą bardzo zróżnicowane: niektóre będą wymagały napisania
dokumentu w LaTeX czy Markdown, inne programu w C++, jeszcze inne skryptu w
Bashu czy Pythonie. Niektóre zadania będą w formie krótkich (kilkanaście
minut) mini-referatów do zaprezentowania przed grupą. Nacisk zostanie położony
na jakość prezentacji i umiejętność przekazania wiadomości grupie. Niektóre
zadania mogą wymagać nauczenia się prostych narzędzi (np. do tworzenia
obrazków czy szyfrowania dokumentów). Ostatnią częścią pracowni będzie
projekt, którym będzie wymyślenie i przygotowanie własnego zadania
olimpijskiego lub przygotowanie własnego materiału edukacyjnego z zakresu
algorytmiki konkursowej.  
  
Efektem ubocznym kursu ma być zbiór zadań, który wykorzystamy do wewnętrznego
konkursu dla zainteresowanych oraz wśród uczniów, dla których prowadzimy
zajęcia w liceach i gimnazjach.  
  
  
Wymagania  
=========  
Ukończenie kursu Algorytmów i Struktur Danych powinno być wystarczające, choć nie jest wymaganiem koniecznym."
Workshops: Linux device drivers programming,4,"Wykład, samodzielne rozwiązywanie zadań programistycznych, czytanie i analiza kodu jądra systemu Linux.",,False,False,"Zajęcia będą prowadzone przez pracownika firmy [AntMicro](https://antmicro.com/) w cyklu dwutygodniowym.

Na warsztatach będziemy rozwijać sterownik do sensora podłączonego przez magistralę I²C (IMU lub temperatury i wilgotności). Każde spotkanie zaczniemy od wprowadzenia do tematu, a dalej przełączymy się na pisanie kodu. Po każdych zajęciach sterownik będzie implementował coraz więcej funkcjonalności. System Linux będziemy uruchamiać pod kontrolą Renode symulującego płytkę rozwojową na procesorze ARM. Ambitni studenci w ramach projektu końcowego mogą spróbować podpiąć jakiś sensor do prawdziwego sprzętu, np. Raspberry Pi."
FPGA programming,6,"wykład, samodzielna praca przy komputerze, indywidualny/zespołowy projekt programistyczny",,False,False,"Wykład jest wprowadzeniem do projektowania układów cyfrowych przy użyciu
języka opisu sprzętu (System)Verilog oraz ich implementacji na układach FPGA. W ramach
zajęć student nauczy się również metod testowania sprzętu oraz zapozna się z
podstawami formalnej weryfikacji układów cyfrowych.

**Wymagania:**

Wysoce wskazana jest znajomość zasad projektowania układów cyfrowych (np. przez zaliczenie przedmiotu ""Logika cyfrowa""), mile
widziana jest znajomość języka C i idąca za tym umiejętność programowania
niskopoziomowego.

**Program:**

1. Verilog jako język modelowania sprzętu
2. Symulacja sprzętu przy użyciu programów Icarus Verilog, Verilator i ModelSim
3. Testowanie modeli sprzętu przy użyciu języka Verilog
4. Synteza sprzętu
5. Budowa układów FPGA
6. Synteza sprzętu przy użyciu programu Yosys
7. Synteza sprzętu na FPGA Intela przy użyciu programu Quartus
8. Elementy wbudowane na FPGA: multiplikatory, pamięci, PLL
9. Wykorzystywanie tzw. rdzeni IP (modułów sprzętowych)
10. Łączenie modułów sprzętowych przy użyciu Intel Platform Designer (Qsys), magistrala Avalon
11. Magistrala AMBA AXI
12. Język TCL
13. Łączenie FPGA z sprzętowym procesorem
14. Języki opisu sprzętu wysokiego poziomu: Chisel i Clash
15. Formalna weryfikacja sprzętu przy użyciu programów Yosys i SymbiYosys

**Zalecana literatura:**

Douglas J.Smith, HDL Chip Design: A Practical Guide for Designing,
Synthesizing & Simulating ASICs & FPGAs Using VHDL or Verilog  
Samir Palnitkar, Verilog HDL (2nd Edition)  
J. Bhasker, A Verilog HDL Primer, Third Edition  
Donald Thomas, Logic Design and Verification Using SystemVerilog (Revised)"
Principles of Program Analysis,6,"lecture, individual programming tasks, blackboard problem solving",,False,False,"Program analysis offers static compile-time techniques for reasoning about behaviors of computer programs. The main application domain is in optimizing compilers, but the techniques are also useful in automatic error detection, verification of properties of software used in safety-critical computer systems, locating vulnerable code etc.

This course gives an overview of main approaches to program analysis and the theory behind them.


The course may be mathematically quite demanding, so overall fluency in mathematics is required.

**Topics covered:**

* Data-flow analysis
* Control-flow analysis
* Abstract interpretation
* Type-and-effect systems"
Computing for Computer Scientists,3,"* Wykład interaktywny
* Prezentacja
* Samodzielna praca przy komputerze
* Pracownia programistyczna
* Dyskusja",,False,True,"Celem przedmiotu jest przybliżenie studentom pierwszego roku podstawowych narzędzi do współtworzenia, kompilowania, uruchamiania, publikowania oraz dokumentowania swoich oraz cudzych programów.

Ten kurs jest planowany na 10 godzin wykładu, 10 godzin pracowni oraz 3 punkty ECTS.

Program przedmiotu:

  * Praca w systemie Linux: pliki, procesy, użytkownicy, potoki i strumienie, kompilowanie i uruchamianie programów. 
  * Polecenie ssh oraz podstawy kryptografii.
  * Systemy kontroli wersji na przykładzie systemu git.
  * Narzędzia do wyszukiwania informacji.
  * LaTeX.

Pracownia będzie głównie polegała na samodzielnym zgłębianiu tematów poruszanych na wykładzie. W wielu przypadkach zadania na pracowni będą wymagały od studentów samodzielnego znalezienia rozwiązania w dokumentacji lub
internecie."
Advanced data structures,6,"Wykład, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów, indywidualny/zespołowy projekt programistyczny",,False,False,"Na obowiązkowym wykładzie z Algorytmów i Struktur Danych zapoznajemy się głównie z klasycznymi strukturami danych, które w dość ograniczony sposób operują na danych wejściowych. Na przykład, do zaimplementowania struktury słownikowej opartej na dowolnych drzewach przeszukiwań binarnych potrzebujemy być w stanie tylko porównywać dwa elementy. Plusem takiego założenia jest to, że w często nietrudny sposób można udowodnić, że skonstruowana struktura jest optymalna. Należy się jednak zastanowić, czy ograniczenie się do porównywania elementów jest rozsądne.

Głównym celem wykładu będzie przedstawienie słuchaczom szeregu wyników w tak zwanym modelu Word RAM, w którym pozwalamy na wykonywanie operacji takich jak dodawanie, odejmowanie, przesunięcia bitowe, mnożenie czy też dzielenie na elementach (liczbach) przechowywanych w strukturze. Dla wspomnianego powyżej przykładu pozwala to na skonstruowanie słownika przechowującego zbiór liczb z przedziału [1,n^2] tak, aby każda operacja działała w czasie O(loglogn). Co ciekawe, pokażemy że nie da się lepiej!

Ze względu na częstą nieobecność prowadzącego we Wrocławiu, niektóre wykłady będą być może prowadzone w formie online lub jako 4h wykładu na miejscu raz na dwa tygodnie (i 4h ćwiczeń raz na dwa tygodnie). Szczegóły zostaną ustalone ze słuchaczami na początku semestru."
Proseminar: Blockchain Beyond Buzzwords,3,"Praca z materiałami źródłowymi, przygotowanie i wygłoszenie wystąpienia, konsultacje z prowadzącym, wystąpienia innych osób uczestniczących w seminarium, dyskusja",,False,False,"O blockchainie mówi i pisze się dużo, ale niekoniecznie z sensem. To proseminarium powinno choć trochę zbliżyć uczestniczki i uczestników do rzetelnego zrozumienia przynajmniej pewnych aspektów tej technologii.

Sugerowane źródła dla wystąpień to fragmenty książek uchodzących za podręczniki w tej tematyce (przy okazji będzie można ocenić, czy opinia jest trafna), różne _white papery_ (a także te w inne kolory czy wzorki) poszczególnych projektów, i ew. artykuły naukowe (bądź do takich aspirujące); lista ta wszelako nie jest zamknięta.

#### Informacja uzupełniająca dla zapisujących się w zimie 21/22 (w związku z brakiem spotkań przed końcem wypisów/zapisów):

Jako proseminarium przedmiot jest **przeznaczony zasadniczo dla słuchaczy studiów I stopnia**. Lista proponowanych tematów pojawi się na pierwszym spotkaniu (20 października), oczywiście można przedstawić swój własny pomysł. Zgodnie z nazwą i opisem przedmiotu, zależy mi na krytycznym spojrzeniu na to, co o okołoblockchainowych kwestiach się mówi – może to zainspiruje Państwa do znalezienia ciekawych tematów."
Combinatorics,6,"Wykład, wykład interaktywny, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań",,False,False,Wykład opisuje podstawowe zagadnienia kombinatoryczne nie zawarte w programie przedmiotu: matematyka dyskretna.
Selected Aspects of Practical Software Development,6,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",,False,False,"_Przedmiot dostępny w dwóch wersjach: kurs inżynierski za 5 ECTS oraz
przedmiot I1 z egzaminem za 6 ECTS (oba zaliczają te same grupy efektów
kształcenia). Wybór kursu (bez egzaminu) zaznacza się poprzez dodatkowe
zapisanie się do grupy ćwiczeniowej z etykietą ""wykład okrojony""._

Celem zajęć jest przedstawienie studentom praktyki projektowania obiektowego
oprogramowania. Zajęcia w zwięzły sposób łączą podstawową wiedzę z zakresu baz
danych i inżynierii oprogramowania w obszarze projektowania obiektowego w
wybranych współczesnych realiach technologicznych.

Wymagania: przyda się znajomość paradygmatu obiektowego, pojęć obiektu,
konstruktora, dziedziczenia, polimorfizmu i jego realizacji we współczesnych
językach programowania.

Zajęcia są pomyślane jako zamiennik dla następujących kanonicznych zajęć:

  * w części dotyczącej baz danych - Bazy danych

  * w części dotyczącej projektowania obiektowego (wzorce projektowe) i inżynierii oprogramowania - Projektowanie obiektowe oprogramowania

  * w części praktycznej dotyczącej wytwarzania aplikacji internetowych - specjalizowane kursy technologii wytwarzania aplikacji internetowych, m.in. kurs Projektowanie aplikacji ASP.NET, kurs Ruby on Rails, kurs WWW

## Wykład

Część podstawowa - obiejmuje materiał realizujący wymagania programowe:

  1. podstawy projektowania obiektowego
    1. analiza obiektowa 
    2. zbieranie wymagań
    3. przypadki użycia
  2. język UML
    1. diagramy klas, obiektów, zachowań i sekwencji
  3. od modelu pojęciowego do modelu relacyjnego
    1. etap modelu pojęciowego
    2. etap modelu obiektowego
    3. etap modelu relacyjnego
  4. podstawy praktyki baz danych
    1. tabele, kolumny, więzy
    2. klucze podstawowe, klucze obce
    3. widoki, procedury składowane
    4. indeksy
    5. język SQL - zapytania SELECT, INSERT, UPDATE, DELETE, podzapytania, klauzule WHERE, ORDER, TOP, JOIN, złączenia wewnętrzne i zewnętrzne
  5. język Javascript - nowoczesny hybrydowy język funkcyjno-obiektowy
    1. filozofia języka - Javascript jako praktyczna realizacja idei Javy - write once run everywhere
    2. historia, środowiska uruchomieniowe (Google V8, Microsoft Chakra)
    3. podstawowe elementy języka, zasięg zmiennych, hoisting
    4. system typów, dynamiczne/luźne typowanie
    5. obiekty, właściwości
    6. specyfika `this` \- wiązanie kontekstowe
    7. listy/tablice
    8. enumeracja składowych obiektów vs enumeracja elementów tablic
    9. funkcje jako typy pierwszoklasowe (first class citizens)
    10. memoizacja
    11. redefinicje funkcji
    12. domknięcia
    13. tworzenie obiektów - funkcje konstruktorowe, prototypy, literały
    14. dziedziczenie/enkapsulacja
    15. IIFE (immediately-invoked function expressions)
    16. lambda wyrażenia
    17. klasy
    18. generatory
    19. callbacks vs promises vs async/await
    20. modularyzacja 
    21. obiekty hostów - przeglądarka internetowa vs środowisko node.js
    22. debugowanie kodu w przeglądarce
    23. środowiska zintegrowane 
    24. narzędzia jakościowe: JSLint/JSHint/Closure 
    25. ekosystem/nadzbiory/transpilacja (Typescript/Coffeescript/ES6)
    26. Javascript jako język frontendowy i backendowy - kompilacja innych języków do Javascript (m.in. LLVM, emscripten, inne)
  7. aplikacja internetowa w przeglądarce
    1. podstawy HTML5, elementy struktury dokumentu
    2. podstawy CSS3, pozycjonowanie, wygląd, stylowanie responsywne
    3. podstawy modelu Document Object Model (DOM)
    4. model zdarzeniowy, pętla zdarzeń
    5. obiekt canvas i podstawy grafiki bitmapowej
  8. aplikacja internetowa na serwerze
    1. środowisko node.js, pakiety npm
    2. podstawowe moduły, m.in. filesystem, http
    3. framework Express - routing, wzorzec MVC, silnik widoków EJS
    4. framework Socket.IO 
    5. autentykacja/autoryzacja
    6. komunikacja z wybraną bazą danych 
  9. testy jednostkowe aplikacji Javascript - framework Mocha, technologia Selenium

Pracownia

Pracownia będzie polegała na uzupełnieniu materiału z wykładu szeregiem zadań
o charakterze praktycznym. Przewiduje się listy zadań odpowiadajace
poszczególnym partiom materiału z wykładu."
Human-Computer Interaction or Computer-Human Interaction (HCI or CHI),6,"* Wykład bogato ilustrowany materiałami audiowizualnymi  
* Ćwiczenia audytoryjne (ok. 300 zadań, pytania, omówienia, dyskusje, spory)
* Pracownia programistyczna (4 projekty rozwojowe realizowane w grupach 2-, 3-osobowych)
* Komplet materiałów wykładowych i innych na stronie wykładu w Sieci",,False,False,"**Cel zajęć.** Przedmiot jest poświęcony **wszechstronnemu** przeglądowi
zagadnień związanych z interakcją na styku człowiek-komputer (ang. _Human-Computer Interaction_) oraz projektowaniem rzeczy użytecznych i ładnych (ang.
_design_ ). Celem zajęć jest poznanie zasad rządzących procesem projektowania, oceny i realizacji interaktywnych interfejsów systemów komputerowych spełniających postulaty użyteczności (ang. _usability_). Na ćwiczeniach studentki i studenci omawiają tematy przedstawiane na wykładzie i wskazane w literaturze, prezentują i utrwalają samodzielnie zdobytą wiedzę. W ramach pracowni 
projektują i wykonują w zespołach dwu- lub trzyosobowych interfejs wybranej przez siebie aplikacji lub witryny sieciowej, działając etapowo, zgodnie z zasadami sztuki w tej dziedzinie.

**Wymagania.** Przedmiot „Komunikacja człowiek-komputer” jest wybitnie
interdyscyplinarny. Interfejsy komputerowe są poddawane analizie i refleksji w zetknięciu z rzeczywistym, typowym lub wyrafinowanym użytkownikiem. Prócz oczywistych kwalifikacji informatycznych, w tym technik inżynierii
oprogramowania (**osobny wykład**) i niektórych aspektów AI (**odrębny wykład**), szerzej – aplikacji zainteresowania psychologią, socjologią, antropologią, lingwistyką, fizjologią, ergonomią, wzornictwem przemysłowym, a nawet filozofią i sztuką dają osobie studiującej KCK (HCI) przewagę twórczą i
produkcyjną. Jeśli chodzi o narzędzia warsztatowe, wskazane jest elementarne rozeznanie w posługiwaniu się którymś z języków tworzenia interaktywnych stron WWW (np. HTML, **osobny wykład**), aplikacji
okienkowych (**inny wykład**), a także – być może najważniejsze – wprawne operowanie którymś z systemów konstruowania makiet interfejsów; jego uboczne, samodzielne opanowanie nie przysparza trudności, a znajomość ta stanowi swoistą „wartość dodaną”. 

**Cele szczegółowe.** Uczestnik kursu ma okazję poznać elementy składające się na dobry interfejs, w rozumieniu wywierania jak najkorzystniejszych wrażeń na użytkowniku docelowym, opanować podstawową wiedzę psychologiczną i socjologiczną w zakresie przydatnym w projektowaniu GUI, zrozumieć związki między udanym interfejsem a sukcesem ekonomicznym, poznać podstawowe zasady ergonomii i komunikacji werbalnej i wizualnej (a także dźwiękowej) z zastosowaniem w interfejsach komputerowych, reguły operowania przestrzenią, barwą, krojami pisma i innymi materiałami do budowy interfejsów oraz prześledzić techniki designerskie pomocne w tworzeniu interfejsów nowoczesnych komputerów i skomputeryzowanych urządzeń. Opanowuje praktycznie wybrane narzędzie projektowania makiet interfejsów graficznych.

**Pożytki.** Uczestnik kursu nabiera nowego spojrzenia i pojmowania graficznych (i in.) interfejsów użytkownika, świadomości i zasad rządzących konstruowaniem udanych GUI, przestaje być amatorem w podejściu do projektowania witryn sieciowych. Wiadomości z zakresu psychologii, socjologii, neurologii (jak działa pamięć człowieka) dają mu nowe, analityczne rozeznanie możliwości i ograniczeń zarówno człowieka, jak i wytwarzanych przez niego przedmiotów i maszyn, w tym — komputerów.

**Ramy wykładu.** Niżej podano tytuły wykładów. Szczegółowe wypunktowanie poruszanych zagadnień przekracza ramy tego streszczenia, jest dostępne w
trakcie semestru na stronie wykładu w witrynie SKOS.  
1\. Wstęp  
2\. Wyszukiwanie potrzeb  
3\. Analiza potrzeb [i] ludzi  
4\. Prototypowanie czas zacząć  
5\. Naucz się krytykować  
6\. Kształtowanie interfejsów  
7\. Zmysły mylą  
8\. Barwą, krojem i układem  
9\. Układ, liczy się układ  
10\. Inwentaryzacja GUI  
11\. GUI — dokończenie remanentu i wykład studencki  
12\. Wykłady studenckie

**Literatura.** Istnieje wiele dobrych podręczników KCK (HCI). Niektóre są dostępne bezpłatnie w Sieci.  Prócz tego Sieć zawiera mnóstwo artykułów poświęconych projektowaniu witryn i ogólniej — kwestiom designerskim interfejsów komputerowych. Od osoby studiującej i jej zainteresowań zależy, ile zdoła wydobyć w skończonym czasie semestru z internetowego morza fachowych rad i wiadomości. Na wykładzie są proponowane jako dodatkowe niektóre lektury, spośród wartych uwagi, pomieszczonych w Sieci. Oto kilka przewodnich podręczników:

1\. Lynch P. J., Horton S.: _Web Style Guide. 3rd Edition_. Yale University Press 2008. Książka dostępna w Sieci bez opłat.

2\. Van Duyne D. K., Landay J. A., Hong J. I.: _The Design of Sites: Patterns for Creating Winning Web Sites_. Prentice Hall Professional 2007.

3\. Leventhal L. M., Barnes J. A.: _Usability Engineering: Process, Products, and Examples_. Pearson/Prentice Hall 2008.

4 .Dzieła klasyków dziedziny, D. Normana i J. Nielsena — dostępne w Sieci.

5\. Inne wartościowe artykuły, przemyślenia, instruktaże i normy, m.in. na stronach firm 
Microsoft i Google.

W trakcie semestru materiały pomocnicze do wykładu są udostępniane na odpowiedniej stronie witryny SKOS.

**Formy zaliczenia.** Aktywne, twórcze uczestnictwo w ćwiczeniach i pracowni, opracowanie wartościowej i pełnej makiety wybranego interfejsu (w dążeniu do
ulepszenia istniejącej aplikacji lub zupełnie nowego), wykazanie się umiejętnością konstruktywnych ocen i krytyki przedmiotów użytkowych, w tym
aplikacji komputerowych. Umiejętne przedstawienie i przekazanie własnego wyrobu (GUI). Dodatkowo, w miarę możliwości czasowych, studenci mogą
przygotować na koniec semestru **własne wykłady** wzbogacające, a zwłaszcza unowocześniające, wiedzę o trendach, modach i praktyce w dziedzinie KCK (HCI).
Semestralny kurs kończy się egzaminem pisemnym.

**Uwaga dotycząca sposobu prowadzenia zajęć.** _Komunikacja-człowiek-komputer_ to przedmiot wybitnie interdyscyplinarny, a jego prowadzenie wiąże się z uruchamianiem (wyzwalaniem)  kreatywnych zdolności studentów. Przedmiot do roku 2020 nie był prowadzony _offline_. Z praktyki prowadzenia tych zajęć wynika, że choć przygotowywane materiały wykładowe zawierają w zasadzie komplet wiadomości potrzebnych do podejścia do egzaminu, to jednak brak bezpośredniego komentarza, żywej rozmowy z audytorium, rozważania pomysłów powstających w toku spontanicznych dyskusji — wszystko to jest trudne do aranżowania na odległość. Skoro jednak świat schodzi na takie metody, co pozostaje? Zdalne prowadzenie ćwiczeń z KCK uważam za trudne do realizacji, pracownię da się zorganizować w ten sposób. Powyższe uwagi pozostawiam tutaj jako _signum temporis_, miejmy nadzieję, że (na czas jakiś) minionego.     

20-05-04, 20-05-25, 21-09-20, 22-04-24 zpl..IIUWr"
Seminar: Advanced topics in semantics of programming languages,3,,,False,False,"Seminarium stanowi przegląd zaawansowanych zagadnień dotyczących semantyki języków programowania, takich jak:  

  * teoria dziedzin (PCF, full abstraction, relacje logiczne, równania na dziedzinach)
  * równoważność programów (bisymulacje, relacje logiczne)
  * semantyka typów (częściowe relacje równoważności, parametryczność)
  * game semantics
  
Literatura:

  1. Domain-Theoretic Foundations of Functional Programming. Thomas Streicher. World Scientific Publishing Co. Pte. Ltd., 2006.
  2. Domains and Lambda-Calculi. Martin Abadi and Pierre-Louis Curien. Cambridge University Press, 1998.
  3. Theories of Programming Languages. John C. Reynolds. Cambridge University Press, 1998.
  4. The Formal Semantics of Programming Languages: An Introduction. Glynn Winskel. The MIT Press, 1993.
  5. Game Semantics. Samson Abramsky and Guy L. McCusker. Logic and Computation: Proceedings of the 1997 Marktoberdorf Summer School, Springer-Verlag, 1998.
  6. Bisimilarity as a Theory of Functional Programming. Andrew D. Gordon. Theoretical Computer Science, 228(1-2):5-47, 1999."
Distributed Systems,6,"* Wykład wsparty materiałami audiowizualnymi

* Ćwiczenia audytoryjne (rozwiązywanie zadań, analiza problemów, sprawy dyskusyjne i wątpliwe)",,False,False,"Klasyczny temat, akademickie podejście. Powiedzieć że Internet jest przykładem systemu rozproszonego (A. Silberschatz i in.) to powiedzieć niepodważalną prawdę i zarazem nic nie powiedzieć. Wykład z systemów rozproszonych drąży problematykę SR w pół drogi między jej abstrakcjami a zagadnieniami realizacyjnymi (zob. **algorytmy rozproszone**, **sieci komputerowe**). Wykład jest oparty na podręczniku Maartena van Steena i Andrew S. Tanenbauma:
_**Distributed Systems 3rd edition (2017)**_, łatwo dostępnym w Sieci, stanowiącym trzecie wydanie książki wymienionych autorów (autorem pierwszego wydania jest tylko prof. Tanenbaum, oba wcześniejsze wydania mają polskie przekłady). Zaangażowani i samodzielni studenci mogą studiować SR bez specjalnego przygotowania, jest jednak wskazane, aby elementarne zagadnienia działania **sprzętu komputerowego** i **systemów operacyjnych**, a także pracy sieciowej zainteresowanym studentom nie były całkiem obce.

**Uwaga dotycząca sposobu prowadzenia zajęć.** Podobnie jak w przypadku _Seminarium z systemów_ praktyka semestru letniego roku akademickiego 2019-2020 wykazuje, że zajęcia z SR można poprowadzić zdalnie. Niemniej, podkreślam to za każdym razem, zajęcia prowadzone w trybie zdalnym są pewną namiastką zajęć prowadzonych konwencjonalnie. Niewykluczone że obie strony odczuwają pewien niedosyt. Powtarzam argumenty: zdalnie prowadzone zajęcia stępiają i ograniczają proces dydaktyczny,  eliminują możliwość prawdziwie bezpośredniego dyskursu, utrudniają ocenę w aspekcie osobowościowym, psychologicznym. Obecnie istnieją jednak przesłanki, że w nadchodzącym, nowym roku akademickim, praca zdalna nie będzie koniecznym surogatem.   

20-05-04, 20-05-25, 21-02-19, 22-04-24 zpl..IIUWr 

**Przegląd zagadnień**

1\. Wstęp

2\. Architektury

3\. Procesy

4\. Komunikacja

5\. Nazewnictwo

6\. Koordynacja

7\. Zwielokrotnienie

8\. Tolerowanie awarii

9\. Bezpieczeństwo

**Literatura**

1\. Van Steen M., Tanenbaum A.S.: _Distributed Systems 3rd edition_. Published
by Maarten van Steen 2017, previously published by Pearson Education Inc.  
.  
2\. Tanenbaum A.S., van Steen M.: _Systemy rozproszone. Zasady i paradygmaty_, przekł. zpl. Warszawa, Wydawnictwa Naukowo-Techniczne 2006. (2007 ang., 2017 ang., dostępne w Sieci).
  
Inne podręczniki

3\. Coulouris G., Dollimore J., Kindberg T.: _Systemy rozproszone –– podstawy
i projektowanie_ , przekł. zpl. Warszawa, WNT 1998 (lub wyd. ang. z 2012 r.,
dostępne w Sieci).

4\. Ghosh S.: _Distributed Systems: An Algorithmic Approach (2nd ed.)_. CRC Press 2014 (częściowo dostępne w Sieci).  
.  
5\. Tanenbaum A.S.: _Rozproszone systemy operacyjne_ , przekł. zpl. Wydawnictwo Naukowe PWN, Warszawa 1997.  
.  
6\. Chow R., Johnson T.: _Distributed Operating Systems & Algoritms_. Addison-
Wesley, Reading 1997.

Poza tym można korzystać z dowolnych innych materiałów (w tym artykułów) i podręczników akademickich do systemów rozproszonych, napotkanych w Sieci.

Wykładowi towarzyszą ćwiczenia mające na celu poszerzenie i utrwalenie poszczególnych tematów. W trakcie semestru materiały pomocnicze do wykładu są
udostępniane na odpowiedniej stronie witryny SKOS.

                                            *

Oprogramowanie niemal od początku przyrasta warstwami z tendencją do nadbudowywania kolejnych warstw. Systemy rozproszone wypełniają istotną, praktycznie nieusuwalną warstwę. Zapoznanie się z nią może w przyszłości ułatwić uprawianie... _archeologii informatycznej._ 

20-05-04, 21-02-19,  22-04-24 zpl..IIUWr"
Algorithms for Planar Graphs,6,,,False,False,"Wiele problemów grafowych, dla których istnieją algorytmy wielomianowe, można
rozwiązywać w czasie bliskim liniowego jeśli dany graf jest planarny. Na
przykład, minimalne cięcie rozdzielające dane dwa wierzchołki w planarnym
grafie nieskierowanym może być znalezione w czasie O(nlog(n)), podczas gdy
czas działania najlepszego znanego algorytmu dla dowolnego grafu
nieskierowanego to O(n^3). Celem wykładu jest zapoznanie studentów z
technikami używanymi do konstruowania efektywnych algorytmów dla grafów
planarnych, między innymi:

  1. Kombinatoryczna definicja grafu planarnego.
  2. Dualność.
  3. Separatory.
  4. Najkrótsze ścieżki dla nieujemnych wag krawędzi.
  5. Najkrótsze ścieżki z wielu źródeł.
  6. Najkrótsze ścieżki dla dowolnych wag krawędzi, własność Monge'a.
  7. Dense distance graph (DDG), najkrótsze ścieżki w DDG.
  8. Wyrocznie aproksymujące odległość.
  9. Diagramy Voronoi'a dla grafów planarnych i wyrocznie odległości.
  10. Minimum st cut w grafie nieskierowanym.
  11. Maximum st flow w grafie skierowanym.
  12. Techniki aproksymacyjne dla grafów planarnych: branchwidth, treewidth, technika Baker.
  13. Aproksymacja TSP w grafie planarnym."
Theory of argumentation and elements of logical semiotics,3,Wykład,,False,False,"** Przedmiot prowadzony przez dr. hab. Marcina Selingera z Katedry Logiki i Metodologii Nauk WNS UWr. **

#### I. Przedmiot i podstawowe zagadnienia teorii argumentacji [6, 10, 12, 14].
1. Problematyka argumentacji w filozofii i nauce.
2. Współczesne nurty i tematyka badań.
3. Semiotyka i jej podstawowe działy: syntaktyka, semantyka i pragmatyka.
#### II. Struktura argumentacji potocznej [9, 10, 12, 14].
1. Wypowiedź argumentacyjna i pojęcie argumentu. Perswazyjno-performatywny charakter wypowiedzi
argumentacyjnej. Austina-Searle’a teoria aktów mowy.
2. Budowa argumentów I. Struktury standardowe (argumenty proste, szeregowe, równoległe, seryjne).
3. Budowa argumentów II. Elementy dialektyczne (argumenty kondukcyjne i zdania podcinające).
4. Budowa argumentów III. Rozumowania założeniowe i klasyfikacja rozumowań.
5. Formalne ujęcie struktur argumentacyjnych. Diagramy argumentacyjne.
6. Kontrargumenty i relacja ataku.
#### III. Ocena argumentacji [4, 9, 10, 11, 12, 13, 14]
1. Trzy poziomy oceny siły argumentu: logiczny, perswazyjny i społeczny.
2. Interpretacja przesłanek i konkluzji argumentu. Implikatura konwersacyjna i maksymy konwersacyjne
Grice’a.
3. Poprawność materialna argumentacji i petitio principii. Semantyczne pojęcie prawdy a syntaktyczne
pojęcie dowodu. Twierdzenie Tarskiego o niedefiniowalności prawdy i twierdzenie Gödla o
niezupełności arytmetyki.
4. Prawda a szczerość. Logiczne aspekty kłamstwa.
5. Argumenty dedukcyjne. Metoda konstrukcji i deduktywizm w badaniach nad siłą argumentów. Analiza
argumentacji dedukcyjnej na przykładzie logiki nazw [1, 7, 12, 13].
a) Definicja nazwy, desygnat i zakres nazwy. Stosunki między zakresami nazw.
b) Klasyczne zdania kategoryczne i ich interpretacja ekstensjonalna. Diagramy Venna.
c) Prawa kwadratu logicznego. Prawa konwersji, obwersji i kontrapozycji. Klasyczne sylogizmy
kategoryczne.
6. Argumenty niededukcyjne. Schematy argumentacyjne i krytyczne pytania.
a) Problematyka błędu w argumentacji. Dekalog pragma-dialektyczny vanEemerena i Grootendorsta.
b) Przegląd rodzajów argumentów i typowych błędów związanych z argumentacją.
#### IV. Wybrane modele oceny siły argumentu [10, 12]
1. Podejście strukturalne.
2. Podejście dialektyczne.
3. Abstrakcyjna teoria argumentacji.
4. Podejście empiryczne."
Project: Artifical intelligence for Regular Boardgames,4,"Projekt programistyczny, dyskusja.",,False,False,"W ramach projektu będziemy rozwijać projekt języka regularnych gier planszowych (RBG).
W szczególności będzie to polegało na opracowaniu i implementacji ogólnych algorytmów sztucznej inteligencji potrafiących grać w dowolną opisaną grę w tym języku.
Wykorzystywać będziemy różne podejścia takie jak: klasyczne heurystyki, metody specyficzne dla języka, uczenie się.

Są też dostępne zadania związane z interfejsem dla gracza oraz projektowaniem gier i generatorów gier stanowiących wyzwanie dla naszych algorytmów.

Implementacje będziemy wykorzystywać do celów badawczych, co może zaowocować pracą naukową z dziedziny AI/Game Playing.

Projekt będzie realizowany razem z Jakubem Kowalskim.

Wymagania:
* C++;
* i/lub Python, do niektórych zadań.
* Mile widziana, ale nie konieczna, wiedza z zakresu sieci neuronowych, reinforcement i deep learning.

*Jeśli zaszłaby konieczność prowadzenia zajęć zdalnie to nie ma to wpływu na ten przedmiot. Co najwyżej nie będziemy się spotykać na żywo.*"
Decidability and Complexity of Logics Motivated by Computer Science,3,Samodzielne przygotowanie i wygłoszenie prezentacji. Dyskusja na temat prezentacji własnej i innych uczestników.,,False,False,"Na seminarium czytać będziemy prace dotyczące rozstrzygalności i złożoności problemów spełnialności (czy dana formuła ma model),
skończonej spełnialności (czy dana formuła ma model skończony) oraz związanych z nimi problemów odpowiadania na zapytania do baz danych/baz wiedzy (dla danej bazy D, teorii logicznej T i zapytania q, czy prawdą jest, że każdy model/skończony model D i T spełnia q?)

Interesować nas będą fragmenty logiki pierwszego rzędu (two-variable fragment, guarded fragment, unary negation fragment, guarded negation fragment, ...) oraz logiki deskrypcyjne.

Materiał będzie się częściowo pokrywał z materiałem przedmiotu Problemy Decyzyjne w Logice, ale będzie też sporo innych rzeczy i osoby, które ten przedmiot zaliczyły mogą śmiało zapisać się na seminarium. 

Niewykluczone, że spotkamy się z pewnymi problemami otwartymi, które będzie można próbować rozwiązać."
Automata theory,6,"Wykład, rozwiązywanie zadań",,False,False,"Wykład będzie dotyczył klasycznych wyników z teorii automatów skończonych oraz bardziej zaawansowanych modeli automatów. Część zagadnień pojawia się na JFiZO a na tych zajęciach zostaną omówione dogłębniej. 
Na przykład: 
- Każdy NFA można przekształcić do równoważnego wyrażenia regularnego i vice versa. Jak się ma rozmiar NFA do rozmiaru wyrażenie regularnego?
- Języki regularne spełniają lemat o pompowaniu. Czy zachodzi twierdzenie odwrotne? 


Program:
    Automaty skończone:
    a) Równoważne definicje języków regularnych: automaty, wyrażenie regularne, WMSO i monoidy.
    b) Twierdzenia Kleene'go, Myhilla-Neroda i ich zastosowania.
    c) Uczenie się automatów. 
    d) Minimalizacja automatów.
 
    Automaty na słowach nieskończonych.
    a) Automaty Buchiego oraz inne warunki akceptacji.
    b) Zamkniętość języków omega-regularnych ze względu na sumę, przekrój, dopełnienie. 
    c) Determinizacja automatów na słowach nieskończonych.

    Automaty na drzewach oraz drzewach nieskończonych.
    a) Podstawowe definicje i własności.
    b) Związki automatów na drzewach z grami na grafach.

    Gry na grafach.
    a) Podstawowe definicje.
    b) Strategie: bezpamięciowe, ze skończoną pamięcią oraz z nieskończoną pamięcią.

    Automaty z wagami.
    a) Podstawowe definicje.
    b) Zastosowania w rozpoznawaniu mowy i weryfikacji."
Selected Aspects of Practical Software Development,5,"* Projekt programistyczny
* Pracownia programistyczna
* Wykład

W razie konieczności nauczania zdalnego - materiały online.",,False,False,"Celem zajęć jest przedstawienie studentom praktyki projektowania obiektowego
oprogramowania. Zajęcia w zwięzły sposób łączą podstawową wiedzę z zakresu baz
danych i inżynierii oprogramowania w obszarze projektowania obiektowego w
wybranych współczesnych realiach technologicznych.

Wymagania: przyda się znajomość paradygmatu obiektowego, pojęć obiektu,
konstruktora, dziedziczenia, polimorfizmu i jego realizacji we współczesnych
językach programowania.

Zajęcia są pomyślane jako zamiennik dla następujących kanonicznych zajęć:

  * w części dotyczącej baz danych - Bazy danych

  * w części dotyczącej projektowania obiektowego (wzorce projektowe) i inżynierii oprogramowania - Projektowanie obiektowe oprogramowania

  * w części praktycznej dotyczącej wytwarzania aplikacji internetowych - specjalizowane kursy technologii wytwarzania aplikacji internetowych, m.in. kurs Projektowanie aplikacji ASP.NET, kurs Ruby on Rails, kurs WWW

## Wykład

Część podstawowa - obejmuje materiał realizujący wymagania programowe:

  1. podstawy projektowania obiektowego
    1. analiza obiektowa 
    2. zbieranie wymagań
    3. przypadki użycia
  2. język UML
    1. diagramy klas, obiektów, zachowań i sekwencji
  3. od modelu pojęciowego do modelu relacyjnego
    1. etap modelu pojęciowego
    2. etap modelu obiektowego
    3. etap modelu relacyjnego
  4. podstawy praktyki baz danych
    1. tabele, kolumny, więzy
    2. klucze podstawowe, klucze obce
    3. widoki, procedury składowane
    4. indeksy
    5. język SQL - zapytania SELECT, INSERT, UPDATE, DELETE, podzapytania, klauzule WHERE, ORDER, TOP, JOIN, złączenia wewnętrzne i zewnętrzne

  5. język Javascript - nowoczesny hybrydowy język funkcyjno-obiektowy
    1. filozofia języka - Javascript jako praktyczna realizacja idei Javy - write once run everywhere
    2. historia, środowiska uruchomieniowe (Google V8, Microsoft Chakra)
    3. podstawowe elementy języka, zasięg zmiennych, hoisting
    4. system typów, dynamiczne/luźne typowanie
    5. obiekty, właściwości
    6. specyfika `this` \- wiązanie kontekstowe
    7. listy/tablice
    8. enumeracja składowych obiektów vs enumeracja elementów tablic
    9. funkcje jako typy pierwszoklasowe (first class citizens)
    10. memoizacja
    11. redefinicje funkcji
    12. domknięcia
    13. tworzenie obiektów - funkcje konstruktorowe, prototypy, literały
    14. dziedziczenie/enkapsulacja
    15. IIFE (immediately-invoked function expressions)
    16. lambda wyrażenia
    17. klasy
    18. generatory
    19. callbacks vs promises vs async/await
    20. modularyzacja 
    22. debugowanie kodu w przeglądarce
    23. środowiska zintegrowane 
    24. narzędzia jakościowe: JSLint/JSHint/Closure 
    25. ekosystem/nadzbiory/transpilacja (Typescript/Coffeescript/ES6)
    26. Javascript jako język frontendowy i backendowy - kompilacja innych języków do Javascript (m.in. LLVM, emscripten, inne)
  7. aplikacja internetowa w przeglądarce
    1. podstawy HTML5, elementy struktury dokumentu
    2. podstawy CSS3, pozycjonowanie, wygląd, stylowanie responsywne
    3. podstawy modelu Document Object Model (DOM)
    4. model zdarzeniowy, pętla zdarzeń
    5. obiekt canvas i podstawy grafiki bitmapowej
  8. aplikacja internetowa na serwerze
    1. środowisko node.js, pakiety npm
    2. podstawowe moduły, m.in. filesystem, http
    3. framework Express - routing, wzorzec MVC, silnik widoków EJS
    4. framework Socket.IO 
    5. autentykacja/autoryzacja
    6. komunikacja z wybraną bazą danych 
  9. testy jednostkowe aplikacji Javascript - framework Mocha, technologia Selenium

Pracownia

Pracownia będzie polegała na uzupełnieniu materiału z wykładu szeregiem zadań
o charakterze praktycznym. Przewiduje się listy zadań odpowiadajace
poszczególnym partiom materiału z wykładu."
Seminar: advanced algorithmics,3,,,False,False,"Celem seminarium jest zapoznanie studentów z wybranymi wynikami publikowanymi
na konferencjach algorytmicznych typu SODA/ICALP/ESA/... oraz wprowadzenie ich
do własnych badań. Większość z prezentowanych prac będzie pochodzić z kilku
ostatnich lat, ale niektóre z nich będą także okazją do uzupełnienia wiedzy z
zakresu klasyki AiSD.

Ubocznym (lecz istotnym dla studentów) efektem zajęć może być wyników, które legną u podstaw pracy magisterskiej.

Niektóre zajęcia będą miały formę spotkania online, na którym referat wygłoszą goście spoza Wrocławia. W związku z tym zajęcia będą prowadzone w języku angielskim."
Numerical Analysis (B),8,"* wykład 
* wykład interaktywny 
* ćwiczenia z systemem deklaracji (rozwiązywanie zadań teoretycznych i typu _włącz komputer_ z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów, analiza algorytmów pod kątem ich poprawności, złożoności i aspektów numerycznych)",,False,False,"Celem zajęć jest przedstawienie podstawowych metod i algorytmów rozwiązywania
typowych zadań obliczeniowych. Omawiane zagadnienia mają wielorakie
zastosowania m.in. w obliczeniach naukowych czy grafice komputerowej.

**Uwaga COVID-19/20/21/22** 

W razie konieczności zajęcia lub ich część prowadzone będą w formie zdalnej lub hybrydowej (przy użyciu Microsoft Teams oraz m.in. tabletu graficznego).

**Wymagania**

  * analiza matematyczna,
  * algebra.

**Program wykładu**

  1. _Analiza błędów._ Arytmetyka zmiennopozycyjna. Uwarunkowanie zadania. Algorytmy numerycznie poprawne.
  2. _Rozwiązywanie równania nieliniowych._ Ogólna teoria metod iteracyjnych. Metody: bisekcji, Newtona i siecznych.
  3. _Interpolacja._ Wzór interpolacyjny Lagrange'a. Reszta wzoru interpolacyjnego i znaczenie odpowiedniego doboru węzłów (węzły równoodległe i ""Czebyszewa""). Wzór interpolacyjny Newtona. Interpolacja za pomocą funkcji sklejanych III stopnia, krzywe Béziera i ich zastosowania w grafice komputerowej.
  4. _Aproksymacja._ Metoda najmniejszych kwadratów. Dyskretna aproksymacja średniokwadratowa za pomocą wielomianów - wielomiany ortogonalne, twierdzenie o _n_ -tym wielomianie optymalnym. Informacja o aproksymacji jednostajnej.
  5. _Kwadratury._ Kwadratura liniowa. Reszta i rząd kwadratury. Zbieżność ciągu kwadratur. Kwadratury interpolacyjne. Kwadratury Newtona-Cotesa. Wzory złożone: trapezów i Simpsona. Metoda Romberga. Kwadratury Gaussa-Legendre'a.
  6. _Algebra numeryczna._ Informacja o uwarunkowaniu zadania rozwiązywania układu równań liniowych. Rozkład macierzy kwadratowej na iloczyn macierzy trójkątnych. Obliczanie wyznaczników. Obliczanie macierzy odwrotnej. Metoda eliminacji Gaussa i jej warianty.

**Literatura**

  * Å. Björck, G. Dahlquist, _Metody numeryczne_ , PWN, 1987.
  * G. Dahlquist, Å. Björck, Numerical methods in scientific computing, Vol. I, SIAM, 2008.
  * M. Dryja, J.i M. Jankowscy, _Przegląd metod i algorytmów numerycznych_ , cz. 1 i 2, WNT, 1988.
  * D. Kincaid, W. Cheney, _Analiza numeryczna_ , WNT, 2005.
  * J. Stoer, R. Bulirsch, _Wstęp do analizy numerycznej_ , PWN, 1987."
Competition Protection in the Market Economy,3,Wykład,,False,False,"*Przedmiot prowadzony przez dr hab. Darię Kostecką-Jurczyk  z  Instytutu Nauk Ekonomicznych.*

Celem przedmiotu jest przedstawienie studentom podstawowych zasad
ochrony konkurencji w Polsce oraz Unii Europejskiej, w tym dozwolonych i zakazanych ograniczeń
konkurencji przez przedsiębiorców, procesów monopolizacji gospodarki a także kontroli fuzji oraz
przejęć spółek handlowych."
Half-course: Hacking for everyone,3,"Prezentacja, praca własna na dedykowanej platformie, dyskusja i wymiana doświadczeń.",,False,False,"Celem kursu jest zaznajomienie uczestników z technikami hakowania różnych elementów systemów informatycznych. Przedmiot będzie miał charakter zadań typu CTF i będzie oparty o platformę CyberQ od EC Council. Zakres tematyczny będzie zbliżony do określonego przez certyfikację Certified Ethical Hacker (CEH).

W pierwszej edycji kurs będzie oparty głównie o pracę studentów, którzy przy wsparciu prowadzącego będą zbierać ""flagi"" w wybranych scenariuszach, a następnie przedstawiać rozwiązania pozostałym uczestnikom, wymieniając doświadczenia."
Scheduling theory,6,"* A lecture with blackboard and/or slide presentation
* An exercise session with collaborative supervised problem solving
* Individual student work on homework sheets
* Discussions",,False,False,"Scheduling theory investigates the assignment of tasks to resources with the intent of minimizing some cost.
A classical example is assigning jobs of various lengths to machines, so that the load of the machines
is as balanced as possible, for example by minimizing the load of the busiest machine. Naturally, scheduling
has a myriad of applications both inside and outside of computing, including logistics, operation management,
worker allocation as well as scheduling CPU-bound tasks and scheduling virtual machines in a cloud environment.

This course focuses on scheduling theory as a branch of theoretical computer science, and our main goal is to
design optimal algorithms -- or, if not optimal, then at least provably efficient ones. 

Throughout the course, we shall introduce the main algorithmic tools used for in the area of scheduling theory,
and present select major results in the area which use these tools. In particular, we will focus on 
optimal polynomial-time algorithms for scheduling problems, approximation algorithms, and online algorithms.

Sample topics:

* Introduction to scheduling theory, overview of the area, Graham notation.
* List scheduling, online list scheduling. List scheduling on machines with different speeds.
* Dynamic programming and its applications in scheduling.
* Preemptive list scheduling minimizing the sum of weighted completion times.
* Scheduling on unrelated parallel machines.
* Online throughput scheduling of unit and equal-size jobs.
* Semi-online scheduling: known optimum makespan, known sum of processing times.

The course is aimed at Master-level students of computer science, but advanced Bachelor-level students
with interest in algorithm design are also welcome. Knowledge of basic algorithms and data structures is required.
Basic familiarity with the theory of online computation and the theory of linear optimization will be useful at
later stages of the course, but is not mandatory.

The exercise sessions will consist of problem solving practice in class, and grades for the exercise sessions will
be determined by two larger homework sheets throughout the semester. An oral exam on the topics of the lecture
will determine the final grade.

The course will be taught completely in English.

Literature:

 * M. L. Pinedo. Scheduling: Theory, Algorithms, and Systems. Springer, 2008. 
 * Peter Brucker: Scheduling Algorithms. Springer, 2007.
 * D. P. Williamson, D. B. Shmoys: The Design of Approximation Algorithms.  Cambridge University Press, 2012. Available online: https://www.designofapproxalgs.com/
 * B. Chen, C. N. Potts, G. J. Woeginger: A review of machine scheduling: Complexity, algorithms and approximability. In D. Z. Du and P. M. Pardalos. Handbook of Combinatorial Optimization, 1998.

Similar courses at other universities:
* https://www.cs.dartmouth.edu/~deepc/Courses/S09/lectures.html
* https://www-m9.ma.tum.de/WS2015/Scheduling"
Computer systems,6,"* Wykład
* Ćwiczenia audytoryjne
* Pracownia programistyczna
* Samodzielna praca przy komputerze",,False,False,"Elementarny wykład z architektury komputerów i struktury systemów
operacyjnych, ze szczególnym uwzględnieniem interakcji pomiędzy tymi dwoma
komponentami systemów komputerowych. Oprócz zrozumienia najważniejszych idei,
studenci nabędą praktyczne umiejętności niezbędne współczesnemu programiście:
podstawy programowania niskopoziomowego (na przykładzie asemblera x86-64), programowania systemowego (obsługa plików, procesów, komunikacji
międzyprocesowej) i współbieżnego (synchronizacja, współdzielenie zasobów).
Zrozumieją, jak używane przez nich konstrukty językowe wpływają na wydajność
programów. Wykładowi towarzyszy ćwiczenio-pracownia.

Studenci będą zachęcani do kontynuowania przygody z budową i organizacją
systemów komputerowych na bardziej zaawansowanych wykładach: “Architektury
systemów komputerowych”,“Systemy operacyjne” (_uwaga: za te dwa przedmioty nie będzie można wtedy uzyskać punktów ECTS_), “Struktura jądra systemu UNIX”, “Projekt: System operacyjny Mimiker“.

Więcej informacji o wykładze w sylabusie.

Wykład opracowany wspólnie z Krystianem Bacławskim."
Operating Systems,8,"Wykład, grupowa analiza kodu źródłowego, rozwiązywanie zadań z komentowaniem, indywidualne rozwiązywanie zadań, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, samodzielna praca przy komputerze, indywidualny projekt programistyczny.",,False,False,"Celem wykładu jest zapoznanie słuchaczy z wybranymi aspektami systemu uniksowego z punktu widzenia programisty. Na przykładzie wywołań systemowych i narzędzi systemu _Linux_ zostaną przedstawione najważniejsze osiągnięcia w dziedzinie systemów operacyjnych.

Organizacja oraz algorytmy i struktury danych jądra systemu operacyjnego będą omawiane na przedmiocie _„Struktura jądra UNIX”_.

## Lista tematów

1. Wprowadzenie
   * jądro systemu operacyjnego
   * przestrzeń adresowa
   * izolacja przestrzeni jądra i użytkownika
   * zmiana kontekstu i przestrzeni adresowej
   * przerwania sprzętowe i wywłaszczanie
   * dyspozytor i planista zadań
   * wywołania systemowe `strace`, obsługa pułapek i błędów
   * model aplikacji w systemach uniksowych
   * model maszyny procesu w systemie uniksowym
2. Procesy
   * zasoby i stan procesu
   * parametry procesu `argv` i zmienne środowiskowe `envp`
   * tworzenie procesów `fork`
   * ładowanie programów `execve`
   * kończenie procesów `exit`
   * oczekiwanie na zmianę stanu procesów potomnych `waitpid`
   * hierarchia procesów: `getpid`, `getppid`
3. Sygnały
   * sygnały synchroniczne i asynchroniczne, domyślne akcje
   * wysyłanie sygnałów: `kill`
   * procedury obsługi sygnałów: `signal` i `sigaction`
   * pojęcie sekcji krytycznej i wyścigu
   * funkcje wielobieżne
   * blokowanie i odblokowanie sygnałów `sigprocmask`
   * oczekiwanie na sygnały `sigsuspend`
   * nielokalne skoki: `setjmp` i `longjmp`
4. Zarządzanie zadaniami
   * grupy procesów: `setpgid`
   * grupa pierwszoplanowa i grupy drugoplanowe: `tcsetpgrp`
   * sesje i terminal sterujący
   * organizacja powłoki uniksowej
   * wstrzymywanie `SIGSTOP` i wznawianie procesów `SIGCONT`
5. Pliki
   * różnice między interfejsem `stdio.h` i uniksowym `unistd.h`
   * typy plików: zwykłe, katalogi, urządzenia, potoki, gniazda, etc.
   * hierarchia plików, ścieżki, punkty montażowe
   * bieżący katalog roboczy
   * domyślnie otwarte pliki `stdin`, `stdout`, `stderr`
   * otwieranie `open` i zamykanie `close` plików oraz wybrane flagi plików
   * odczyt `read` i zapis `write`, pułapki z _short counts_
   * właściwości pliku terminala
   * kursor pliku i zmiana jego pozycji `lseek`, powstawanie dziur
   * zmiana rozmiaru pliku `truncate`
   * zmiana właściwości urządzeń wejścia-wyjścia `ioctl`
   * tablica deskryptorów vs. otwarte pliki
   * wpływ `fork` na tablicę deskryptorów
   * przekierowania plików `dup` i `dup2`
   * operacje na deskryptorach plików `fcntl`
   * zamykanie plików przy `execve` i flaga `CLOEXEC`
6. System plików
   * metadane i lista bloków pliku, i-węzły
   * odczyt metadanych pliku `stat`
   * sprawdzenie uprawnień dostępu do plików
   * zmiana uprawnień `chmod` i właściciela pliku `chown`
   * wpisy katalogów `dirent`, odczyt katalogu `readdir`
   * dowiązania twarde `link` i symboliczne `symlink`
   * odczyt dowiązań symbolicznych `readlink` i `lstat`
   * superblok i odczyt metadanych systemu plików `statvfs`
   * księgowanie i operacje idempotentne
7. Buforowanie plików
   * wpływ buforowania na wydajność programów
   * buforowanie plików w jądrze `fsync`
   * buforowanie danych vs. metadanych
   * spójność danych a buforowanie
   * wybór strategii buforowania w _stdio_ `setvbuf`
   * odczyty i zapisy rozproszone `readv` i `writev`
8. Tożsamość, autoryzacja i uwierzytelnianie
   * autoryzacja vs. uwierzytelnianie
   * tożsamość procesu `getuid`, `getgid`, `getgroups`
   * identyfikatory vs. nazwy `getent`
   * przestrzenie nazw zasobów
   * przejęcie tożsamości pliku wykonywalnego (set-uid, set-gid)
   * zmiana tożsamości `setreuid`
9. Komunikacja międzyprocesowa
   * tworzenie potoków `pipe` i `pipe2`
   * łączenie procesów przy pomocy potoków
   * właściwości potoków, atomowe zapisy
   * gniazda datagramowe i strumieniowe
   * gniazda domeny uniksowej 
10. Pamięć wirtualna
    * metody przydziału pamięci wirtualnej `sbrk` i `mmap`
    * odwzorowania plików i obiektów anonimowych
    * struktury opisujące przestrzeń adresową `pmap`
    * obsługa błędu strony, przestrzeń wymiany
    * zbiór roboczy i rezydentny, buforowanie stron 
    * współdzielenie pamięci i mechanizm _copy-on-write_
    * tworzenie `mmap` i niszczenie `munmap` odwzorowań
    * zmiana uprawnień odwzorowań `mprotect`
    * synchronizacja pamięci z obiektami wspierającymi `msync`
    * przechwytywanie błędów stron, obsługa `SIGSEGV`
11. Zarządzanie stertą
    * interfejs biblioteki standardowej: `malloc`, `realloc` i `free`
    * organizacja pamięci alokatora: bloki i areny
    * fragmentacja wewnętrzna i zewnętrzna, kompaktowanie
    * zarządzanie listą wolnych bloków
    * podział i złączanie bloków
    * polityki przydziału (first-fit, best-fit)
    * algorytm znaczników granicznych (boundary tags)
    * algorytm kubełkowy (segregated fits)
    * wykrywanie błędnych odwołań do pamięci (kanarki)
    * pule obiektów i przydział płytowy (slab allocator)
12. Programowanie sieciowe
    * architektura klient-serwer
    * nazewnictwo stron komunikacji
    * protokoły połączeniowe i bezpołączeniowe
    * interfejs gniazd BSD
    * nawiązywanie połączeń
    * nasłuchiwanie i akceptowanie połączeń
    * adres powiązany z gniazdem
    * współbieżna obsługa wielu połączeń `select` i `poll`
13. Wątki
    * model wielowątkowości w uniksach
    * współdzielenie pamięci
    * wyścigi i procedury wątkowo bezpieczne
    * thread local storage
    * tworzenie `pthread_create` wątków
    * złączanie `pthread_join` wątków i wątki odczepione (detached)
    * wątki i `fork`, `exit` i `execve`
    * wątki i sygnały
    * wątki i operacje wejścia-wyjścia
14. Synchronizacja
    * muteksy i semafory
    * problem czytelników i pisarzy
    * ziarnistość blokad
    * głodzenie i zakleszczenia
    * problem odwócenia priorytetów
    * zmienne warunkowe i monitory
    * blokady współdzielone

##### Zajęcia

Większość zajęć do przedmiotu będzie prowadzona w postaci ćwiczeń z deklaracjami. Na pracowni programistycznej będą do wykonania co najmniej trzy duże projekty:

 * prosta powłoka uniksowa `shell`
 * algorytm przydziału pamięci `malloc`
 * system plików `ext2`


##### Zmiana od roku akademickiego 2021/2022

**W związku ze zmianą wymiaru godzinowego, od roku 2021/2022 zmienia się liczba punktów ECTS z 6 do 8.**"
Introduction to Linear Optimization,6,"* Lectures with blackboard and/or slide presentation
* Exercise sessions with collaborative supervised problem solving 
* Individual student work on homework sheets
* Simple programming tasks (usage of LP solvers)",,False,False,"The course will be given jointly by:
* Martin Böhm and 
* Jarosław Byrka

Linear optimization, or linear programming, is a study of encoding
mathematical problems -- from the very fundamental in computer
science, such as flow and matching problems, to problems central to
supply chain and logistics -- as problems described by a set of linear
equalities, where the quality of a solution is also measured by a
linear function.

The centerpoint of linear optimization is the fact that efficient
algorithms -- in both theoretical and practical sense of the word --
exist to find the optimal solution of such a linear system.

We can see the practical impact of linear optimization by the fact
that early research into this field has been awarded the 1975 Nobel
Memorial Prize in Economics. On the theoretical side, many advanced
courses in algorithm design benefit from knowledge of linear programming,
among others:

 * Approximation algorithms (Algorytmy aproksymacyjne, https://zapisy.ii.uni.wroc.pl/offer/algorytmy-aproksymacyjne_8/ )
 * Online algorithms (Algorytmy online, https://zapisy.ii.uni.wroc.pl/offer/algorytmy-online_16/)
 * Algorithmic game theory (https://zapisy.ii.uni.wroc.pl/offer/712-algorithmic-game-theory/)
 * Submodular optimization (Optymalizacja submodularna, https://zapisy.ii.uni.wroc.pl/offer/3160-optymalizacja-submodularna/ )
 * Scheduling theory (https://zapisy.ii.uni.wroc.pl/offer/3153-scheduling-theory/)
 
This course offers a thorough introduction to the theory of linear
optimization, with a particular focus on both the mathematical
background of the area as well as empowering the student to be able to
model many computer science problems as linear systems, and solve such
systems on a computer with the use of a linear programming solver.

The course is aimed at Bachelor-level (undergraduate)
Computer Science students and above, and is appropriate for first-year
Master-level students as well. A basic knowledge of linear algebra is
expected.

The exercise sessions will consist of a combination of theoretical
problem solving practice in class and practical modelling tasks to be
solved with the help of a computer solver. The grade for the exercises
will be determined by a set of several homework sheets throughout the
semester. The course will be concluded with a final exam, which will
be oral or written depending on the number of attending students.

The course will be taught completely in English.

Sample topics:
 * Introduction to linear programming and integer programming.
 * Modeling with linear and integer programs.
 * Convexity and its properties.
 * Hyperplanes, polytopes and polyhedra. Farkas lemma.
 * Duality in linear optimization.
 * Ellipsoid method: an algorithm for solving linear programs. 
 * Solution methods for large LPs: separation oracles and column generation methods.
 * Network flows and their algorithms. Duality between network flows and graph cuts.
 * Integrality of selected combinatorial polytopes. Linear relaxations of integer programs.
 
 Literature: 
 * Jiří Matoušek, Bernd Gärtner. Understanding and Using Linear Programming. Springer 2007  (https://link.springer.com/book/10.1007/978-3-540-30717-4)
 * Lecture notes of Alexander Shrijver (in particular, Section 2 of https://homepages.cwi.nl/~lex/files/dict.pdf)"
Course: Game Development in Unity3D,5,"* Wykład
* Pracownia programistyczna
* Projekt programistyczny",,False,False,"Program kursu będzie obejmować tworzenie gier w silniku Unity3D.  
Rozpocznie się kilkoma wykładami dotyczącymi podstaw silnika Unity oraz ogólnego wprowadzenia do branży gier.  
Tematyką kolejnych wykładów będzie m.in.:

* tworzenie skryptów c#, i łączenie ich z głównym silnikiem (GameObject, Component, MonoBehaviour, zmienne publiczne edytowalne),
 prefaby, instancjonowanie, Update/FixedUpdate/Start, wyszukiwanie obiektów z kodu
* modelowanie, teksturowanie, import assetów
* fizyka (soft, rigid body), systemy cząsteczek
* animacje, maszyna stanów, animacja menu, animacja ludzi
* oświetlenie, bakowanie lightmap, daylight, artificial light
* shadery
* testowanie (w tym testy automatyczne), TDD (test driven development)
* materiały (w tym Physically Based Shading materials)
* rodzaje renderingu (forward, deferred)
* efekty post process (np. bloom, color grading)
* efekty: screen space ambient occlusion i screen space reflections
* standard assety

Kurs jest od podstaw, co oznacza, że nie wymaga wcześniejszej znajomości C# ani programu do modelowania 3D.

Wykład będzie prowadzony w cyklu 2-godzinnym: na pierwszej godzinie omawiany będzie kolejny fragment silnika Unity, a na drugiej zdobyta wiedza będzie wykorzystywana w praktyce do stworzenia gry.

Zaliczenie składa się z punktacji za rozwiązania list zadań (każda lista to gra lub jej fragment do wykonania), oraz prezentacji finalnego projektu (gry zaprojektowanej i napisanej przez studenta).

Przykłady projektów które mogą pojawić się na pracowni:

* Arkanoid
* Asteroids
* Tetris
* Snake
* Własny finalny projekt mini gry

Pracownia będzie prowadzona jako ""warsztaty - hands on"", na których powtórzymy rzeczy z wykładu, ćwicząc je w praktyce.

Listy zadań w zależności od złożoności będą do zrealizowania od tygodnia do
czterech tygodni (na większości list będzie można wybrać jedną z dwóch gier do
realizacji).

[Gry z poprzednich lat](https://youtu.be/UsdCor8PfCY)"
Seminar: Competitive Artificial Intelligence,3,"Prezentacja, czytanie prac naukowych / dokumentacji zawodów, dyskusja.",,False,False,"Seminarium ma dwa podstawowe cele:

Po pierwsze zaprezentować istniejące zawody w dziedzinie Sztucznej Inteligencji (w grach) - zarówno komercyjne jak i akademickie. Interesują nas zasady zawodów, dostepne języki i protokoły, jak wyglądała gra/gry w poprzednich edycjach oraz analiza zwycięskich botów.

Po drugie rozwinąć wiedzę na temat stosowanych algorytmów, ich efektywnej implementacji oraz synergii z innymi podejściami. Zazwyczaj zwycięskie podejścia są konglomeratem różnych algorytmów, heurystyk i zwyczajnej 'ifologii' - chcielibyśmy usystematyzować sobie wiedzę kiedy jakie podejście rokuje na osiągnięcie dobrych rezultatów.

Przeglądowe listy interesujących nas wydarzeń:
- https://www.gocoder.one/blog/ai-game-competitions-list
- https://ieee-cog.org/2022/#COMPETITIONS
- https://icga.org/?page_id=3468
- NeurIPS competitions

W programie przewidujemy aktywne wspieranie CodinGame Fall Challenge 2022.

Zainteresowani będą mieli okazję włączenia się do badań akademickich, co może stanowić podstawę do pracy magisterskiej lub licencjackiej/inżynierskiej.

Współprowadzącym seminarium będzie dr Marek Szykuła.

W zależności od zainteresowania przedmiotem oraz wniosków po prezentacjach, możliwa będzie kontynuacja w semestrze letnim."
Seminar: probability and algorithms,3,,,False,False,"Zamierzam poprowadzić seminarium o tematyce będącej
rozszerzeniem obecnie prowadzonego seminarium z protokołów
populacyjnych, które są przykładem algorytmów, w których
losowość wprowadzana jest przez losowe interakcje między agentami. 
Seminarium planuję poprowadzić we współpracy z prof.
Leszkiem Gąsieńcem z Uniwersytetu w Liverpoolu. Zajęcia
będą prowadzone zdalnie."
Manipulation and abuses on the financial market,5,"Wykład, ćwiczenia",,False,False,"**Przedmiot prowadzony przez dr hab., prof. UWr  Edytę Rutkowską z Instytutu Nauk Ekonomicznych.**

##### Cele przedmiotu
1. Zapoznanie studenta z różnymi formami i postaciami szeroko rozumianych nadużyć i manipulacji
na rynku finansowym w Polsce.
2. Wyposażenie studenta w wiedzę na temat przestępstw na rynku finansowym.
3. Zapoznanie studenta z różnego rodzaju nadużyciami instytucji finansowych w relacjach umownych
z klientami (z niebezpiecznymi , strukturyzowanymi i skomplikowanymi produktami finansowymi o
dużym ryzyku oraz nieuczciwymi praktykami rynkowymi wprowadzającymi w błąd, praktykami
naruszających zbiorowe interesy konsumentów, missellingiem).
4. Wyposażenie studenta w wiedzę na temat zagrożeń wynikających z zastosowania nowych
technologii oraz umiejętność ich diagnozowania i unikania ich negatywnych skutków.

##### Treści programowe
1. Formy i przejawy szeroko rozumianych nadużyć i manipulacji na rynku finansowym w
Polsce
2. Stosowanie niedozwolonych klauzul umownych w konsumenckich umowach o usługi
finansowe jako zakazana praktyka konsumencka (decyzje Prezesa UOKIK w tych sprawach i
nakładane kary)
3. Praktyki naruszające zbiorowe interesy konsumentów na rynku usług finansowych
(decyzje Prezesa UOKIK w tych sprawach i nakładane kary)
4. Nieuczciwe praktyki rynkowe na rynku usług finansowych. Manipulowanie
informacją o odpłatności za usługi finansowe
5. Czyny nieucziwej konkurencji na rynku finansowym
6. Nadużycia w relacjach umownych instytucji finansowych z konsumentami (problem
niebezpiecznych, hybrydowych, strukturyzowanych produktów finansowych zagrożonych dużym
ryzkiem, polisolokaty, “kredyty frankowe”, rabatowanie kosztów kredytu dla konsumentów)
7. Misselling na rynku usług finansowych
8. Nadużycia związane w przeprowadzaniem transakcji płatniczych (omyłkowy przelew
na złe konto- procedura zwrotu pieniędzy, ataki phishingowe na klientów banku, wykonanie
transakcji nieautoryzowanej, nienależyte wykonanie transakcji
9. Nowe technologie na rynku finansowym i problem cyberbezpieczeństwa. Kradzież
tożsamości i i inne fraudy.
10. Zjawisko prania brudnych pieniędzy i mechanizmy jego przeciwdziałanie
11. Nadużycia na rynku kapitałowym (manipulacje instrumentami finansowymi i insider
tranding), naduzycia na rynku obligacji
12. Prowadzenie działalności na rynku finansowym bez zezwolenia lub wpisu do rejestru.
13. Piramidy finansowe

14. Przestępstwa na rynku finansowym w ujęciu ogólnym wynikające z przepisów
karnych ustaw sektorowych
15. Przeciwdziałanie nadużyciom na rynku finansowym i mechanizmy usuwania ich
skutków (mechanizmy karne, cywilnoprawne, administracyjnoprawne). Mechanizmy rozpatrywania
reklamacji i sporów (dochodzenie indywidualnych roszczeń konsumenckich wyikajacych z nadużyć)
16. Ochrona konsumentów przed nadużyciami na rynku finansowym i rola organów
ochrony."
Seminar on Cryptography and Computer Security,3,"Wykład, prezentacja, dyskusja, samodzielna praca przy komputerze, studium przypadku",,False,False,Celem seminarium jest zgłębienie różnych aspektów kryptografii i okolic oraz jej zastosowanie w bezpieczeństwie komputerowym.
Armies and Wars: Hybrid and Conventional,5,"wykład, dyskusja",,False,False,"**Przedmiot prowadzony przez dra Michała Piekarskiego z Instytutu Studiów Międzynarodowych UWr.**

Celem przedmiotu jest zapoznanie osób studiujących ze zjawiskiem współczesnych konfliktów,
zarówno mających charakter konwencjonalny jak również zjawiska tzw. wojen hybrydowych,
prowadzonych z użyciem innych środków niż siła militarna, oraz związanych z tymi zjawiskami
wyzwań dla współczesnych społeczeństw. 

##### Treści programowe
Pojęcia wojny konwencjonalnej i hybrydowej, agresji konfliktu zbrojnego.
Podstawowe pojęcia: strategia, sztuka operacyjna, taktyka. Omówienie roli i zadań poszczególnych
elementów sił zbrojnych
Ewolucja wojen nowoczesnych i postnowoczesnych – od wojen pomiędzy mocarstwami po wojny
asymetryczne i hybrydowe.
Ewolucja armii – ich organizacji, wyposażenia i relacji ze społeczeństwem na wybranych przykładach
(Polska, USA, Wielka Brytania, Japonia, Niemcy, Izrael).
Dylematy i wyzwania współczesnych wojen w tym:
Technika a wojna
Wojna a informacja i dezinformacja
Wojna a kultura, w tym kultura strategiczna"
Introduction to philosophical logic,3,Wykład,,False,False,"**Przedmiot prowaqdzony przez dra hab. Marka Magdziaka z Katedra Logiki i Metodologii Nauk, Wydział Nauk Społecznych.**

Przedstawienie podstawowych pojęć i wybranych problemów logicznych, uwzględniając
filozoficzne podstawy logiki, z naciskiem na ich zastosowanie w ontologii, etyce i
metodologii ogólnej. Nabycie przez słuchaczy umiejętności formułowania i oceny
argumentacji filozoficznej oraz budowania poprawnych i trafnych definicji. Wykształcenie
umiejętności konceptualizacji problemów oraz odróżniania problemów rzetelnych od
pseudo-problemów i sporów przedmiotowych od sporów słownych."
Soft Power and Its Tools in International,3,wykład,,False,False,"**Przedmiot prowadzony przez prof. dr hab. Beatę Ociepkę z Instytutu Studiów Międzynarodowych UWr.**

Pozyskanie wiedzy z zakresu stosunków międzynarodowych, w tym na temat roli i znaczenia
miękkiej siły jako zasobu państwa i sposobu zachowania w stosunkach międzynarodowych.
Pogłębienie wiedzy dotyczącej relacji pomiędzy wymiarem wewnętrznym i zewnętrznym polityki
zagranicznej poprzez poznanie analizy polityki zagranicznej. Wskazanie na wpływ strategii
rządowych i działań NGO na pozycję międzynarodową państwa. Wypracowanie umiejętności
tworzenia podstaw strategii zastosowania narzędzi miękkiej siły na różnych poziomach relacji
międzynarodowych. Wskazanie na udział i znaczenie aktorów niepaństwowych i obywateli w
stosunkach międzynarodowych i na zagrożenia, wynikające z procesów de-demokratyzacji i
kurczenia się sfery publicznej, dla tego udziału.
##### Treści programowe
Studenci poznają znaczenie miękkiej siły i jej narzędzi jak dyplomacja publiczna i kulturalna oraz
kształtowanie marki państw (branding państw) w polityce zagranicznej. Uzyskają zarówno wiedzę
teoretyczną, jak i praktyczną o przygotowaniu kampanii, wykorzystujących zasoby miękkiej siły
państwa.�
1. Koncepcja miękkiej siły w teorii stosunków międzynarodowych. Ujęcie J.S Nye: miękka,
twarda i sprytna siła jako ramy dla studiów nad dyplomacją publiczną i brandingiem
państw. Sila i dyskurs: dyskurs jako siła w stosunkach międzynarodowych.
2. Sila normatywna Mannersa: „normalność” w stosunkach międzynarodowych. Siła
społeczna według van Hama. Europejska odpowiedź na amerykańską koncepcję
miękkiej siły. Miękkie elementy siły ekonomicznej.
3. Siła komunikacji w stosunkach międzynarodowych. Rola mediów jako aktorów
stosunków międzynarodowych i gatekeeperów w komunikacji międzynarodowej:
Facebook/Meta jako globalny gatekeeper.
4. Dyplomacja publiczna jako narzędzie miękkiej siły w polityce zagranicznej.
5. Kultura jako zasób miękkiej siły: dyplomacja kulturalna i dyplomacja publiczna.
6. Dyplomacja publiczna jako forma międzynarodowej komunikacji politycznej.
Dyplomacja publiczna 2.0 i Twiplomacja.
7. Ekonomizacja polityki zagranicznej: zagraniczna polityka wizerunkowa, branding
państw i międzynarodowe public relations.
8. Wpływ narzędzi miękkiej siły na opinię publiczną za granicą: jak to działa? Narracje i
dyskursy. Nadawanie za granicę.
9. Miękka siła państw małych i średnich. Przypadek wykorzystania brandingu dla
bezpieczeństwa państwa: Litwa, Łotwa i Estonia.
10. Polska: studium przypadku.
11. Miękka siła superpotęgi: Stany Zjednoczone.
12. Wykorzystanie miękkiej siły i jej narzędzi przez państwa autorytarne: Chiny. Przypadek
Rosji w kontekście agresji na Ukrainę.
13. Państwo jako marka (brand): indeksy miękkiej siły, marek państw i ich postrzegania.
14. Kampanie i strategie narzędzi miękkiej siły na poziomie centralnym, regionalnym i
lokalnym."
Project: Martian Rover Analog Construction and Development,4,indywidualny/zespołowy projekt programistyczny,,False,False,"Celem projektu jest skonstruowanie i oprogramowanie analogu łazika
marsjańskiego, który będzie brał udział w zawodach University Rover Challenge (URC), European Rover Challenge (ERC) i innych. Zadania do zrealizowania w ramach projektu
obejmują:

- Oprogramowanie sterowników silników oraz modułów pomocniczych,
- Algorytmy planowania trasy i rozpoznawania przeszkód,
- Algorytmy sterowania manipulatorem,
- Zarządzanie kamerami i transmisją obrazu,
- Konfiguracja łączności bezprzewodowej,
- Projekt mechaniczny komponentów łazika, dostosowanych do zadań wymaganych w konkretnych zawodach (np. moduły pobierania, przechowywania i badania próbek, efektor przeznaczony do pisania na klawiaturze).

Do programowania łazika wykorzystywany jest system ROS (Robot Operating System, http://www.ros.org/). Wbrew nazwie, ROS nie jest systemem operacyjnym, a raczej frameworkiem, zbiorem narzędzi i modułów przeznaczonych do programowania rozproszonego systemu sterowania robotami. Wcześniejsza znajomość ROS nie jest wymagana.

Zajęcia mają charakter zamknięty - udział w projekcie mogą brać tylko
członkowie koła Continuum. Osoby nie będące członkami koła, chcące wziąć udział w projekcie, powinny skontaktować się z wykładowcą oraz zarządem koła.

#### Wymagania

- Znajomość języka C, C++ lub Python,
- Umiejętność pracy w systemie Linux przy użyciu linii poleceń,
- Znajomość systemu kontroli wersji Git.

#### Literatura

* Jason M. O'Kane, A Gentle Introduction to ROS.
* Morgan Quigley, Brian Gerkey and William D. Smart, Programming Robots with ROS, O'Reilly."
Introduction to Programming in C,5,wykład – wykład interaktywny - samodzielna praca przy komputerze - indywidualne programowanie – indywidualny projekt programistyczny,,False,True,"**Wstęp, czyli jak się ma ""Wstęp do programowania w języku C"" do ""Wstępu do programowania w języku Python""**

Studenci 1-go roku studiów 1-go stopnia mogą rozpocząć naukę programowania i podstaw informatyki w jednym z dwóch języków: **C albo Python** (można wybrać tylko jeden z tych dwóch kursów!). Każdy z tych kursów pozwala opanować podstawy informatyki i programowania a w dalszych semestrach doskonalić się w programowaniu w innych (lub tych samych) językach. W szczególności zaczynając od ""Kursu: Wstęp do programowania w języku C"", nie skazujecie się na zawsze na ten język (i nieznajomość Pythona) oraz _vice versa_. W drugim semestrze studiów (i kolejnych) pojawiają się kursy języków programowania (C++, Java, Ruby, Python), które pozwalają opanować różne języki, przy założeniu, że studenci mają ogólne pojęcie o programowaniu, które zdobywają na obu przedmiotach ""Kurs: Wstęp do programowania w języku C/Python"".

**O samym kursie ""Wstęp do programowania w języku C""**  
  

Celem tego kursu jest nauczenie i rozwinięcie podstawowych umiejętności programowania w jednym z najbardziej rozpowszechnionych języków imperatywnych - języku C. Wykład jest ilustrowany wieloma przykładami, a towarzyszące mu zajęcia w pracowniach uczą (poprzez wiele drobnych zadań i końcowy projekt)
praktyki dobrego programowania. Nie wymaga on od uczestników żadnych wcześniejszych umiejętności programowania, ale studenci startujący od zera będą musieli poświęcić mu więcej pracy w domu, aby szybko wyrównać poziom. Elementy języka są wprowadzane stopniowo, zaczynając od konstrukcji podstawowych, a kończąc na bardziej zaawansowanych zagadnieniach, jak wskaźniki i dynamiczne struktury danych, operacje na plikach czy funkcje rekurencyjne. Ostatnie wykłady poświęcone są obiektowym elementom języka C++.  
Pochód języków programowania trwa od zarania informatyki. Studium języków C i C++ ułatwia start w naturalną ich kontynuację, do której obecnie zaliczają się ważne z komercyjnego punktu widzenia języki i środowiska: Java (Sun) oraz C# (.NET Microsoft).

**Wymagane przygotowanie:** Brak, chociaż przydatna będzie podstawowa umiejętność programowania.  

W przypadku prowadzenia zajęć w formie zdalnej, wykłady będą w formie wideokonferencji, a na pracowni studenci będą indywidualnie programować rozwiązania zadań z list. Zgłaszanie rozwiązań oraz punktowe i słowne oceny programów będą realizowane w systemie SKOS.
  
**Program:**

  * Podstawowe konstrukcje języka: instrukcje i deklaracje.
  * Standardowe typy danych, wyrażenia.
  * Standardowe wejście/wyjście, filtry.
  * Funkcje, moduły i struktura programu.
  * Metody agregacji danych: tablice, struktury i unie.
  * Wskaźniki.
  * Dynamiczne zarządzanie pamięcią, standardowe biblioteki C.
  * Sekwencyjne i swobodne przetwarzanie plików.
  * Programowanie okienkowego interfejsu w GTK+.
  * Klasy, obiekty i strumienie w C++.

**Literatura:**

* Kernighan B.W., Ritchie D.M.: Język ANSI C. Seria ""Klasyka Informatyki"". Warszawa, Wydawnictwa Naukowo-Techniczne 2003. Podręcznik podstawowy.
* King K.N.: Język C, Nowoczesne programowanie, Wydanie II, Helion 2011 (uwzględnia standard C99).
* Banahan M., Brady D., Doran M., The C Book, http://publications.gbdirect.co.uk/c_book/ (dostępny za darmo jako pdf i na WWW).
* Schildt B., C: The Complete Reference: covers C++ and ANSI C, Osborne McGraw-Hill, 
* ISO/IEC 2011 - Programming languages - C (aktualny standard ISO 2011), http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1570.pdf (wstępna wersja opisu standardu)."
Advanced techniques in C++ and STL,5,"Wykład, analiza przykładowych programów, samodzielna praca programistyczna w domu oraz na zajęciach.",,False,False,"**C++** to obiektowy język programowania z długą i bogatą historią.
Stworzony przez Bjarne Stroustrupa w roku 1983, doczekał się pierwszego standardu ISO/IEC 14882:1998 w 1998 roku, znanego jako C++98.
Następnie kilkukrotnie standard ten był aktualizowany: C++03, C++11  oraz C++14.
Ostatnia, najnowsza wersja standardu ISO/IEC 14882:2017, nazwana **C++17**, opublikowana została w grudniu 2017 roku.
Obecnie trwają prace nad kolejną wersją standardu, na razie roboczo nazywanego C++2a.

Język C++ jest jednym z najpopularniejszych obecnie języków programowania, przeznaczonych do tworzenia programów o charakterze systemowym, inżynierskim oraz do pisania gier komputerowych. 
Umożliwia pisanie przenośnych aplikacji zarówno pod Windowsa, Linuxa oraz inne systemy operacyjne.
Język ten oferuje potężne możliwości - pozwala ukrywać skomplikowane rozwiązania pod prostymi interfejsami wysokiego poziomu i jednocześnie tworzyć kod działający na niskim poziomie, gdy wymagane są wysoka wydajność i niskie obciążenie.

Biblioteka standardowa języka C++ jest jego częścią i należy do standardu.
Uzupełnia sam język logicznymi strukturami, czyniąc go łatwiejszym w używaniu.
**STL**, czyli standardowa biblioteka szablonów, jest trzonem biblioteki standardowej.
Powinna być pierwszą rzeczą jakiej trzeba się nauczyć zaraz po opanowaniu języka C++. 

Kurs zaawansowanych technik w C++ i STL ma zapoznać studentów z najnowszymi elementami samego języka programowania jak również z całą biblioteką standardową."
Advanced Python Programming,5,"* wykład
* live coding
* indywidualna implementacja zadań
* projekt programistyczny",,False,False,"Python jest eleganckim obiektowo-zorientowanym językiem skryptowym,
wykorzystywanym zarówno do tworzenia serwisów interentowych jak i do tworzenia
narzędzi do administrowania systemami operacyjnymi (Linux Redhat). Składnia
Pythona jest dość oryginalna: zakres pętli czy instrukcji warunkowej jest
wyznaczony za pomocą wcięć, jednak dzięki temu programy są przejrzyste i
czytelne. Silną stroną Pythona są listy będące częścią języka, dzięki czemu
operacje na listach mają zwartą notację. Programujący w Pythonie mają do
swojej dyspozycji obszerną i rozwijaną bibliotekę standardową, dzięki czemu
można np. napisać klienta prostej sieci P2P w siedemnastowierszowym programie."
Databases 2,6,"wykład
projekt",,False,False,"Wykład będzie poświęcony implementacji systemów zarządzania bazami danych. W ramach pracowni - projekt w C++, we współpracy z teamem Oracle MySQL (https://blogs.oracle.com/mysql/).

Peter Bailis, Joseph M. Hellerstein, Michael Stonebraker  Readings in Database Systems, 5th Edition, http://www.redbook.io/

Raghu Ramakrishnan and Johannes Gehrke, _Database Management Systems_. (Third Edition) McGraw-Hill.

**Program:**

  * Implementacja SZBD.
    * Przechowywanie danych,
    * Indeksy,
    * Sortowanie zewnętrzne,
    * Ewaluacja zapytań,
    * Optymalizacja zapytań,
    * Transakcje.

**Wymagania:** Bazy danych, Algorytmy i Struktury Danych, umiejętność programowania w C++."
Modeling financial derivatives using the F# functional language,2,"Wykład, pracownia",,False,False,"**Przedmiot prowadzony przez pracowników **

Czy zastanawiałaś\zastanawiałes się jak wygląda praca analityka
lub programisty w dziale modelowania instrumentów
finansowych? Co to jest i czym się zajmuje bank inwestycyjny
albo co to jest Fintech? Jeśli chcesz nabyć praktycznych
umiejętności w tej dziedzinie, porządanych na całym świecie,
to podejmij wyzwanie i zapisz się na wykład prowadzony przez
zespół doświadczonych programistów i “quantów”
międzynarodowego banku inwestycyjnego Credit Suisse.
Dowiesz się czym są i do czego służą instrumenty pochodne,
jak banki je wyceniają, oraz jak praktycznie zaimplementować ich
wycenę w języku funkcyjnym F#.
Te umiejętności są bardzo cenione w wielu instytucjach
finansowych, w szczególności w Credit Suisse, który od wielu
lat rozwija dział Quant Analysis and Technology we Wrocławiu
i Warszawie, oraz aktywnie poszukuje pracowników.
Credit Suisse co roku ogłasza nabór do różnego rodzaju
programów dla studentów studiów technicznych i nie tylko,
w których nabyta tu wiedza może być dużą pomocą podczas
rekrutacji."
Calculus,10,"Wykład, rozwiązywanie zadań z komentowaniem, dyskusja",,False,True,"**Program:**

  1. Liczby rzeczywiste i zespolone (4 godz.) : kresy, aksjomat ciągłości, liczby zespolone jako punkty płaszczyzny, postać biegunowa.
  2. Ciągi i szeregi liczbowe rzeczywiste i zespolone (10 godz.): ciągi zbieżne, warunek Cauchy'ego zbieżności, ciągi rekurencyjne (przykłady), twierdzenie Bolzano-Weierstrassa, kryteria zbieżności szeregow, szeregi potęgowe.
  3. Funkcje jednej zmiennej (12 godz.): granica funkcji w punkcie, granice jednostronne, ciągłość funkcji (definicja Cauchy'ego i Heinego), własności funkcji ciągłej na odcinku domkniętym, własność Darboux.
  4. Pochodna funkcji (12 godz.): interpretacja geometryczna pochodnej, pochodna funkcji złożonej i odwrotnej, twierdzenie o wartości średniej, pochodne wyższych rzędow, wzor Taylora, ekstrema i badanie przebiegu funkcji, wzór Stirlinga.
  5. Całkowanie (12 godz.): funkcja pierwotna, całka oznaczona (interpretacja geometryczna funkcji pierwotnej), całka Riemanna,
zastosowania całek, podstawowe algorytmy numeryczne 
  6. Ciągi i szeregi funkcyjne (10 godz.): zbieżność jednostajna (norma jednostajna), szeregi potęgowe, szereg Taylora, funkcje analityczne (wielomiany, funkcja wykładnicza itp.).

**Wymagania:** matematyka w zakresie szkoły średniej"
Clone: Seminar on Systems,3,,,False,False,"Rozejrzyj się wokół siebie okiem informatyka. Stajemy się stopniowo „włączkami” do Systemu. Niektórzy (niektórzy?, zob. jeden z proponowanych tematów) już się stali. I nie są tylko to moje przewidywania i straszenie sprzed lat. To zjawisko potwierdzają obecnie inni, fachowi obserwatorzy. Z drugiej strony spróbujmy (dziś) żyć bez systemów!.... Te dwa spostrzeżenia wyznaczają ramy referatów, które studenci mogą przygotowywać na seminarium z systemów — ramy praktycznie bez granic. Liczy się sposób prezentacji, własny wkład studenta w temat, twórcze spojrzenie na wybrany system i zdolność
wnioskowania o skutkach jego rozwoju lub zaniechania.

Praktyka minionych edycji seminarium z systemów wskazuje, że studenci wolą wybierać tematy dotyczące systemów w bardzo szeroko rozumianym zakresie. Oto kilka przykładów tematów z ostatnich lat:

„Systemy zarządzania prawami autorskimi” [MZI], „Systemy dystrybucji gier” [MBR], „Przez Big Data do Wielkiego Brata” [FCH], „E-wybory” [BWL], „KLM58C, wind 280 degrees” [KWR], „LEGO – jeden patent, aby wszystkie klocki połączyć” [MWO], „Międzynarodowa Stacja Kosmiczna” [MRO], „Fundusze inwestycyjne” [MZA], „System pisma w Korei” [MKO], „Przegląd mechanizmów manipulacji i wykorzystywania w grupach religijnych” [LKL].

Powracając do systemów osadzonych bardziej bezpośrednio w informatyce, referaty studentów mogą w szczególności dotyczyć ośmiu „przestrzeni
informatycznych” odpowiadających ośmiu książkom ostatnio przetłumaczonym przez proponującego to seminarium. Ujmując swobodnie:

Algorytmy na sposób inżynierski

Git, czyli jeszcze jeden system rozproszony

Wielkie dane — z czym to się je

Co ma algebra abstrakcyjna do biblioteki STL C++

Jak działa oprogramowanie: czy na pewno wiemy? A jeśli nawet, to jak to
wyjaśnić profanom?

Internet rzeczy — konsekwencja i konieczność rozwoju czy techniczno-ekonomiczna fanaberia?

Bezpieczeństwo systemów informatycznych, czyli jak żyć, dopóki wystarcza prądu

Systemy operacyjne — kopalnia tematów bez dna, w szczególności: hiperwizory i maszyny wirtualne; pożyteczne czy informatyczny zawrót głowy?

A poza informatyką, choć bezsprzecznie informatycy mają tu sporo (lub coś) do powiedzenia, na przykład takie propozycje:

Czy sztuczna inteligencja nas „zje”? Jeśli tak, to gdzie będzie się szukać winnych? Jeśli nie, to dlaczego i komu wypadnie dziękować?

Słowa jednoznaczne, słowa o wielu znaczeniach, słowa cenne, słowa śmiecie, słowa pozostające dźwiękami bez realnych przypisań. Co to jest nauka? Co to jest metodologia nauk? Gdzie są rozgraniczenia między nauką a ... 

Dukaizmy, niebinarne zaimki a precyzja i czytelność języka; lingwistyczna odpowiedź na zmiany czy pokoleniowa efemeryda? 

Czy stoicyzm, jako system filozoficzny, „przepis” egzystencjalny, jest dobry na nasze czasy? Tak? Nie?

**Wymagania:** otwarta głowa, ciekawość świata. A dokładniej: szerokie horyzonty myślowe, nieograniczanie się w projekcji zastosowań informatyki do tych najpopularniejszych. Myślenie kategoriami globalnymi: jakie zmiany powoduje burzliwy wzrost zastosowań komputerów i sieci? Czego można się spodziewać za 5 lub 10 lat w związku z tym? Jak Sieć i informatyka oddziałuje na cywilizację? Czy ludzie stają się dzięki zastosowaniom komputerów mądrzejsi? Lepsi? Czy...

Osoby stawiające sobie takie i podobne pytania dobrze kandydują do udziału w „Seminarium z systemów” (S2).

**Cele.** Wzbudzanie refleksji dotyczących wpływu postępu technologicznego, a informatyzacji w szczególności, na ludzkość, losy cywilizacji i świata. W dobie samochodów-sieci i samochodów w Sieci, Internetu rzeczy, silosów informacji gromadzonej wszędzie, oprogramowania, nad którego działaniem informatycy zastanawiają się niczym neurolodzy nad tajnikami mózgu — o wszystkim i o wszystkich warto dyskutować na temat ewentualnych konsekwencji, pozytywów i negatywów rozwoju (a może o potrzebie pewnej stagnacji?). Seminarium nie ma
kształtować postaw ani sądów zdecydowanych i ostatecznych. Ma pobudzić do myślenia o nas, o ludziach i ich krzemowym dziele. Jeśli przy okazji referenci wydobędą z Sieci oryginalne, nowe zastosowania informatyki — tym lepiej.
Technologia zmienia się szybko, człowiek znacznie wolniej. Co z tego wynika? Co wyniknie?

**Możliwa literatura.** Książki tłumaczone przez proponującego seminarium (por. strona w Wikipedii), nowiny i nowości informatyczne odnajdywane w Sieci,
zarówno stricte techniczne i użytkowe, jak i o charakterze oddziaływania społecznego i (lub) kulturowego.

**Forma zaliczenia.** Dobrze przygotowany, dobrze wygłoszony i dobrze udokumentowany, pobudzający do dyskusji referat plus aktywne uczestnictwo w
odbiorze i ocenie innych referatów rokuje dobre zaliczenie.

W trakcie semestru studenci mają wgląd w materiały do wykładów wygłoszonych na S2 w poprzednich latach, udostępniane na odpowiedniej stronie witryny SKOS.

**Uwaga dotycząca sposobu prowadzenia zajęć.** Praktycznie w każdym przypadku zdalne prowadzenie zajęć stępia i ogranicza proces dydaktyczny, usztywnia dyskusję, niemniej doświadczenie z poprowadzenia tych zajęć w semestrze letnim roku akademickiego 2019-2020  w trybie zdalnym (z konieczności) dowodzi, że mimo tych strat można je poprowadzić zdalnie. Oczywiście to nie to samo, co bezpośrednia wymiana myśli z młodzieżą akademicką w salach Instytutu. Zakładam optymistycznie, że: a) będziemy jeszcze trochę istnieć i b) wirus (przyroda) na jakiś jeszcze czas odpuści

20-05-04, 20-05-25, 20-06-08, 20-06-21, 22-04-24, 22-06-29 zpl..IIUWr"
Ideas of Post-Humanism: the Artificial Intelligence Project and the Problem of Possible Minds,5,"wykład, dyskusja, praca semestralna",,False,False,"**Przedmiot prowadzony przez dra Piotra Łukomskiego z  Instytutu Politologii, Wydziału Nauk Społecznych.**

1. Metafora komputera w badaniach nad umysłem i świadomością oraz jej konsekwencje dla
rozumienia kultury i człowieka.
2. Post-humanizm czy humanizm rozszerzony – komu lub czemu możemy przypisać cechę
umysłu.
3. Kultura jako rzeczywistość wirtualna: problem znaczenia, sensu i komunikacji w teorii
informacji.
4. Humanistyka jako artefakt kultury w świecie technologii informacyjnych.
5. Mózg Boltzmanna i inne eksperymenty myślowe czyli rzeczywistość z punktu widzenia
możliwego umysłu.
6. Umysł świadomy czyli jaki? Stopniowalność świadomości i idea panpsychizmu.
7. Czym jest świadomość – symulatorem czy symulacją: pomieszanie porządków logicznych i
przyczynowo – skutkowych.
8. Zakres pojęcia świadomości: perspektywa pierwszo-osobowa i perspektywa trzecio-osobowa.
Świat prywatnych fenomenów a rzeczywistość obiektywna i społeczna.
9. Świadomość refleksyjna i jej rola w procesach przetwarzania informacji o świecie. Problem
podmiotu w naukach kognitywnych.

10. Idea odwróconej inżynierii: jeśli potrafimy skonstruować świadomy umysł to wiemy, czym on
jest.
11. Świadomość i tożsamość: czy jesteśmy tym, kim myślimy, że jesteśmy?
12. Wielorakość tożsamości graczy i aktorów: świat społeczny jako symulacja ról.
13. Idea persony w klasycznej humanistyce i jako rola do odegrania.
14. Umysł i świadomość poza ludzkim mózgiem: problem A.I. i G.A.I. Systemy przetwarzania
informacji i problem kontroli nad zachowaniami społecznymi. Dystopia końca ludzkości."
Seminar: Finite and Algorithmic Model Theory,6,wykład – wykład interaktywny – prezentacja - dyskusja – analiza tekstu - rozwiązywanie zadań z komentowaniem,,False,False,"Seminarium skupia się na bardziej zaawansowanych tematach skończonej i algorytmicznej teorii modeli. Skierowane jest do słuchaczy przedmiotów ,,Wybrane tematy teorii modeli skończonych i złożoności opisowej'' oraz ,,Problemy decyzyjne w logice'', ale mogą w nim też wziąć osoby zainteresowane logiką, które we własnym zakresie nadrobią podstawowe pojęcia (gry Erenfauhta Fraisego, (nie)rozstrzygalność logiki pierwszego rzędu).


**Termin i tryb seminarium:**

Termin seminarium zostanie ustalony podczas pierwszego  spotkania. Seminarium będzie prowadzone online.
Seminarium będzie prowadzone przez Bartosza Bednarczyka oraz Piotra Ostropolskiego-Nalewaję."
Seminar: Fine-grained complexity,3,"Wykład, rozwiązywanie zadań z komentowaniem, indywidualne/grupowe rozwiązywanie zadań/problemów, indywidualny/zespołowy projekt programistyczny",,False,False,"Złożoność drobnoziarnista (fine-grained complexity) jest aktualnie jednym z najbardziej dynamicznie rozwijających się kierunków algorytmiki. Prace poświęcone tej tematyce regularnie pojawiają się na topowych konferencjach typu STOC/FOCS/SODA/ICALP, a poświęcone jej wykłady są prowadzone na najlepszych uczelniach zarówno w Europie (ETH, Saarbruecken), jak i w USA (MIT, Stanford, Harvard). Celem tych zajęć będzie wprowadzenie i przedstawienie najciekawszych (w naszej ocenie) wyników w tej dziedzinie.

Celem fine-grained complexity jest klasyfikacja problemów rozwiązywalnych w czasie wielomianowym. Przykładowo, w problemie APSP chcemy znaleźć odległość między każdą parą wierzchołków w danym ważonym grafie skierowanym. Nie jest trudno rozwiązać ten problem w czasie O(n^3), co być może zaskakujące nie znamy istotnie szybszego algorytmu. Ale jednocześnie nie potrafimy udowodnić, że takiego nie ma! Naturalne jest więc rozważanie całej klasy problemów, które są równoważne APSP (w odpowiednio zdefiniowanym sensie): rozwiązanie dowolnego z nich w czasie O(n^{3-eps}) sprawi, że uzyskamy istotnie szybsze rozwiązanie dla wszystkich innych.

Seminarium będzie złożone z dwóch części. Podczas pierwszej z nich (prowadzonej online) zapoznamy się z podstawowymi technikami używanymi w tej dziedzinie, na podstawie materiałów z wykładów prowadzonych na innych uczelniach, a później (już w formie stacjonarnej) zajmiemy się czytaniem i omawianiem aktualnych prac.

Wśród technik omawianych na pierwszej części znajdzie się sporo takich, które powinny być przystępne już dla studentów, którzy zaliczyli zajęcia z Matematyki Dyskretnej (a z całą pewnością dla tych, którzy zaliczyli Algorytmy i Struktury Danych). W pracach przedstawianych na drugiej części pojawią się pomysły nieco trudniejsze, których zrozumienie może być dobrym wstępem do ambitnej pracy magisterskiej."
Project: Machine Learning for Recommender Systems,4,zespołowy projekt programistyczny z elementami studiów literatury i prac badawczych,,False,False,"Celem projektu jest opracowanie/wykorzystanie/rozszerzenie algorytmów uczenia maszynowego dla systemów rekomendujących i wykorzystanie ich do konstrukcji prototypu systemu rekomendującego dla wybranego problemu/zbioru danych.

Poza podstawowymi algorytmami _Collaborative Filtering_ i _Matrix Factorization_, chciałbym skupić się na nowych podejściach m.in. _Factorization Machines_, _Neural Collaborative Filtering_, _Neural Graph Collaborative Filtering_ i ich rozszerzeniach, a także rozważyć takie aspekty jak: zmienność charakterystyki danych/użytkowników/produktów/interakcji w czasie, różne modele implicite i explicite ratings, różne modele wektorowych zanurzeń produktów, zgodność wektorowych zanurzeń produktów z ich kategoryzacją i product feedem.

Prototyp systemu będzie uczony i testowany na wybranym zbiorze danych, takim jak _Movie-Lens_, _Yelp_, _Amazon-Books_ lub innym dostępnym publicznie (m.in. na Kaggle).

**UWAGA:** Projekt jest przeznaczony dla osób posiadających wiedzę z eksploracji danych i uczenia maszynowego (w zakresie potrzebnym do realizacji projektu) oraz umiejętności techniczne w tym zakresie. Część prac może być wykonywana przez osoby z mniejszym doświadczeniem, ale zalecałbym kontakt emailem i ustalenie tego przed zapisaniem się."
Course: Technical writing (Q2),3,"Wykład, analiza tekstu, ćwiczenia warsztatowe, krótka praca zaliczeniowa",,False,False,"Ten przedmiot:
- będzie prowadzony **w drugiej połowie semestru** letniego,
- jest przeznaczony dla osób odbywających studia **zarówno I, jak i II stopnia** – w związku z tym musi być zaklasyfikowany jako kurs „zaawansowany”, ale w tym przypadku jest to kwestia terminologii, która nie powinna nikogo odstraszać.

---

Pisanie tekstów technicznych (w tym prac dyplomowych czy zaliczeniowych, ale też jakichkolwiek opracowań, które powinny cechować się precyzją i uporządkowaniem wypowiedzi) to umiejętność tyleż cenna, co trudna do pozyskania w zorganizowany sposób. W ofercie mało jest przedmiotów poświęconych bezpośrednio tej umiejętności, a w trakcie studiów informatycznych nabywa się ją (bądź nie) niejako przy okazji. Ten kurs powinien przynajmniej częściowo zapełnić tę lukę.

Zasadnicza część kursu będzie poświęcona organizacji, podziałowi i składowi tekstu – zarówno ich ogólnym zasadom, jak i realizacją tych zasad w systemie składu LaTeX. Nie jest to jednak kurs LaTeXa _per se_ – o ile na pewno będzie pomocny w rozwoju umiejętności oraz dobrych praktyk w tym systemie, ważniejsze będzie omówienie zasad, które będzie można stosować w dowolnych systemach składu, także tych popularnych z kategorii WYSIWYG.

Kurs będzie ponadto obejmował wiedzę językową – pewnie siłą rzeczy dość fragmentaryczną – przydatną w pisaniu tekstów technicznych. Jeśli starczy czasu, sił i ochoty, pojawi się też analogiczna tematyka dla języka angielskiego, przy czym oczywiście do odbycia kursu wystarczy tylko podstawowa jego znajomość.

#### Wymagania wstępne

##### Zrealizowane przedmioty
* _Logika dla informatyków_, _matematyka dyskretna_ **lub** inny przedmiot, w ramach którego należało tworzyć i spisywać rozumowania matematyczne

##### Niezbędne kompetencje
* Podstawowa znajomość systemu składu tekstu LaTeX, np. pozyskana w ramach przedmiotu _podstawowy warsztat informatyka_
* Znajomość języka polskiego na poziomie absolwenta szkoły średniej"
FreeBSD Device Drivers,5,"* Wykład.
* Ćwiczenia: czytanie kodu jądra _FreeBSD_, analiza zachowania jądra przy użyciu _DTrace_, konsultacje do pracowni w zakresie projektowania.
* Pracownia: implementacja sterowników, szukanie błędów, rozszerzanie `gdb`.",,False,False,"Celem kursu jest przygotowanie studentów do pracy z jądrem _FreeBSD_, a w szczególności do implementacji sterowników. Po drodze nauczymy się również korzystać z _DTrace_ i zajrzymy do tematów, które zostały pominięte na przedmiocie _Struktura Jądra UNIX_. 

Zajęcia będą prowadzone raczej luźnym tempem. W pierwszej edycji wykład będzie niedopracowany, a prowadzący będzie się uczył niektórych rzeczy wraz ze studentami. Na pracowni będziemy pisać sterowniki urządzeń. Na ćwiczeniach będziemy czytać kod i uruchamiać skrypty DTrace.

**UWAGA!** Prowadzący zakłada dobre przygotowanie teoretyczne z zakresu organizacji jąder systemów operacyjnych.

##### Tematy wykładów

* Instalacja i praca z systemem FreeBSD.
* Kompilacja jądra i sterowników.
* DTrace i śledzenie jądra.
* Debugowanie w przestrzeni jądra.
* Omówienie systemu budowania i `BSD Make`.
* Struktura modułu jądra.
* Interfejs plikowy urządzeń `cdevsw`
* Wykrywanie urządzeń i kojarzenie ich ze sterownikami `driver` i `devclass`.
* Zarządzanie zasobami sprzętowymi: pamięć, porty, kanały DMA i przerwania.
* Sterownik magistrali (na przykładzie `PCI`).
* Zmienne jądra `sysctl`.
* Reakcja na zdarzenia jądra `eventhandler`.
* Kolejki zadań odroczonych `taskqueue`.
* Sterowniki urządzeń przechowujących dane.
* Common Access Method.
* Sterowniki urządzeń USB.
* Omówienie stosu sieciowego.
* Sterowniki urządzeń sieciowych."
Modern web development,5,"Wykład, pracownia, implementacja projektu w grupach",,False,False,"*Przedmiot będzie prowadzony przez pracowników firmy FINGO.*

Na wykładach opowiemy jak budować aplikacje webowe przy użyciu popularnych bibliotek i framework-ów: ReactJS, TypeScript, Spring Boot, Java.

**Organizacja pracowni:** Pracowania będzie podzielona na 2 etapy. Pierwszy, trwający ok. 4 tygodni będzie polegał na samodzielnym implementowaniu zadań powiązanych z wykładami. Następnie przez ok. 10 tygodni studenci będą w grupach 3-4 osobowych implementować prostą aplikację webową. Praca będzie podzielona na dwutygodniowe sprinty, a pracownia będzie miała formę demo, na którym każdy zespół będzie prezentował postęp prac.

**Wymagania:** Zalecamy wcześniejsze zaliczenie *Kursu WWW* oraz *Kursu języka Java*. Od uczestników kursu wymagać będziemy znajomości Javy, JavaScriptu oraz podstaw CSS. Mile będzie widziana także znajomość TypeScriptu.

**Program przedmiotu:**

1. Git 
2. Agile
3. Wprowadzenie do Reacta
    1. Podstawowe koncepcje (TS/JS, TSX/JSX, komponenty klasowe/funkcyjne)
    1. Ustawienie środowiska (wymagania, setup)
    1. Pierwsza apka (Create React App)
    1. Narzędzia developerskie (react developer tools)
1. Bardziej zaawansowane koncepcje React
    1. Komunikacja pomiędzy komponentami (używanie props, children)
    1. Zarządzanie stylem (css, scss)
    1. Podstawy hoooków, hook efektów
    1. Poprawianie wydajności (useCallback, useMemo)
1. Zarządzanie stanem:
    1. Wbudowane rozwiązania (hooki stanu, context api)
    1. Zewnętrzne rozwiązania (redux + redux toolkit, recoil)
1. Routing
1. Korzystanie z pomocniczych bibliotek
    1. Biblioteki komponentów (material, bootstrap, antdesign)
    1. Obsługa formularzy (form hooks)
    1. Obsługa tłumaczeń (i18next)
1. Obsługa API:
    1. Łączenie się z backendem (axios, react-query)
    1. Tworzenie abstrakcji API
    1. Tworzenie mocków API
1. Testowanie aplikacji frontendowej
1. Ekosystem Javy
    1. JDK/JRE
    1. Narzędzia do automatyzacji budowania
1. Wprowadzenie do Spring-a, 
    1. Spring, Spring Boot, Spring Data, Spring Security
    1. Dependency Injection
    1. Servlet API
    1. Spring MVC
1. Architektura trójwarstwowa aplikacji
    1. Dostęp do danych
    2. Warstwa serwisowa
    3. REST API
1. Komunikacja z front-endem
1. Testowanie
    1. Testy jednostkowe
    1. Testy integracyjne
    1. Testy API
1. Zabezpieczanie aplikacji"
Seminar: Advances in Computer Systems,3,"wykład, prezentacja",,False,False,"Computer architecture is the science and art of selecting and interconnecting hardware components to create a computer that meets functional, performance and cost goals. We will learn advanced concepts of the different parts of modern computing system that are subject of the recent research in Industry and Academia. We will cover: memory technologies, processing in memory, memory scheduling, caches, branch prediction, speculative execution, parallel computing systems, heterogeneous computing, interconnection networks, etc.

The goal of this seminar is to explore space of computer architecture research. We want to go broad, not deep. Each talk should highlight the most important aspects of given publication - we don't want to dive into details. We need to cover some of the tools listed on [GitHub](https://github.com/CMU-SAFARI) that SAFARI group uses for research.

Before you give first talk you should familiarize with the following:
 * [The Task of the Referee](https://www.cs.utexas.edu/users/mckinley/notes/reviewing-smith.pdf), Smith, IEEE Computer 1990
 * [Notes on Constructive and Positive Reviewing](https://www.cs.utexas.edu/users/mckinley/notes/reviewing.html), Hill & McKinley, 2005
 * [How (and How Not) to Write a Good Systems Paper](https://www.seltzer.com/margo/teaching/CS508.19/background/p264-levin.pdf), Levin & Redell, OSR 1983
 * [How to Write a Great Research Paper](https://www.microsoft.com/en-us/research/academic-program/write-great-research-paper/), Jones, 2016

Any publication recommended by [Onur Mutlu](https://people.inf.ethz.ch/omutlu/), renowned researcher in the area of computer systems, will do. However you're free to choose a paper published (in recent years) on conferences listed below:
  * MICRO: [IEEE/ACM International Symposium on Microarchitecture](https://www.microarch.org/)
  * ASPLOS: [International Conference on Architectural Support for Programming Languages and Operating Systems](https://asplos-conference.org/),
  * ISCA: [International Symposium on Computer Architecture](https://iscaconf.org/),
  * HPCA: [IEEE International Symposium on High-Performance Computer Architecture](https://hpca-conf.org/)

Each student will give three brief presentations - up to 30 minutes + discussion. To manage your time efficiently you may choose to reuse slides available on [Seminar in Computer Architecture 2021](https://safari.ethz.ch/architecture_seminar/fall2021/doku.php?id=schedule) (and previous years) course site."
Linux device drivers,6,"Wykład, rozwiązywanie zadań z komentowaniem, konsultowanie pomysłów na rozwiązywanie zadań programistycznych, indywidualna analiza kodu źródłowego, samodzielna praca programistyczna, indywidualny projekt programistyczny.",,False,False,"Zajęcia będą przez Krystiana Bacławskiego z Instytutu Informatyki UWr i Karola Gugałę z firmy [Antmicro](https://antmicro.com/). Krystian będzie odpowiadał za część teoretyczną, a Karol za część praktyczną zajęć. Zajęcia będą prowadzone zgodnie z poniższą tabelką:

| godziny | tydzień nieparzysty | tydzień parzysty     |
|:-------:|:-------------------:|:--------------------:|
|  xx-yy  | pracownia (Karol)   | wykład (Karol)       |
|  yy-zz  | wykład (Krystian)   | ćwiczenia (Krystian) |

Na ćwiczeniach będziemy omawiać najważniesze zagadnienia wprowadzające w świat jądra Linux. Omówimy tematy, których nie poruszono na przedmiocie ASK, tj. model uprzywilejowany procesora, kontrolery przerwań, MMIO, DMA, modele spójności pamięci, komunikację międzyprocesorową. Wprowadzimy Was w ograniczenia pracy w jądrze. Opowiemy o podziale jądra na dolną i górną połówkę, metodach delegacji zadań, synchronizacji wątków, algorytmach przydziału pamięci i wirtualnym systemie plików.

Na pracowniach będziemy rozwijać sterownik do sensora podłączonego przez magistralę I²C (IMU lub temperatury i wilgotności). Każde spotkanie zaczniemy od wprowadzenia do tematu, a dalej przełączymy się na pisanie kodu. Po każdych zajęciach sterownik będzie implementował coraz więcej funkcjonalności. System Linux będziemy uruchamiać pod kontrolą Renode symulującego płytkę rozwojową na procesorze RISC-V. Studenci w ramach projektu końcowego będą podpinać wybrany sensor do prawdziwego sprzętu, np. Arty-A7 100."
An Introduction to Finite and Classical Model Theory,6,"* wykład
* indywidualne/grupowe rozwiązywanie zadań
* rozwiązywanie zadań z komentowaniem
* dyskusja",,False,False,"**Przedmiot zostanie uruchomiony przy przynajmniej 10ciu chętnych. Docelowa godzina wykładu to poniedziałek 16:15-18:00.**

(Finite) model theory is a vital area of mathematical logic, which, from our perspective, serves as the foundation of relational database theory.
The classes will be about some selected topics from classical and finite model theory, which I found interesting or/and important. The lecture will be quite theoretical and the difficulty level of the presented content will vary. 
The classes are dedicated to students interested in theoretical computer science and math. Nevertheless, they should be accessible to students after their 3rd semester of bachelor studies. 
For students interested in doing research or writing a thesis on related topics, the classes are a good opportunity to kick-start something.

The lecture will contain:

1. An introduction + a few examples. The compactness theorem with a proof via Gödel's theorem. Some consequences of Compactness Theorem with application to inexpressibility in FO. 

2. Some important model-theoretic properties of FO: Craig Interpolation, Projective Beth Definability, Łoś-Tarski preservation theorem, Homomorphism preservation theorem. 
A bit about failures of the above theorems in the finite realm. 

3. Zero-one laws of FO, i.e. a property of FO that the probability of satisfaction of a first-order formula in a random structure is either 0 or 1. Inexpressivity via 0-1 law. Rado graphs, Fraisse limits, and a bit about omega-categoricity and complete theories. 

4. Ehrenfeucht-Fraisse games as the universal method for showing inexpressivity in FO. Games on linear orders, types, back-and-forth equivalence. Proof of Fraisse's theorem. We will discuss also some modifications of E-F games, e.g. pebble games and MSO games.

5. FO can express only local properties. Hanf's and Gaifman's localities, with proofs. Applications of localities to inexpressivity and to the construction of fixed-parameters-tractable meta-algorithms for query evaluation over structures of bounded degree.
Model theory can make formulae large.

7. Modal logic as a tamed fragment of FO. Characterisation theorems of Van-Benthem and Rosen. Some model theory of modal logic.


8. Order-invariant First-Order Logic, so a few words about how beautiful the finite model theory is. Is there a logic for PTime, and how the logicians are trying to show that P != NP. 

9. Fagin's theorem that problems definable in ESO are precisely those decidable in NP. A bit about FO spectra and the quest for a logic for P.

Lectures and exercise sessions will be given by Bartosz Bednarczyk. Preferably in English. 
Some of the lectures will be based on ""Elements of Finite Model Theory"" by Libkin (freely accessible here: https://homepages.inf.ed.ac.uk/libkin/fmt/fmt.pdf), lecture notes by Martin Otto (https://www2.mathematik.tu-darmstadt.de/~otto/LEHRE/FMT16.pdf), ""A shorter model theory"" book by Hedges and some recent papers.

**WARNING!**
The lectures and exercise sessions will be from 16:15pm to 6pm on **MONDAYS**. Please take this into account when voting for my class. There will be no way to change it as I'm in Dresden on Tuesdays, Wednesdays and Thursdays. 

**Exam:** 
The exam will be oral. You will be asked to prepare and present to me some of the proofs discussed during the lecture. 

**Requirements:** 
The class is dedicated to ambitious students that already had fun during ""Logic for Computer Scientists"" and enjoy theoretical results (and would like to learn something other than algorithms or programming languages). An obvious requirement is to have a good grade in the 1st-semester logic course.
When in doubt, contact BBE via email."
Introduction to algorithms in telecommunication,3,"1. Wykład z użyciem środków multimedialnych
2. Ćwiczenia praktyczne z dyskusją możliwych rozwiązań oraz praktycznym rozwiązaniem
problemów.
3. Studium przypadków na bazie podanych przykładów
4. Konsultacje bezpośrednio po wykładzie
5. Praca własna – samodzielne studia oraz przygotowanie do wykładu
6. Praca własna – samodzielne studia oraz przygotowanie do ćwiczeń
7. Praca własna – samodzielne studia oraz przygotowanie do laboratorium",,False,False,"**The course consists of 4 blocks taught by Nokia employees.** 


With this block of courses we would like to introduce students to signal processing algorithms in telecommunications. It would be an example of application of mathematical methods in engineering problems. However, these algorithms are in themselves an interesting scientific element which is being developed and are an engaging object of research. 
 
The course is structured in four independent blocks. Each block focuses on different real word use case that can be formulated as a fundamental mathematical problem.  Altogether, that will allow you to become familiar with a variety of issues related to mathematical methods in telecommunications."
Algorithmic Causality with Applications,2,"Wykład, rozwiązywanie zadań",,False,False,"**The course is given by Maciej Liśkiewicz.**

Discovering and understanding causal relationships is an important task of empirical sciences. For example, recognising the causes of diseases or economic crises is of great social interest. However, for ethical or economic reasons questions as “Does smoking cause lung cancer?” can be difficult to examine through direct experimentation. On the other hand, there are often available large amounts of observed data that can provide relevant information about these issues. The goal of causal inference — a quickly growing sub-area of AI — is to establish cause-effect relationships combining observed data with existing knowledge. The main focus of this course is on the algorithmic issues of causality that enable broad applications of the causal theory in AI and empirical sciences.

**A tentative schedule is to have three Friday meetings (28.10, 18.11, 2.12.2022).**"
Seminar: Modern Data Mining,3,"samodzielne czytanie literatury, prezentacja, dyskusja",,False,False,"_**UWAGA**: W przypadku takiej konieczności, w roku akademickim 2020/21 zajęcia mogą być prowadzone zdalnie przez Google Meet lub podobne narzędzie interaktywnej komunikacji._

This seminar focuses on advanced data mining algorithms for processing big, complex and unstructured data. It mainly concerns recommendation systems, dimensionality reduction with neighborhood embedding, temporal data mining and decision support systems. In recommendation systems, various approaches from simple collaborative filtering to advanced matrix factorization are presented and discussed in the context of their practical relevance, concerning not only the popular MSE or MAE measures, but also the coverage, diversity, and novelty of recommendations. In temporal data mining, beside the analysis of regular time series with machine learning methods, such as Support Vector Regression and Neural Networks, unstructured temporal data are studied. Additional topics may concern unstructured datasets, such as irregular multidimensional time series, GPS tracks or medical images."
Machine Learning,7,"* Lecture
* Programming assignments
* Written assignments
* Programming project",,False,False,"This course provides the fundamentals of Machine Learning, i.e. of designing programs that implement a data-driven, rather than hand-implemented behavior. 
The course provides a gentle introduction of the topic, but strives to provide enough details and intuitions to explain state-of-the-art ML approaches: ensembles of Decision Trees (Boosted Trees, Random Forests) and Neural Networks. 
Starting with simple linear and Bayesian models, we proceed to learn the concepts of trainable models, selecting the best model based on data, practical and theoretical ways of estimating model performance on new data, and the difference between discriminative and generative training. The course introduces mainstream algorithms for classification and regression including linear models, Naive Bayes, trees, ensembles. Practical sessions provide a hands-on experience on building models together with familiarizing Students with popular python-based tools like numpy, pandas and pytorch."
Proseminar: Data Visualisation,3,"Samodzielnie studiowanie książki, samodzielne poszukiwanie innych źródeł, prezentowanie przez studentów w czasie zajęć, samodzielna implementacja.",,False,False,"Seminarium ma się skupić na omawianiu różnych zasad i technik wizualizacji danych. Będzie to przegląd wszerz różnych zasad i rozwiązań, z akcentem rozłożonym równomiernie pomiędzy kwestiami estetycznymi, a praktycznymi.

Konkretniej, będziemy wspólnie czytać książkę [1]. Każdy ze uczestników będzie miał za zadanie zreferować temat przedstawiony w jednym z rozdziałów, uzupełniając treści tam przedstawione informacjami o tym, jak obecnie można tego typu wizualizacje implementować.

Na koniec każdy uczestnik będzie miał za zadanie przygotować 3 wizualizacje wybranych przez siebie danych na podstawie zdobytej wiedzy.

[1] Steele, J., & Iliinsky, N. (2010). Beautiful visualization: Looking at data through the eyes of experts. "" O'Reilly Media, Inc.""."
Information and Coding Theory,6,"* Ćwiczenia audytoryjne
* Wykład",,False,False,"Teoria informacji bada zagadnienia takie jak:
* mierzenie ilości informacji w ciągu danych,
* ograniczenia na przetwarzanie danych
* ograniczenia komunikacji.

Powstała jako próba odpowiedzi na pytania typu:
* jaki jest optymalny kompresor dla danego typu danych?
* jak szybko możemy przesyłać informacje przez kanał komunikacji?

Pytania te dość szybko doprowadziły do dużo bardziej ogólnych pytań, typu:
* jak mierzyć jakość kompresora?
* jak mierzyć prędkość przesyłu danych przez kanał komunikacji?

Podejście oferowane przez teorię informacji różni się od tego oferowanego przez ""analizę najgorszego przypadku"": w dużo większym stopniu skupia się ona na analizie procesu losowego i działania na ""losowych"" danych. Podejście to okazuje się skuteczne w praktyce — narzędzia i pojęcia stworzone przez teorię informacji są powszechnie używane przy analizie praktycznie implementowanych rozwiązań: kompresory bezstratne, korekcja błędów, przetwarzanie sygnałów…

Przedmiot zaczniemy od przedstawienia klasycznych zagadnień teorii informacji. Następnie skupimy się na zastosowaniu tych zagadnień: pokażemy dolne i górne granice dla kompresji danych, co więcej pokażemy, że wiele współcześnie stosowanych metod kompresji, pomimo faktu, że wydają się tylko heurystykami, ma teoretyczne podstawy lub teoretyczne analizy (omówimy zarówno bezstratne jak i stratne algorytmy). Oprócz klasycznych wyników pokażemy też te bardziej współczesne oraz pokażemy zastosowania teorii informacji w innych działach informatyki.


Przedmiot jest niezależny (i rozłączny) od przedmiotu Kompresja Danych. W porównaniu do Kompresji Danych ten przedmiot jest nastawiony w o wiele większym stopniu na aspekty teoretyczne, np. gdy Kompresja Danych przedstawia szereg algorytmów kompresji i daje intuicje, dlaczego działają, my pokażemy twierdzenia mówiące o skuteczności niektórych z nich.

Przedmiot ma pewne niewielkie przecięcie z przedmiotem Kody korekcyjne, usunięcie go jest trudne w reżimie wybieralności przedmiotów.

### Zagadnienia:

*    Miary informacji: entropia, dywergencja, informacja wspólna, łańcuchy Markowa, nierówność przetwarzania danych
*    Kompresja bezstratna: kody o zmiennej długości, źródła ergodyczne, kodowanie uniwersalne
*    Przykłady kompresji uniwersalnej: LZ77, kompresja gramatykowa.
*    Kompresja stratna: kwantyzacja, kompresja dźwięku i obrazu, transformata Karhunen–Loève, dyskretna transformata kosinusowa (DCT)
*    Przepustowość kanałów komunikacji: twierdzenie Shannona.
*    Inne zastosowania teorii informacji: uczenie maszynowe, generatory pseudolosowe.

### Wymagania wstępne:

Rachunek prawdopodobieństwa, Algebra, mile widziane: Matematyka dyskretna, Algorytmy i struktury danych.

### Literatura:

1. Thomas M. Cover, Joy A. Thomas, Elements of Information Theory. Wiley Series in Telecommunications, 1991.

2. Gareth A. Jones, Mary J. Jones, Information and Coding Theory. Springer, 2000.

3. David Salomon, Data Compression: The Complete Reference, Springer, 1998

Przedmiot będzie realizował część materiału z kursów innych uczelni: [MIT](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-441-information-theory-spring-2016/lecture-notes/), [University of Chicago](https://home.ttic.edu/~madhurt/courses/infotheory2017/index.html), [Stanford](https://web.stanford.edu/class/ee376a/outline.html)."
Introduction to cloud computing,2,"* Work with technological documentation and teaching materials in the form of videos, remote labs in the form of exercises on cloud platforms, including *challenge* exercises. 

* Consultation of progress of own work and project ideas. Group discussions.

* Individual design of a technology solution running in the cloud (e.g., application, CD/CI solution, data science project).",,False,False,"The course is aimed at students that would like to survey the basics of the services offered by the three main cloud providers (AWS, GCP, Azure). 

Students are supposed to *self-study* the topics using the  free teaching materials provided by Google, AWS or some other available tutorials.

The labs (15h) offer an opportunity for the students  to discuss any problems they have encountered during the self-study and also to demonstrate their progress and get the ECTS points. 
 
This course is also a good choice as the first course  taught in English."
Online algorithms,6,"* wykład
* rozwiązywanie zadań z komentowaniem
* indywidualne/grupowe rozwiązywanie zadań",,False,False,"**Przedmiot nie będzie odbywać się w trybie zdalnym**

W przypadku niektórych rzeczywistych zagadnień, takich jak szeregowanie zadań (scheduling), zarządzanie pamięcią podręczną, routing pakietów czy buforowanie danych w internecie (web caching), algorytm je rozwiązujacy musi działać w sposób online i dokonywać decyzji bez wiedzy lub z częściową wiedzą o przyszłości. Tematem wykładu będą takie właśnie zagadnienia i ich analiza. Podobnie jak w przypadku algorytmów aproksymacyjnych, interesować nas będą rozwiązania przybliżone. Pokażemy, jak dowodzić konkretnych gwarancji o jakości takich przybliżeń. Wykład prowadzony będzie w oparciu o podane poniżej książki i aktualne prace naukowe.

**Wymagania:**

* Algorytmy i struktury danych (M)
* Rachunek prawdopodobieństwa

**UWAGA:** Osoby, które nie spełniają powyższych wymagań, będą musiały
zaliczyć niepunktowany egzamin wstępny i zostaną zapisane tylko w przypadku
wolnych miejsc.

* Definicja konkurencyjności, przykładowe zagadnienia.
* Algorytmy zaznaczające: problem pamięci podręcznej, wpływ randomizacji, metryczne systemy zadań.
* Analiza zamortyzowana za pomocą funkcji potencjału: problem reorganizacji listy.
* Funkcje potencjału dla algorytmów randomizowanych.
* Zasada minimaksowa dla dowodzenia dolnych ograniczeń.
* Metoda podwajania: zastosowania do problemów eksploracji 
terenu i szeregowania.
* Techniki programowania liniowego: problem pokrywania zbiorami, routing. 
* Problem k-server: dolne ograniczenia, algorytm dla drzew.
* Technika factor-revealing LP: problem migracji pliku.
* Funkcje pracy: optymalny algorytm dla metrycznych systemów zadań.
* Problem routingu i rozłącznych ścieżek.
* Przybliżanie dowolnych metryk za pomocą drzew, zastosowania.

**Literatura:**

* Alan Borodin, Ran El-Yaniv: ""Online Computation and Competitive Analysis"". Cambridge University Press, 1998.
* Rajeev Motwani, Prabhakar Raghavan: ""Randomized Algorithms"". Cambridge University Press, 1995.
* Amos Fiat, Gerhard J. Woeginger: ""Online Algorithms, The State of the Art"". Springer, 1998
* Niv Buchbinder, Joseph Naor: ""The Design of Competitive Online Algorithms via a Primal–Dual Approach"". Foundations and Trends in Theoretical Computer Science, 2007"
History of Philosophy,5,"wykład, ćwiczenia",,False,False,"_W przypadku konieczności prowadzenia zajęć zdalnie, ten przedmiot będzie prowadzony przez MS Teams._

Tematy, problematyka i materiały na zajęcia z informatyki, w rok. akadem.
2018-2019, sem. letni.

Zakładane efekty kształcenia: student wykazuje się znajomością podstawowych
problemów z filozofii w proponowanym zakresie; relacji między filozofią a
nauką oraz między różnymi typami wiedzy naukowej, w stopniu umożliwiającym
interdyscyplinarny ogląd nauki. Zna i prawidłowo stosuje podstawową
terminologię filozoficzną (metodologiczną, logiczną itp.). Potrafi przedstawić
podstawowe zagadnienia z zakresu logiki i filozofii języka, szczególnie w
kontekście wiedzy naukowej; rozumie znaczenie i wpływ języka na procesy i
efekty poznawcze oraz mechanizmy budowania wiedzy naukowej. Zna i rozumie
historyczny kontekst, historyczne uwarunkowania dla omawianej problematyki.

Wykłady

30 godz., 15 spotkań

Dr Zbigniew Pietrzak – Instytut Filozofii WNS.

  1. Wprowadzenie: filozofia – dziedziny filozofii i przedmiot filozofii, min. pytanie o _arche_ – filozofia Jońska, Pitagorejczycy (liczba); głównie zagadnienia współczesne.
  2. Filozofia i historia nauki. Problem demarkacji nauki – nauka, pseudonauka, protonauka. Metodologiczne typy nauk: nomotetyczne, idiograficzne, formalne.
  3. Struktura nauki – prawa, teorie, związki między nimi.
  4. Filozofia i historia nauk przyrodniczych – filozofia naturalna, historia naturalna/historia natury, współczesne przyrodoznawstwo.
  5. Filozofia i historia nauk formalnych.
  6. Kryzys w nauce, kryzys w filozofii: źródła i konsekwencje (metodologiczne, heurystyczne, pojęciowe, strukturalne, społeczne itp.). Sprzeczności jako źródło kryzysu.
  7. Nabywanie języka – pogląd naturalistyczny i analityczny/metafizyczny.
  8. Język i poznanie - struktura i gramatyka w językach naturalnych.
  9. Język i poznanie - język a rzeczywistość.
  10. Język w nauce – kształtowanie pojęć, redefinicje. Od języka potocznego do języka sformalizowanego. Język jakościowy – język ilościowy.
  11. Język a rzeczywistość w nauce: realność i konwencjonalność pojęć. Realizm i antyrealizm w nauce; psychologizm i antypsychologizm.
  12. Problemy ontologiczne w informatyce – ontologia symbolu itp.
  13. Ewolucja umysłu – ewolucja wiedzy.
  14. Sztuczna inteligencja – perspektywy: biologii ewolucyjnej, filozofii umysłu (teorie umysłu), lingwistyczna (język), neuronauk.
  15. Podsumowanie.

Egzamin.

Literatura – szczegółowy wykaz tytułów zostanie przedstawiony na zajęciach.
(Szczegółowy plan tematów może jeszcze ulec modyfikacjom).

Ćwiczenia

30 godz., 15 spotkań

Dr Marcin Łazarz – Katedra Logiki i Metodologii Nauki WNS.

1-2. Liczba jako _arche_. Arytmetyzacja nauk (Platon, Pitagorejczycy).
Pitagorejska teoria liczb, punktualizm i odkrycie niewymierności. Liczby
naturalne, wymierne, rzeczywiste. Historia pojęcia ciągłości a jego pierwsza
poprawna definicja. Paradoksy Zenona z Elei i zagadnienie nieskończonych sum
liczbowych (szeregów).

3-4. Indukcjonizm i hipotetyzm. Poglądy Bacona i Kartezjusza w kwestii co jest
wartościową wiedzą i jak ją zdobywać. Metody naukowe.

  5. Prawda. Klasyczna definicja prawdy (Arystoteles, Platon) i nieklasyczne definicje prawdy: kartezjańska i koherencyjna definicja prawdy.
  6. Kryzys podstaw matematyki. Ufundowanie matematyki. Paradoksy teorii mnogości. Formalizm logicyzm i konstruktywizm. Logika intuicjonistyczna. Niekonstruktywne prawa logiki klasycznej. Konstruktywne dowody.
  7. Język nauk formalnych. Język pierwszego rzędu. Metoda aksjomatyczno-dedukcyjna (Platon, Euklides). Teorie aksjomatyczne.

8-9. Definicja prawdy Tarskiego. Znaczenie i model. Środki syntaktyczne i
środki semantyczne. Twierdzenie o pełności dla logiki predykatów. Modele
zamierzone.

10-11.Niesprzeczność i rozstrzygalność. Program Hilberta. Teorie niesprzeczne
i zupełne. Niezupełność. Hipoteza continuum. Twierdzenie Gödla o niezupełności
arytmetyki Peano.

  12. Umysł – teorie umysłu.

13-14. Sztuczna inteligencja.

  15. Zaliczenia.

Zaliczenie na ocenę.

Literatura – szczegółowy wykaz tytułów zostanie przedstawiony na zajęciach.
(Szczegółowy plan tematów może jeszcze ulec modyfikacjom).

Przygotował

Zbigniew Pietrzak

Instytut Filozofii WNS"
Functional Programming,6,"* Wykład
* Pracownia programistyczna",,False,False,"_Do r. akad. 2016/17 Programowanie funkcyjne było przedmiotem I2.T (JP Języki programowania i logika - 100%), od r. akad. 2017/18 - I1._  
      
  Programowanie funkcyjne jest stylem programowania opartym na obliczaniu wartości wyrażeń, w przeciwieństwie do programowania imperatywnego, wykorzystującego modyfikacje stanu programu przez instrukcje. Studenci znają już ten paradygmat z przedmiotu ""Metody programowania"", gdzie był wykorzystywany język Scheme, w którym jest stosowana typizacja dynamiczna.  
      
  Celem tego wykładu jest pogłębiona prezentacja programowania funkcyjnego. Paradygmat ten obecnie staje się bardzo popularny (również w językach imperatywnych), ponieważ wysoki poziom abstrakcji ułatwia składanie komponentów, a bezstanowość jest wykorzystywana w wysokopoziomowych mechanizmach programowania współbieżnego, które pozwalają pisać efektywne programy, wykorzystujące procesory wielordzeniowe.  

 W trakcie wykładu będą przedstawione pojęcia i techniki programowania funkcyjnego z wykorzystaniem dwóch języków z typizacją statyczną. OCaml (język z rodziny ML) wykorzystuje ewaluację gorliwą, najpopularniejszą w implementacjach języków programowania. Pozwala też programować imperatywnie i obiektowo.&nbsp; Język F# z platformy .Net jest w znacznym stopniu kompatybilny z językiem OCaml.   
    Haskell jest czystym językiem funkcyjnym z ewaluacją leniwą.  
      
Będzie omawiany m.in. system typów z polimorfizmem parametrycznym, funkcje wyższych rzędów, rekursja ogonowa, mechanizm dopasowania do wzorca, sygnatury, struktury, funktory i monady, klasy typów, strategie ewaluacji wyrażeń.   
      
Na zajęciach w pracowni studenci będą pisali proste programy, których tematyka będzie zsynchronizowana z zagadnieniami, omawianymi na wykładzie.&nbsp;   
      
Wymagania:  
Metody programowania

Nauczanie zdalne
W razie konieczności możliwe jest przejście na tryb zdalny. Materiały do wykładów będą umieszczane na SKOSie (jak zawsze), a wykład będzie prowadzony on-line z wykorzystaniem wybranej platformy. Zadania na pracownię też będą umieszczane na SKOSie (jak zwykle), rozwiązania studentów będą dostarczane za pośrednictwem SKOSa, a prowadzący zapewnią informację zwrotną. Tu również przewiduję bezpośrednią interakcję między prowadzącym i studentami.

**Przedmiot będzie wykładał Piotr Polesiuk.**"
Numerical analysis (M),12,"* wykład,
* wykład interaktywny,
* prezentacja,
* live coding,
* ćwiczenia z systemem deklaracji (rozwiązywanie zadań teoretycznych i typu włącz komputer z komentowaniem),
* indywidualne/grupowe rozwiązywanie zadań/problemów,
* analiza algorytmów pod kątem ich poprawności, złożoności i efektywności.",,False,False,"Celem zajęć jest przedstawienie podstawowych metod i algorytmów rozwiązywania typowych zadań obliczeniowych.
      
**Analiza błędów**
          Arytmetyka numeryczna. Uwarunkowanie zadania. Algorytmy numerycznie poprawne.  

**Rozwiązywanie równań nieliniowych**  
          Ogólna teoria metod iteracyjnych. Metody: bisekcji, Newtona  
          i siecznych. Równania algebraiczne.         

**Interpolacja funkcji**       
          Wzór interpolacyjny Lagrange'a. Reszta wzoru interpolacyjnego.  
          Wzór interpolacyjny Newtona. Interpolacja Hermite'a.  
          Interpolacja za pomocą funkcji sklejanych III stopnia.  

**Aproksymacja funkcji**             
          Aproksymacja średniokwadratowa  za pomocą wielomianów –  
          wielomiany ortogonalne, twierdzenie o _n_ -tym wielomianie optymalnym.  
          Aproksymacja jednostajna – twierdzenie  
          o alternansie, informacja o algorytmie  
          Remeza konstrukcji wielomianu optymalnego,  
          wielomiany prawieoptymalne.  

**Całkowanie numeryczne**  
          Kwadratura liniowa. Reszta i rząd kwadratury. Zbieżność ciągu  
          kwadratur. Kwadratury interpolacyjne.  
          Kwadratury Newtona-Cotesa. Wzory złożone: trapezów i Simpsona.  
          Metoda Romberga. Kwadratury Gaussa.  

**Rozwiązywanie układów równań liniowych**  
          Uwarunkowanie zadania. Rozkład macierzy kwadratowej na iloczyn  
          macierzy trójkątnych. Metoda eliminacji Gaussa.   
          Metody iteracyjne rozwiązywania układów równań liniowych.  
                       
**Literatura**  
- A. Björck, G. Dahlquist, Metody numeryczne, PWN, 1987.
- M. Dryja, J.i M. Jankowscy, Przegląd metod i algorytmów numerycznych, cz. 1 i 2, WNT, 1988.
- D. Kincaid, W. Cheney, Analiza numeryczna, WNT, 2005.
- G. Dahlquist, A. Björck, Numerical Methods in Scientific Computing, Vol. I, SIAM, 2008.   
- W. Gautschi, Numerical Analysis. An Introduction, Birkhäuser, 1997.
- G. Hämmerlin, K.-H. Hoffmann, Numerical Mathematics, Springer-Verlag, 1991.
- A. Quarteroni, R. Sacco, F. Saleri, Numerical Mathematics, Springer-Verlag, 2000."
Efficient Implementation of Algorithms,4,"Indywidualne rozwiązywanie zadań, prezentacja pomysłów i rozwiązań",,False,False,"Każde spotkanie ma dwie części. Podczas pierwszej studenci rozwiązują zadania
typowe (w większym lub mniejszym stopniu) dla zawodów programistycznych typu
AMPPZ, CERC,… . W drugiej części dyskutujemy nad metodami ich rozwiązań.

Cel zajęć wybiega daleko poza przygotowania drużyn reprezentujących UWr na
zawodach. Jak pokazuje wieloletnie doświadczenie, zajęcia w zasadniczy sposób
pogłębiają zrozumienie algorytmów, poprawiają biegłość w programowaniu i
umiejętność rozwiązywania problemów. To są umiejętności chyba najczęściej
sprawdzane obecnie przy rekrutacji przez „topowe firmy” (Google, Microsoft,…)

_Uwagi:_ przedmiot przystępny już dla bardziej zaangażowanych studentów 1-go
roku

zalecane Algorytmy i Struktury Danych"
Front-end apps development,5,"Wykład interaktywny, live coding, dyskusja, indywidualne rozwiązywanie zadań",,False,False,"Choć frontend jest nieodłączną częścią większości aplikacji webowych, to proces jego wytwarzania znacząco zmienił się w ostatnich latach. Gwałtowny rozwój frameworków, bibliotek i preprocesorów sprawił, że programiści borykają się dziś z zupełnie innymi problemami niż jeszcze dekadę temu. Za zmianami ciężko jest nadążyć, nic więc dziwnego, że wiele osób nie rozumie z czym wiąże się rola Frontend Developera.

Wykład ma na celu przybliżyć słuchaczom tę rolę i związane z nią odpowiedzialności, a także przekazać wiedzę umożliwiającą wytworzenie pierwszych frontendowych aplikacji. Poruszymy zarówno aspekty techniczne jak i te bardziej teoretyczne, by nie zależeć od konkretnych rozwiązań.

Program przedmiotu będzie oparty na [Roadmapie Frontendowej](https://roadmap.sh/frontend). Przejdziemy przez interesujący podzbiór zagadnień, gdzieniegdzie dorzucając dodatkowe tematy.

Poniższa lista tematów jest orientacyjna. W zależności od potrzeb, na niektóre z nich poświęcimy więcej (lub mniej) czasu.

1. Podstawy działania Internetu
1. HTML
    * Podstawy HTML
    * Dobre praktyki i konwencje
    * Formularze i walidacja
1. CSS
    * Podstawy CSS
    * Tworzenie Layoutu: Float, Grid, Flexbox, Positioning, Box Model
    * Responsywny design
    * Preprocesory CSS
    * BEM
1. JavaScript
    * Podstawy JavaScriptu
    * Manipulacja DOM
    * ES6+
    * Zaawansowane pojęcia: Hoisting, Event Bubbling, Scope, Prototype, Shadow DOM
    * Event Loop
    * TypeScript
1. Komunikacja z Backendem
    * REST, *SOAP?*, *GraphQL?*
1. Menadżer Pakietów
1. Narzędzia
    * Bundlery: Webpack, EsBuild
    * NPM
    * Lintery i formatery
1. Frameworki/Biblioteki
    * Przegląd dostępnych opcji
    * Podstawy React'a
1. Nowoczesny CSS
    * Styled Components
    * CSS Modules
    * Frameworki CSS: Material, Bootstrap, inne?
1. Testowanie Aplikacji
1. Optymalizacja 

*Wymagania: podstawowa umiejętność programowania, podstawowa znajomość dowolnego systemu kontroli wersji*"
Computational complexity,6,"wykład, rozwiązywanie zadań z komentowaniem, indywidualne i zespołowe rozwiązywanie zadań.",,False,False,"Celem wykładu jest przedstawienie kluczowych koncepcji i twierdzeń teorii
złożoności obliczeniowej, ktore powinien znać każdy dobrze wykształcony
magister informatyki. Po uporządkowaniu wiedzy nabytej na JFiZ, przedstawimy
trochę podstawowych pojęć i faktow, a następnie przejdziemy do omawiania
zagadnień z poniższej listy.



  * Pamięć vs Czas
    * Twierdzenie Hopcrofta, Paula, Valianta:  o tym, że pamięć jest cenniejszym zasobem niż czas obliczeń i że można przekonać się o tym grając w kamyki
  * Dopełnienie vs Niedeterminizm
    * Twierdzenie Immermana-Szelepcsenyi'ego: o tym, że niedeterministycznie można nie tylko zgadywać istnienie rozwiązań, ale także ich nieistnienie 
  * Determinizm vs Niedeterminizm
    * Twierdzenie Paula, Pippengera, Szemeredi'ego i Trottera: o tym, że umiejętność zgadywania jest istotnie pomocna (przynajmniej wtedy, gdy mamy mało czasu)
  * Struktura zbiorow NP-trudnych
    * Twierdzenie Mahaneya: o tym, że zbiory NP-zupełne nie mogą mieć mało elementow, no chyba, że P=NP (w co nikt nie wierzy)
  * Dowody interakcyjne
    * Twierdzenie Shamira (IP=PSPACE): m.in. o tym, że ograniczony (w mocy obliczeniowej)  krol Artur może skorzystać podczas gry w szachy z podpowiedzi nieskończenie mądrego Merlina i, co ważniejsze, nie dać mu się oszukać
  * Trudność zliczania
    * Twierdzenie Valianta: o znaczeniu „-1""  w definicji wyznacznika macierzy albo inaczej o tym , że obliczanie permanentu macierzy jest nieporownanie trudniejsze od obliczania wyznacznika (no chyba, że P=NP:-)
    * Twierdzenie Tody, o tym, że umiejętność szybkiego zliczania cykli Hamiltona w grafie ma daleko większe konsekwencje niż mogłoby się to wydawać
    * Twierdzenie Valianta, Vazirani'ego o tym, że szukanie igły w stogu siana jest tak samo trudne niezależnie od liczby igieł w stogu (przynajmniej wtedy, gdy igłami są podstawienia spełniające formułę SAT, a stog tworzą podstawienia niespełniające)
  * Algorytmy probabilistyczne:
    * Twierdzenie Beigela, Reingolda, Spielmana: o tym jak policzyć przekonanych w więcej niż w 50%
  * Złożoność problemu rozpoznawania liczb pierwszych
    * Twierdzenie Pratta  (Primes \in NP) o tym, że istnieją proste dowody pierwszości liczb, 
    * Twierdzenie Agrawala-Kayala-Saxeny (Primes \in P) o tym, że warto uczyć się algebry, by dowodow na pierwszość nie trzeba było zgadywać
  * Spojność w grafach
    * Twierdzenie Reingolda: o tym, że łatwiej jest sprawdzać połączenia, gdy drogi są dwukierunkowe
  * Moc probabilistycznej weryfikacji
    * Twierdzenie Arory, Safry o  tym, że do nabrana przekonania o spełnialności formuły wystarczy wylosować stałą liczbę bitow z pewnego dowodu



Większość z powyższych twierdzeń udowodnimy. W niektorych przypadkach będziemy
jednak musieli zadowolić się przedstawieniem jedynie idei dowodu L"
